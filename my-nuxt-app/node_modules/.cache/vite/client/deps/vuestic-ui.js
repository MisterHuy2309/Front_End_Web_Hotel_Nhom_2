import {
  autoUpdate,
  computePosition,
  flip,
  getNodeName,
  isNode,
  offset,
  shift,
  size
} from "./chunk-DTD6TJFQ.js";
import "./chunk-G3PMV62Z.js";

// node_modules/vuestic-ui/dist/es/src/services/color/presets.js
var presets = {
  light: {
    // Accent
    primary: "#154EC1",
    secondary: "#767C88",
    success: "#3D9209",
    info: "#158DE3",
    danger: "#E42222",
    warning: "#FFD43A",
    // Background Colors
    backgroundPrimary: "#f6f6f6",
    backgroundSecondary: "#FFFFFF",
    backgroundElement: "#ECF0F1",
    backgroundBorder: "#DEE5F2",
    // Text Colors
    textPrimary: "#262824",
    textInverted: "#FFFFFF",
    // Misc
    shadow: "rgba(0, 0, 0, 0.12)",
    focus: "#49A8FF",
    transparent: "rgba(0, 0, 0, 0)"
  },
  dark: {
    // Accent
    primary: "#3472F0",
    secondary: "#767C88",
    success: "#66BE33",
    info: "#3EAAF8",
    danger: "#F34030",
    warning: "#FFD952",
    // Background Colors
    backgroundPrimary: "#050A10",
    backgroundSecondary: "#1F262F",
    backgroundElement: "#131A22",
    backgroundBorder: "#3D4C58",
    // Text Colors
    textPrimary: "#F1F1F1",
    textInverted: "#0B121A",
    // Misc
    shadow: "rgba(255, 255, 255, 0.12)",
    focus: "#49A8FF",
    transparent: "rgba(0, 0, 0, 0)"
  }
};

// node_modules/vuestic-ui/dist/es/src/services/breakpoint/index.js
var vaBreakpointSymbol = Symbol("vaBreakpoint");
var defaultThresholds = {
  xs: 0,
  sm: 640,
  md: 1024,
  lg: 1440,
  xl: 1920
};
var getBreakpointDefaultConfig = () => ({
  enabled: true,
  bodyClass: true,
  thresholds: defaultThresholds
});

// node_modules/vuestic-ui/dist/es/src/services/global-config/types.js
var defineVuesticConfig = (config) => config;

// node_modules/vuestic-ui/dist/es/src/components/va-message-list/VaMessageListWrapper.vue_vue_type_script_setup_true_lang.js
import { defineComponent as defineComponent3, computed as computed17, toRef as toRef2, openBlock as openBlock3, createElementBlock as createElementBlock3, createVNode, unref as unref3, withCtx as withCtx3, renderSlot as renderSlot3, normalizeProps as normalizeProps2, guardReactiveProps as guardReactiveProps2 } from "vue";

// node_modules/vuestic-ui/dist/es/src/components/va-message-list/VaMessageList.vue_vue_type_script_setup_true_lang.js
import { defineComponent as defineComponent2, computed as computed13, openBlock as openBlock2, createElementBlock as createElementBlock2, Fragment as Fragment2, renderSlot as renderSlot2, normalizeProps, guardReactiveProps, unref as unref2, mergeProps as mergeProps2, createElementVNode, renderList, createBlock as createBlock3, createCommentVNode as createCommentVNode2, createTextVNode as createTextVNode2, toDisplayString as toDisplayString2 } from "vue";

// node_modules/vuestic-ui/dist/es/src/services/config-transport/createRenderFn.js
import { withCtx, h, Text, isVNode, createBlock } from "vue";
var renderSlotNode = (node, ctx = null) => {
  return withCtx(() => [node], ctx);
};
var makeVNode = (node) => {
  if (typeof node === "string") {
    return h(Text, node);
  }
  return isVNode(node) ? node : createBlock(node);
};
var renderSlots = (slots, ctx = null) => {
  return Object.keys(slots).reduce((acc, slotName) => {
    const slot = slots[slotName];
    acc[slotName] = typeof slot === "function" ? slot : renderSlotNode(slot, ctx);
    return acc;
  }, {});
};
var createRenderFn = (component) => {
  const originalRenderFn = component.render || component.ssrRender;
  if (!originalRenderFn) {
    return void 0;
  }
  const compiledRenderedFn = originalRenderFn.name === "_sfc_render" || originalRenderFn.name === "_sfc_ssrRender";
  return function(...args) {
    const ctx = args[0];
    const slots = ctx.$.slots;
    const customCtx = new Proxy(ctx, {
      get(target, key) {
        if (key === "$slots") {
          return renderSlots(slots);
        }
        return target[key];
      }
    });
    const thisArg = compiledRenderedFn ? void 0 : customCtx;
    return originalRenderFn.call(thisArg, customCtx, ...args.slice(1));
  };
};

// node_modules/vuestic-ui/dist/es/src/services/config-transport/createSetupFn.js
import { getCurrentInstance as getCurrentInstance4, computed as computed5, shallowReadonly } from "vue";

// node_modules/vuestic-ui/dist/es/src/utils/omit.js
var omit = (o, keys) => {
  return Object.keys(o).filter((key) => !keys.includes(key)).reduce((acc, key) => {
    acc[key] = o[key];
    return acc;
  }, {});
};

// node_modules/vuestic-ui/dist/es/src/composables/useChildComponents.js
import { computed, provide, getCurrentInstance, inject } from "vue";
var CHILD_COMPONENT_PROP_PREFIX = "child:";
var CHILD_COMPONENTS_INJECT_KEY = "$va:childComponents";
var defineChildProps = (obj) => {
  return Object.keys(obj).reduce((acc, key) => {
    const childName = `${CHILD_COMPONENT_PROP_PREFIX}${key}`;
    acc[childName] = {
      type: Object,
      required: false,
      default: void 0
    };
    return acc;
  }, {});
};
var useChildComponents = (props) => {
  const childProps = computed(() => {
    const propNames = Object.keys(props);
    return propNames.reduce((acc, propName) => {
      if (propName.startsWith(CHILD_COMPONENT_PROP_PREFIX)) {
        const childName = propName.slice(CHILD_COMPONENT_PROP_PREFIX.length);
        acc[childName] = props[propName];
      }
      return acc;
    }, {});
  });
  provide(CHILD_COMPONENTS_INJECT_KEY, childProps);
};
var injectChildPropsFromParent = () => {
  var _a2;
  const childName = (_a2 = getCurrentInstance()) == null ? void 0 : _a2.attrs["va-child"];
  if (!childName) {
    return null;
  }
  const childProps = inject(CHILD_COMPONENTS_INJECT_KEY);
  if (!(childProps == null ? void 0 : childProps.value)) {
    return null;
  }
  return computed(() => childProps.value[childName]);
};

// node_modules/vuestic-ui/dist/es/src/services/config-transport/createProps.js
var KEBAB_CASE_REGEX = /([a-z0-9])([A-Z])/g;
var toKebabCase = (str) => str.replace(KEBAB_CASE_REGEX, "$1-$2").toLowerCase();
var findCamelCased = (obj, key) => {
  if (key in obj) {
    return obj[key];
  }
  return obj[toKebabCase(key)];
};
var createProps = (instance, propsFromConfig) => {
  const instanceProps = instance.props;
  const childPropsFromParent = injectChildPropsFromParent();
  return new Proxy(instanceProps, {
    get: (target, key) => {
      var _a2, _b;
      if (typeof key !== "string") {
        return target[key];
      }
      const childProp = (_a2 = childPropsFromParent == null ? void 0 : childPropsFromParent.value) == null ? void 0 : _a2[key];
      if (childProp !== void 0) {
        return childProp;
      }
      const incomingProps = instance.vnode.props || {};
      const originalProp = target[key];
      const incomingProp = findCamelCased(incomingProps, key);
      if (incomingProp !== void 0) {
        return originalProp;
      }
      const propFromConfig = (_b = propsFromConfig.value) == null ? void 0 : _b[key];
      if (propFromConfig !== void 0) {
        return propFromConfig;
      }
      return originalProp;
    }
  });
};

// node_modules/vuestic-ui/dist/es/src/services/config-transport/createAttrs.js
import { normalizeClass, normalizeStyle } from "vue";
var createAttrs = (instance, propsFromConfig) => {
  const instanceAttrs = instance.attrs;
  return new Proxy(instanceAttrs, {
    get: (target, key) => {
      var _a2;
      if (typeof key !== "string") {
        return target[key];
      }
      if (key === "class") {
        return normalizeClass([propsFromConfig.value.class, instanceAttrs.class]);
      }
      if (key === "style") {
        return normalizeStyle([propsFromConfig.value.style, instanceAttrs.style]);
      }
      const attrFromConfig = (_a2 = propsFromConfig.value) == null ? void 0 : _a2[key];
      if (attrFromConfig !== void 0) {
        return attrFromConfig;
      }
      return target[key];
    },
    ownKeys(target) {
      return [.../* @__PURE__ */ new Set([...Object.keys(instanceAttrs), ...Object.keys(propsFromConfig.value)])];
    },
    getOwnPropertyDescriptor(target, key) {
      return Reflect.getOwnPropertyDescriptor(propsFromConfig.value, key) ?? Reflect.getOwnPropertyDescriptor(instanceAttrs, key);
    }
  });
};

// node_modules/vuestic-ui/dist/es/src/services/config-transport/createSlots.js
import { computed as computed2 } from "vue";
var SLOT_PREFIX = "slot:";
var createSlots = (instance, propsFromConfig) => {
  const instanceSlots = instance.slots;
  const childPropsFromParent = injectChildPropsFromParent();
  const slotsFromConfig = computed2(() => {
    return Object.keys(propsFromConfig.value).reduce((acc, key) => {
      if (key.startsWith(SLOT_PREFIX)) {
        acc[key.slice(SLOT_PREFIX.length)] = propsFromConfig.value[key];
      }
      return acc;
    }, {});
  });
  return new Proxy(instanceSlots, {
    get: (target, key) => {
      var _a2, _b;
      if (typeof key !== "string") {
        return target[key];
      }
      const prefixedKey = `${SLOT_PREFIX}${key}`;
      const childSlot = (_a2 = childPropsFromParent == null ? void 0 : childPropsFromParent.value) == null ? void 0 : _a2[prefixedKey];
      if (childSlot !== void 0) {
        return renderSlotNode(makeVNode(childSlot));
      }
      const originalSlot = target[key];
      if (originalSlot !== void 0) {
        return originalSlot;
      }
      const propFromConfig = (_b = slotsFromConfig.value) == null ? void 0 : _b[key];
      if (propFromConfig !== void 0) {
        return renderSlotNode(makeVNode(propFromConfig));
      }
      return originalSlot;
    },
    ownKeys(target) {
      return [.../* @__PURE__ */ new Set([...Object.keys(instanceSlots), ...Object.keys(slotsFromConfig.value)])];
    },
    getOwnPropertyDescriptor(target, key) {
      return Reflect.getOwnPropertyDescriptor(slotsFromConfig.value, key) ?? Reflect.getOwnPropertyDescriptor(instanceSlots, key);
    }
  });
};

// node_modules/vuestic-ui/dist/es/src/composables/useLocalConfig.js
import { computed as computed3, inject as inject2, provide as provide2 } from "vue";
var LocalConfigKey = "VaLocalConfig";
var CONFIGS_DEFAULT = computed3(() => []);
function useLocalConfig() {
  return inject2(LocalConfigKey, CONFIGS_DEFAULT);
}
function provideLocalConfig(config) {
  provide2(LocalConfigKey, config);
}
function useLocalConfigProvider(config) {
  const prevChain = useLocalConfig();
  const nextChain = computed3(() => [...prevChain.value, config.value]);
  provideLocalConfig(nextChain);
}

// node_modules/vuestic-ui/dist/es/src/services/component-config/utils/use-component-config-props.js
import { computed as computed4 } from "vue";

// node_modules/vuestic-ui/dist/es/src/utils/isNilValue.js
var nilValues = [null, void 0, ""];
var nullOrUndefined = [null, void 0];
var isNilValue = (value) => {
  return nilValues.includes(value);
};
var notNil = (value) => !isNilValue(value);
var isNil = (value) => {
  return nullOrUndefined.includes(value);
};

// node_modules/vuestic-ui/dist/es/src/services/current-app.js
import { getCurrentInstance as getCurrentInstance2, inject as inject$1 } from "vue";

// node_modules/vuestic-ui/dist/es/src/utils/env.js
var processShim = typeof process !== "undefined" ? process : {};
var envShim = processShim.env || {};
var nodeEnv = envShim.NODE_ENV || "";
var isDev = typeof __DEV__ !== "undefined" ? __DEV__ : !["prod", "production"].includes(nodeEnv);

// node_modules/vuestic-ui/dist/es/src/utils/console.js
var warn = (...attrs) => {
  if (isDev) {
    console.warn(...attrs);
  }
  return false;
};
var throwError = (message) => {
  throw new Error(`[Vuestic] ${message}`);
};

// node_modules/vuestic-ui/dist/es/src/services/current-app.js
var currentApp = null;
var prevRegisteredApp = null;
var setCurrentApp = (newApp) => {
  if ((prevRegisteredApp == null ? void 0 : prevRegisteredApp._instance) === null) {
    prevRegisteredApp = null;
  }
  if (newApp === null && prevRegisteredApp === null) {
    return;
  }
  prevRegisteredApp = currentApp;
  currentApp = newApp;
};
var getCurrentApp = () => currentApp;
var inject3 = (key, value = void 0) => {
  var _a2;
  const injectedFromApp = (_a2 = getCurrentApp()) == null ? void 0 : _a2._context.provides[key];
  const vm = getCurrentInstance2();
  if (vm) {
    return inject$1(key, value);
  }
  return injectedFromApp ?? throwError("You're using Vuestic composable outside Vue app. Since you registered Vuestic in multiple apps, composables can not be used outside setup function anymore.");
};

// node_modules/vuestic-ui/dist/es/src/utils/is-object.js
var isObject = (obj) => {
  return obj !== null && typeof obj === "object";
};

// node_modules/vuestic-ui/dist/es/src/utils/clone-deep.js
var cloneDeep = (source) => {
  if (source === null || typeof source !== "object") {
    return source;
  }
  if (Array.isArray(source)) {
    return source.map(cloneDeep);
  }
  if (source instanceof Date) {
    return new Date(source.getTime());
  }
  if (source instanceof RegExp) {
    return new RegExp(source.source, source.flags);
  }
  if (source instanceof Map) {
    return new Map(Array.from(source.entries()).map(([key, value]) => [key, cloneDeep(value)]));
  }
  if (source instanceof Set) {
    return new Set(Array.from(source.values()).map(cloneDeep));
  }
  if (isObject(source)) {
    return Object.keys(source).reduce((acc, key) => {
      acc[key] = cloneDeep(source[key]);
      return acc;
    }, {});
  }
  if (typeof source === "function") {
    return source;
  }
  return source;
};

// node_modules/vuestic-ui/dist/es/src/services/global-config/global-config.js
import { ref, getCurrentInstance as getCurrentInstance3 } from "vue";

// node_modules/vuestic-ui/dist/es/src/utils/merge-deep.js
var isObject2 = (obj) => obj && typeof obj === "object" && !Array.isArray(obj);
var mergeDeep = (target, source) => {
  if (!isObject2(target)) {
    target = {};
  }
  Object.keys(source).forEach((key) => {
    const targetValue = target[key];
    const sourceValue = source[key];
    if (sourceValue instanceof RegExp || sourceValue instanceof Date) {
      target[key] = sourceValue;
    } else if (isObject2(targetValue) && isObject2(sourceValue)) {
      target[key] = mergeDeep(Object.create(
        Object.getPrototypeOf(targetValue),
        Object.getOwnPropertyDescriptors(targetValue)
      ), sourceValue);
    } else {
      target[key] = sourceValue;
    }
  });
  return target;
};
var mergeDeepMultiple = (...objects) => {
  return objects.reduce((acc, obj) => mergeDeep(acc, obj), {});
};

// node_modules/vuestic-ui/dist/es/src/services/colors-classes/config/default.js
var ColorsClassesPresets = [
  {
    prefix: "bg",
    property: "background-color"
  },
  {
    prefix: "text",
    property: ["color", "fill"]
  }
];
var getColorsClassesDefaultConfig = () => ColorsClassesPresets;

// node_modules/vuestic-ui/dist/es/src/services/color/config/make-config.js
var makeColorsConfig = (values) => ({
  ...values,
  get variables() {
    return this.presets[this.currentPresetName];
  },
  set variables(value) {
    this.presets[this.currentPresetName] = value;
  }
});

// node_modules/vuestic-ui/dist/es/src/services/color/config/default.js
var getColorDefaultConfig = () => makeColorsConfig({
  threshold: 150,
  presets: {
    light: presets.light,
    dark: presets.dark
  },
  currentPresetName: "light"
});

// node_modules/vuestic-ui/dist/es/src/services/icon/types/define-aliases.js
var defineIconAliases = (aliases) => aliases;

// node_modules/vuestic-ui/dist/es/src/services/icon/presets/vuestic-aliases.js
var VuesticIconAliases = defineIconAliases([
  {
    name: "va-unsorted",
    to: "swap_vert"
  },
  {
    name: "va-sort-asc",
    to: "va-arrow-up"
  },
  {
    name: "va-sort-desc",
    to: "va-arrow-down"
  },
  {
    name: "va-arrow-first",
    to: "mi-first_page"
  },
  {
    name: "va-arrow-last",
    to: "mi-last_page"
  },
  {
    name: "va-arrow-right",
    to: "mi-chevron_right"
  },
  {
    name: "va-arrow-left",
    to: "mi-chevron_left"
  },
  {
    name: "va-arrow-down",
    to: "mi-expand_more"
  },
  {
    name: "va-arrow-up",
    to: "mi-expand_less"
  },
  {
    name: "va-calendar",
    to: "mi-calendar_today"
  },
  {
    name: "va-delete",
    to: "mi-delete_outline"
  },
  {
    name: "va-check",
    to: "mi-check"
  },
  {
    name: "va-check-circle",
    to: "mi-check_circle"
  },
  {
    name: "va-warning",
    to: "mi-warning"
  },
  {
    name: "va-clear",
    to: "mi-highlight_off"
  },
  {
    name: "va-close",
    to: "mi-close"
  },
  {
    name: "va-loading",
    to: "mi-loop"
  },
  {
    name: "va-plus",
    to: "mi-add"
  },
  {
    name: "va-minus",
    to: "mi-remove"
  }
]);

// node_modules/vuestic-ui/dist/es/src/services/icon/presets/fonts.js
var VuesticIconFonts = [
  {
    name: "mi-{icon}",
    class: "material-icons",
    resolve: ({ icon }) => ({ content: icon })
  },
  // Fallback
  {
    name: "{icon}",
    class: "material-icons",
    resolve: ({ icon }) => ({ content: icon })
  }
];

// node_modules/vuestic-ui/dist/es/src/services/icon/create-icons-config.js
var createIconsConfig = (config) => {
  config.aliases = config.aliases || [];
  config.fonts = config.fonts || [];
  return [
    ...config.aliases,
    ...VuesticIconAliases,
    ...config.fonts,
    ...VuesticIconFonts
  ];
};

// node_modules/vuestic-ui/dist/es/src/services/icon/config/default.js
var getIconDefaultConfig = () => createIconsConfig({});

// node_modules/vuestic-ui/dist/es/src/services/component-config/config/default.js
var getComponentsDefaultConfig = () => (
  // TODO: Should be handled in size service
  {
    VaIcon: {
      sizesConfig: {
        defaultSize: 18,
        sizes: {
          small: 14,
          medium: 18,
          large: 24
        }
      }
    },
    VaRating: {
      sizesConfig: {
        defaultSize: 18,
        sizes: {
          small: 14,
          medium: 18,
          large: 24
        }
      }
    },
    all: {},
    presets: {
      VaButton: {
        default: {
          backgroundOpacity: 1,
          hoverBehavior: "mask",
          hoverOpacity: 0.15,
          pressedBehavior: "mask",
          pressedOpacity: 0.13
        },
        primary: {
          backgroundOpacity: 0.1,
          hoverBehavior: "opacity",
          hoverOpacity: 0.07,
          pressedBehavior: "opacity",
          pressedOpacity: 0.13
        },
        secondary: {
          backgroundOpacity: 0,
          hoverBehavior: "opacity",
          hoverOpacity: 0.07,
          pressedBehavior: "opacity",
          pressedOpacity: 0.13
        },
        plain: {
          plain: true,
          hoverBehavior: "mask",
          hoverOpacity: 0.15,
          pressedBehavior: "mask",
          pressedOpacity: 0.13
        },
        plainOpacity: {
          plain: true,
          textOpacity: 0.6,
          hoverBehavior: "opacity",
          hoverOpacity: 1,
          pressedBehavior: "opacity",
          pressedOpacity: 0.9
        }
      },
      VaInputWrapper: {
        solid: {
          background: "backgroundElement"
        },
        bordered: {
          class: "va-input-wrapper--bordered",
          background: "backgroundElement"
        }
      },
      VaCheckbox: {
        solid: {
          style: "--va-checkbox-background: var(--va-background-element)"
        }
      },
      VaRadio: {
        solid: {
          style: "--va-radio-background: var(--va-background-element)"
        }
      },
      VaMenu: {
        context: {
          cursor: true,
          placement: "right-start",
          trigger: "right-click"
        }
      }
    }
  }
);

// node_modules/vuestic-ui/dist/es/src/services/i18n/config/default.js
var getI18nConfigDefaults = () => ({
  // PROPS
  /** Select search field default text */
  search: "Search",
  /** Select no options text */
  noOptions: "Items not found",
  /** Modal Ok button default text */
  ok: "OK",
  /** Modal Cancel button default text */
  cancel: "Cancel",
  /** FileUpload default button text */
  uploadFile: "Upload file",
  /** FileUpload default undo button text */
  undo: "Undo",
  /** FileUpload default dropzone text */
  dropzone: "Drop files here to upload",
  /** FileUpload default file deleted alert text */
  fileDeleted: "File deleted",
  // Aria attributes
  /** Alert close button aria-label */
  closeAlert: "close alert",
  backToTop: "back to top",
  toggleDropdown: "toggle dropdown",
  carousel: "carousel",
  goPreviousSlide: "go previous slide",
  goNextSlide: "go next slide",
  goSlide: "go slide {index}",
  slideOf: "slide {index} of {length}",
  close: "close",
  openColorPicker: "open color picker",
  colorSelection: "color selection",
  colorName: "color {color}",
  decreaseCounter: "decrease counter",
  increaseCounter: "increase counter",
  selectAllRows: "select all rows",
  sortColumnBy: "sort column by {name}",
  selectRowByIndex: "select row {index}",
  resetDate: "reset date",
  nextPeriod: "next period",
  switchView: "switch view",
  previousPeriod: "previous period",
  removeFile: "remove file",
  reset: "reset",
  pagination: "pagination",
  goToTheFirstPage: "go to the first page",
  goToPreviousPage: "go to the previous page",
  goToSpecificPage: "go to the {page} page",
  goToSpecificPageInput: "enter the page number to go",
  goNextPage: "go next page",
  goLastPage: "go last page",
  /** Rating aria-label */
  currentRating: "current rating {value} of {max}",
  /** Rating item aria-label */
  voteRating: "vote rating {value} of {max}",
  /** Select search input aria-label */
  optionsFilter: "options filter",
  splitPanels: "split panels",
  movePaginationLeft: "move pagination left",
  movePaginationRight: "move pagination right",
  resetTime: "reset time",
  closeToast: "close toast",
  /**
   * Select aria-label selected option prefix
   *
   * @example
   *
   * `Selected option: {option}` or `Selected option: Animal`
   */
  selectedOption: "Selected option",
  /** Select aria-label if no option is selected */
  noSelectedOption: "Option is not selected",
  breadcrumbs: "breadcrumbs",
  counterValue: "counter value",
  selectedDate: "selected date",
  selectedTime: "selected time",
  progressState: "progress state",
  color: "color",
  /** Stepper next button text */
  next: "Next",
  /** Stepper previous button text */
  back: "Previous",
  /** Stepper finish button text */
  finish: "Finish",
  step: "step",
  progress: "progress",
  /** Skeleton aria label */
  loading: "Loading",
  /** Slider aria label */
  sliderValue: "Current slider value is {value}",
  /** Switch aria label */
  switch: "Switch",
  /** Input aria label */
  inputField: "Input field",
  /** File Input message when file type is incorrect */
  fileTypeIncorrect: "File type is incorrect",
  /** Select aria label */
  select: "Select an option"
});

// node_modules/vuestic-ui/dist/es/src/services/global-config/global-config.js
var GLOBAL_CONFIG = Symbol("GLOBAL_CONFIG");
var getDefaultConfig = () => ({
  colors: getColorDefaultConfig(),
  icons: getIconDefaultConfig(),
  components: getComponentsDefaultConfig(),
  breakpoint: getBreakpointDefaultConfig(),
  i18n: getI18nConfigDefaults(),
  colorsClasses: getColorsClassesDefaultConfig(),
  /**
   * global config variable to pass nuxt-link component to vuestic-ui via @vuestic/nuxt
   * TODO: give a try to integrate inertia js router components via this option
   * TODO: if this try won't be success, may be remake to provide/inject
   */
  routerComponent: void 0
});
var createGlobalConfig = (defaultConfig = {}) => {
  const globalConfig = ref(mergeDeep(getDefaultConfig(), defaultConfig));
  const getGlobalConfig = () => globalConfig.value;
  const setGlobalConfig = (updater) => {
    const config = typeof updater === "function" ? updater(globalConfig.value) : updater;
    globalConfig.value = cloneDeep(config);
  };
  const mergeGlobalConfig = (updater) => {
    const config = typeof updater === "function" ? updater(globalConfig.value) : updater;
    globalConfig.value = mergeDeep(cloneDeep(globalConfig.value), config);
  };
  return {
    getGlobalConfig,
    setGlobalConfig,
    mergeGlobalConfig,
    globalConfig
  };
};
var provideForCurrentApp = (provide11) => {
  var _a2, _b;
  const provides = ((_a2 = getCurrentInstance3()) == null ? void 0 : _a2.appContext.provides) || ((_b = getCurrentApp()) == null ? void 0 : _b._context.provides);
  if (!provides) {
    throw new Error("Vue app not found for provide");
  }
  provides[GLOBAL_CONFIG] = provide11;
  return provide11;
};

// node_modules/vuestic-ui/dist/es/src/composables/useGlobalConfig.js
function useGlobalConfig() {
  let injected = inject3(GLOBAL_CONFIG);
  if (!injected) {
    injected = createGlobalConfig();
    provideForCurrentApp(injected);
  }
  return injected;
}

// node_modules/vuestic-ui/dist/es/src/services/component-config/utils/use-component-config-props.js
var withPresetProp = (props) => "preset" in props;
var getPresetProp = (props) => withPresetProp(props) ? props.preset : void 0;
var useComponentConfigProps = (component, originalProps) => {
  const localConfig = useLocalConfig();
  const { globalConfig } = useGlobalConfig();
  const componentName2 = component.name;
  const getPresetProps = (presetPropValue) => {
    return (presetPropValue instanceof Array ? presetPropValue : [presetPropValue]).reduce((acc, presetName) => {
      var _a2, _b, _c;
      const presetProps = (_c = (_b = (_a2 = globalConfig.value.components) == null ? void 0 : _a2.presets) == null ? void 0 : _b[componentName2]) == null ? void 0 : _c[presetName];
      if (!presetProps) {
        return acc;
      }
      const extendedPresets = getPresetProp(presetProps);
      return {
        ...acc,
        ...extendedPresets ? getPresetProps(extendedPresets) : void 0,
        ...presetProps
      };
    }, {});
  };
  const parentInjectedProps = injectChildPropsFromParent();
  return computed4(() => {
    var _a2, _b;
    const globalConfigProps = {
      ...(_a2 = globalConfig.value.components) == null ? void 0 : _a2.all,
      ...(_b = globalConfig.value.components) == null ? void 0 : _b[componentName2]
    };
    const localConfigProps = localConfig.value.reduce((finalConfig, config) => {
      const componentConfigProps = config[componentName2];
      return componentConfigProps ? { ...finalConfig, ...componentConfigProps } : finalConfig;
    }, {});
    const presetProp = [
      originalProps,
      parentInjectedProps == null ? void 0 : parentInjectedProps.value,
      localConfigProps,
      globalConfigProps
    ].filter(notNil).map(getPresetProp).filter(notNil).at(0);
    const presetProps = presetProp ? getPresetProps(presetProp) : void 0;
    return { ...globalConfigProps, ...localConfigProps, ...presetProps };
  });
};

// node_modules/vuestic-ui/dist/es/src/services/config-transport/createSetupFn.js
var createSetupFn = (component) => {
  return (originalProps, ctx) => {
    var _a2;
    const instance = getCurrentInstance4();
    const propsFromConfig = useComponentConfigProps(component, originalProps);
    const attrsFromConfig = computed5(() => {
      return omit(propsFromConfig.value, Object.keys(originalProps));
    });
    const props = createProps(instance, propsFromConfig);
    const attrs = createAttrs(instance, attrsFromConfig);
    const slots = createSlots(instance, propsFromConfig);
    instance.props = props;
    instance.attrs = attrs;
    instance.slots = slots;
    const setupState = (_a2 = component.setup) == null ? void 0 : _a2.call(component, shallowReadonly(props), {
      ...ctx,
      attrs,
      slots
    });
    if (typeof setupState === "object" && !instance.exposed) {
      ctx.expose(setupState);
    }
    return setupState;
  };
};

// node_modules/vuestic-ui/dist/es/src/services/config-transport/createProxyComponent.js
var createProxyComponent = (component) => {
  const setupFn = createSetupFn(component);
  const renderFn = createRenderFn(component);
  return new Proxy(component, {
    get(target, key) {
      if (!(key in component)) {
        return Reflect.get(target, key);
      }
      if (key === "setup") {
        return setupFn;
      }
      if (key === "render" || key === "ssrRender") {
        return renderFn;
      }
      return Reflect.get(target, key);
    }
  });
};

// node_modules/vuestic-ui/dist/es/src/services/config-transport/withConfigTransport.js
var CLASS_COMPONENT_KEY = "__c";
var patchClassComponent = (component) => {
  component[CLASS_COMPONENT_KEY] = createProxyComponent(component[CLASS_COMPONENT_KEY]);
  return component;
};
var withConfigTransport = (component) => {
  if ("setup" in component) {
    return createProxyComponent(component);
  } else if (CLASS_COMPONENT_KEY in component) {
    return patchClassComponent(component);
  } else {
    component.setup = () => ({
      /* Fake setup function */
    });
    return createProxyComponent(component);
  }
};
var withConfigTransport$1 = withConfigTransport;

// node_modules/vuestic-ui/dist/es/src/components/va-icon/VaIcon.vue_vue_type_script_setup_true_lang.js
import { defineComponent, computed as computed9, useAttrs, openBlock, createBlock as createBlock2, resolveDynamicComponent, mergeProps, withCtx as withCtx2, renderSlot, createElementBlock, Fragment, createTextVNode, toDisplayString, createCommentVNode } from "vue";

// node_modules/vuestic-ui/dist/es/src/composables/useSize.js
import { computed as computed6, getCurrentInstance as getCurrentInstance5 } from "vue";
var sizesConfig = {
  defaultSize: 48,
  sizes: {
    small: 32,
    medium: 48,
    large: 64
  }
};
var fontSizesConfig = {
  defaultSize: 1,
  sizes: {
    small: 0.75,
    medium: 1,
    large: 1.25
  }
};
var useSizeProps = {
  size: {
    type: [String, Number],
    default: "",
    validator: (size2) => {
      return typeof size2 === "string" || typeof size2 === "number";
    }
  },
  sizesConfig: {
    type: Object,
    default: () => sizesConfig
  },
  fontSizesConfig: {
    type: Object,
    default: () => fontSizesConfig
  }
};
var fontRegex = /(?<fontSize>\d+)(?<extension>px|rem)/i;
var convertToRem = (px) => px / 16 - 0.5;
var sizeToAbsolute = (size2) => {
  if (typeof size2 === "number") {
    return `${size2}px`;
  }
  return String(size2);
};
var doHaveSizesConfig = (props) => "sizesConfig" in props;
var useSizeRef = (props) => {
  const sizePropName = "size";
  return computed6(() => {
    let sizePropValue = props[sizePropName];
    if (doHaveSizesConfig(props)) {
      const { defaultSize, sizes } = props.sizesConfig;
      if (isNilValue(sizePropValue)) {
        sizePropValue = defaultSize;
      }
      if (sizes) {
        const sizeFromConfig = sizes[sizePropValue];
        if (sizeFromConfig) {
          return sizeToAbsolute(sizeFromConfig);
        }
      }
    }
    return sizeToAbsolute(sizePropValue);
  });
};
var useSize = (props, componentName2 = ((_a2) => (_a2 = getCurrentInstance5()) == null ? void 0 : _a2.type.name)()) => {
  const { getGlobalConfig } = useGlobalConfig();
  const sizesConfigGlobal = computed6(() => {
    var _a2, _b;
    return componentName2 ? (_b = (_a2 = getGlobalConfig().components) == null ? void 0 : _a2[componentName2]) == null ? void 0 : _b.sizesConfig : void 0;
  });
  const sizeComputed = computed6(() => {
    var _a2, _b, _c;
    const { defaultSize, sizes } = props.sizesConfig;
    const defaultSizeGlobal = (_a2 = sizesConfigGlobal.value) == null ? void 0 : _a2.defaultSize;
    if (!props.size) {
      return `${defaultSize || defaultSizeGlobal}px`;
    }
    if (typeof props.size === "string") {
      const sizeFromGlobalConfig = (_c = (_b = sizesConfigGlobal.value) == null ? void 0 : _b.sizes) == null ? void 0 : _c[props.size];
      const sizeFromProps = sizes[props.size];
      if (sizeFromProps) {
        return `${sizeFromProps}px`;
      }
      if (sizeFromGlobalConfig) {
        return `${sizeFromGlobalConfig}px`;
      }
      return props.size;
    }
    return `${props.size}px`;
  });
  const fontSizeInRem = computed6(() => {
    const { defaultSize, sizes } = props.fontSizesConfig;
    if (!props.size) {
      return defaultSize;
    }
    if (typeof props.size === "string") {
      if (props.size in sizes) {
        return sizes[props.size];
      }
      const fontSizeParsed = props.size.match(fontRegex);
      if (!fontSizeParsed || !fontSizeParsed.groups) {
        throw new Error("Size prop should be either valid string or number");
      }
      const { extension, fontSize } = fontSizeParsed.groups;
      return extension === "rem" ? +fontSize : convertToRem(+fontSize);
    }
    return convertToRem(props.size);
  });
  const fontSizeComputed = computed6(() => `${fontSizeInRem.value}rem`);
  return {
    sizeComputed,
    fontSizeComputed,
    fontSizeInRem
  };
};

// node_modules/vuestic-ui/dist/es/src/composables/useComponentPreset.js
var useComponentPresetProp = {
  preset: {
    type: [String, Array],
    default: void 0
  }
};

// node_modules/vuestic-ui/dist/es/src/services/icon/utils/regex.js
var isMatchRegex = (str, regex) => {
  return regex.test(str);
};
var regexGroupsValues = (str, regex) => {
  if (typeof regex !== "string" && regex.global) {
    return [...str.matchAll(regex)].map((g) => g.slice(1));
  }
  const match = str.match(regex) || [];
  if (!match) {
    return [];
  }
  if (match.length > 1) {
    return match.slice(1);
  }
  return match;
};

// node_modules/vuestic-ui/dist/es/src/services/icon/utils/dynamic-segment.js
var dynamicSegmentRegex = /{[^}]*}/g;
var dynamicSegmentStringToRegex = (template) => {
  return template.replace(dynamicSegmentRegex, "(.*)");
};
var dynamicSegmentsNames = (template) => {
  return (template.match(dynamicSegmentRegex) || []).map((g) => g.replace(/{|}/g, ""));
};
var dynamicSegmentsValues = (str, template) => {
  return regexGroupsValues(str, dynamicSegmentStringToRegex(template));
};
var dynamicSegments = (str, template) => {
  const params = dynamicSegmentsNames(template);
  const values = dynamicSegmentsValues(str, template);
  return params.reduce((acc, paramValue, i) => ({ ...acc, [paramValue]: values[i] }), {});
};
var strictMatch = (str, regex) => {
  return (str.match(regex) || [])[0] === str;
};
var isMatchDynamicSegments = (str, template) => {
  const templateRegex = dynamicSegmentStringToRegex(template);
  return strictMatch(str, new RegExp(templateRegex));
};

// node_modules/vuestic-ui/dist/es/src/services/icon/types.js
var isIconConfigurationString = (config) => {
  return typeof config.name === "string";
};
var isIconConfigurationRegex = (config) => {
  return config.name instanceof RegExp;
};

// node_modules/vuestic-ui/dist/es/src/services/icon/utils/get-icon-configuration.js
var isMatchConfiguration = (iconName, iconConfiguration) => {
  if (isIconConfigurationString(iconConfiguration)) {
    return isMatchDynamicSegments(iconName, iconConfiguration.name);
  }
  if (isIconConfigurationRegex(iconConfiguration)) {
    return isMatchRegex(iconName, iconConfiguration.name);
  }
  return false;
};
var resolveIconConfigurationString = (iconName, iconConfiguration) => {
  const args = dynamicSegments(iconName, iconConfiguration.name);
  return iconConfiguration.resolve && iconConfiguration.resolve(args);
};
var resolveIconConfigurationRegex = (iconName, iconConfig) => {
  if (iconConfig.name.global) {
    throw new Error(`Bad icon config with name ${iconConfig.name}. Please, don't use global regex as name.`);
  }
  const args = regexGroupsValues(iconName, iconConfig.name);
  return iconConfig.resolveFromRegex && iconConfig.resolveFromRegex(...args);
};
var resolveIconConfiguration = (iconName, iconConfiguration) => {
  if (isIconConfigurationString(iconConfiguration)) {
    return resolveIconConfigurationString(iconName, iconConfiguration);
  }
  if (isIconConfigurationRegex(iconConfiguration)) {
    return resolveIconConfigurationRegex(iconName, iconConfiguration);
  }
  throw Error("Unknown icon config");
};
var findMatchedIconConfiguration = (iconName, globalIconConfig, namesToIgnore = []) => {
  const matchedConfig = globalIconConfig.find((config) => {
    if (namesToIgnore.includes(config.name.toString())) {
      return false;
    }
    return isMatchConfiguration(iconName, config);
  });
  if (!matchedConfig) {
    throw new Error(`Can not find icon config from ${iconName}. Please provide default config.`);
  }
  return matchedConfig;
};
var findIconConfiguration = (iconName, globalIconConfig, namesToIgnore = []) => {
  if (!iconName) {
    return;
  }
  const matchedIconConfiguration = findMatchedIconConfiguration(iconName, globalIconConfig, namesToIgnore);
  const resolvedIconConfiguration = mergeDeep(resolveIconConfiguration(iconName, matchedIconConfiguration), matchedIconConfiguration);
  namesToIgnore = [...namesToIgnore, matchedIconConfiguration.name.toString()];
  return mergeDeep(
    findIconConfiguration(resolvedIconConfiguration.to, globalIconConfig, namesToIgnore),
    resolvedIconConfiguration
  );
};
var iconPropsFromIconConfiguration = (iconConfiguration) => {
  const junkKeys = ["name", "to", "resolve", "resolveFromRegex"];
  const configuration = iconConfiguration;
  junkKeys.forEach((key) => {
    delete configuration[key];
  });
  return configuration;
};
var getIconConfiguration = (name, iconConfig) => {
  const configuration = findIconConfiguration(name, iconConfig);
  if (configuration === void 0) {
    return {};
  }
  return iconPropsFromIconConfiguration(configuration);
};

// node_modules/vuestic-ui/dist/es/src/composables/useIcon.js
var useIcon = () => {
  const { globalConfig } = useGlobalConfig();
  return {
    getIcon: (name) => getIconConfiguration(name, globalConfig.value.icons)
  };
};

// node_modules/vuestic-ui/dist/es/src/composables/useColors.js
import { computed as computed8, capitalize as capitalize2 } from "vue";

// node_modules/vuestic-ui/dist/es/src/services/vue-plugin/utils/define-vuestic-plugin.js
var defineVuesticPlugin = (fabric) => fabric;

// node_modules/vuestic-ui/dist/es/src/services/cache/plugin/index.js
var VaAppCachePluginKey = Symbol("VaAppCachePlugin");
var CachePlugin = defineVuesticPlugin(() => ({
  install(app) {
    const cache = {
      colorContrast: {}
    };
    app.provide(VaAppCachePluginKey, cache);
  }
}));

// node_modules/vuestic-ui/dist/es/src/composables/useCache.js
var useCache = () => {
  const cache = inject3(VaAppCachePluginKey);
  if (!cache) {
    return {
      colorContrast: {}
    };
  }
  return cache;
};

// node_modules/vuestic-ui/dist/es/src/composables/useReactiveComputed.js
import { computed as computed7, unref, isRef, reactive } from "vue";
var useReactiveComputed = (obj) => {
  const objectRef = typeof obj === "function" ? computed7(obj) : computed7(obj);
  const proxy = new Proxy(objectRef, {
    get(target, p, receiver) {
      if (typeof objectRef.value !== "object") {
        return void 0;
      }
      return unref(Reflect.get(objectRef.value, p, receiver));
    },
    set(target, p, value) {
      if (isRef(objectRef.value[p]) && !isRef(value)) {
        objectRef.value[p].value = value;
      } else {
        objectRef.value[p] = value;
      }
      return true;
    },
    deleteProperty(target, p) {
      return Reflect.deleteProperty(objectRef.value, p);
    },
    has(target, p) {
      if (typeof objectRef.value !== "object") {
        return false;
      }
      return Reflect.has(objectRef.value, p);
    },
    ownKeys() {
      if (typeof objectRef.value !== "object") {
        return [];
      }
      return Object.keys(objectRef.value);
    },
    getOwnPropertyDescriptor() {
      return {
        enumerable: true,
        configurable: true
      };
    }
  });
  return reactive(proxy);
};

// node_modules/vuestic-ui/dist/es/src/utils/text-case.js
var capitalize = (str) => str.charAt(0).toUpperCase() + str.slice(1).toLowerCase();
var wordsRegex = /[A-Z0-9]*(?:[^\-_|A-Z|\s.])*/gm;
var getWords = (str) => {
  var _a2;
  return ((_a2 = str.match(wordsRegex)) == null ? void 0 : _a2.map((word) => word.trim().split(/([0-9]+)|([a-zA-Z]+)/g)).flat().filter(Boolean)) || [];
};
var camelCaseToKebabCase = (str) => {
  return getWords(str).map((word) => word.toLowerCase()).join("-");
};
var kebabCaseToCamelCase = (str) => {
  return getWords(str).map((word, index) => index === 0 ? word.toLowerCase() : capitalize(word)).join("");
};
var startCase = (str) => {
  return getWords(str).map(capitalize).join(" ");
};

// node_modules/vuestic-ui/dist/es/src/utils/color.js
var HEX_TEST_REGEX = /^#([A-Fa-f0-9]{3,4}|[A-Fa-f0-9]{6,8})$/;
var RGB_TEST_REGEX = /^rgba?\(([\d.]+, ?){2}[\d.]+(, ?[\d.]+)?\)$/;
var HSL_TEST_REGEX = /hsla?\([\d.]+(deg|rad|turn|grad)?(,?\s?[\d.]+%?){2}(,?\s?(\/\s?)?[\d.]+%?)?\)/;
var isColor = (strColor) => {
  return HEX_TEST_REGEX.test(strColor) || RGB_TEST_REGEX.test(strColor) || HSL_TEST_REGEX.test(strColor);
};
var isHSLObject = (obj) => {
  if (typeof obj !== "object" || obj === null) {
    return false;
  }
  return "h" in obj && "s" in obj && "l" in obj;
};
var isRGBObject = (obj) => {
  if (typeof obj !== "object" || obj === null) {
    return false;
  }
  return "r" in obj && "g" in obj && "b" in obj;
};
var tryParseHex = (color) => {
  if (!HEX_TEST_REGEX.test(color)) {
    return null;
  }
  const hex = color.replace("#", "");
  const isShort = hex.length < 6;
  const [r, g, b, a] = isShort ? hex.split("").map((char) => parseInt(char + char, 16)) : hex.match(/.{2}/g).map((hex2) => parseInt(hex2, 16));
  return { r, g, b, a: a ?? 1 };
};
var tryParseRgb = (color) => {
  if (!RGB_TEST_REGEX.test(color)) {
    return null;
  }
  const [r, g, b, a = 1] = color.match(/[\d.]+/g).map(Number);
  return { r, g, b, a };
};
var tryParseHsla = (color) => {
  if (!HSL_TEST_REGEX.test(color)) {
    return null;
  }
  const [h15, s, l, a = "1"] = color.match(/[\d.]+%?/g);
  return {
    h: Number(h15),
    s: Number(s.replace("%", "")),
    l: Number(l.replace("%", "")),
    a: a.endsWith("%") ? Number(a.replace("%", "")) / 100 : Number(a)
  };
};
var rgbaToHsla = (rgba) => {
  const r = rgba.r / 255;
  const g = rgba.g / 255;
  const b = rgba.b / 255;
  const max = Math.max(r, g, b);
  const min = Math.min(r, g, b);
  let h15 = 0;
  let s = 0;
  const l = (max + min) / 2;
  if (max !== min) {
    const d = max - min;
    s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
    switch (max) {
      case r:
        h15 = (g - b) / d + (g < b ? 6 : 0);
        break;
      case g:
        h15 = (b - r) / d + 2;
        break;
      case b:
        h15 = (r - g) / d + 4;
        break;
    }
    h15 *= 60;
  }
  return { h: Math.round(h15), s: Math.round(s * 100), l: Math.round(l * 100), a: rgba.a };
};
var hueToRgb = (p, q, t) => {
  if (t < 0) {
    t += 1;
  }
  if (t > 1) {
    t -= 1;
  }
  if (t < 1 / 6) {
    return p + (q - p) * 6 * t;
  }
  if (t < 1 / 2) {
    return q;
  }
  if (t < 2 / 3) {
    return p + (q - p) * (2 / 3 - t) * 6;
  }
  return p;
};
var hslaToRgba = (hsla) => {
  const h15 = hsla.h / 360;
  const s = hsla.s / 100;
  const l = hsla.l / 100;
  const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
  const p = 2 * l - q;
  const r = hueToRgb(p, q, h15 + 1 / 3);
  const g = hueToRgb(p, q, h15);
  const b = hueToRgb(p, q, h15 - 1 / 3);
  return { r: Math.round(r * 255), g: Math.round(g * 255), b: Math.round(b * 255), a: hsla.a };
};
var parseColorToHSL = (color) => {
  if (isHSLObject(color)) {
    return { ...color };
  }
  if (isRGBObject(color)) {
    return rgbaToHsla(color);
  }
  const rgb = tryParseHex(color) ?? tryParseRgb(color);
  if (rgb) {
    return rgbaToHsla(rgb);
  }
  const hsl = tryParseHsla(color);
  if (hsl) {
    return hsl;
  }
  throw new Error(`Color ${color} is not valid. Please, provide valid color.`);
};
var hslToString = ({ h: h15, s, l, a }) => {
  return `hsla(${h15},${s}%,${l}%,${a ?? 1})`;
};
var parseColorToRGB = (color) => {
  if (isRGBObject(color)) {
    return { ...color };
  }
  if (isHSLObject(color)) {
    return hslaToRgba(color);
  }
  const hsl = tryParseHsla(color);
  if (hsl) {
    return hslaToRgba(hsl);
  }
  const rgb = tryParseHex(color) ?? tryParseRgb(color);
  if (rgb) {
    return rgb;
  }
  throw new Error(`Color ${color} is not valid. Please, provide valid color.`);
};
var rgbToString = ({ r, g, b, a }) => {
  if (a === 1) {
    return `rgb(${r},${g},${b})`;
  }
  return `rgba(${r},${g},${b},${a ?? 1})`;
};
var colorToString = (color) => {
  if (isHSLObject(color)) {
    return hslToString(color);
  }
  if (isRGBObject(color)) {
    return rgbToString(color);
  }
  if (typeof color === "string") {
    return color;
  }
  throw new Error(`Color ${color} is not valid. Please, provide valid color.`);
};
var setHSLA = (color, { h: h15, s, l, a }) => {
  const parsedColor = parseColorToHSL(color);
  parsedColor.a = parsedColor.a ?? 1;
  parsedColor.h = h15 ?? parsedColor.h;
  parsedColor.s = s ?? parsedColor.s;
  parsedColor.l = l ?? parsedColor.l;
  parsedColor.a = a ?? parsedColor.a;
  if (parsedColor.h < 0) {
    parsedColor.h = 360 + parsedColor.h;
  }
  if (parsedColor.h > 360) {
    parsedColor.h = parsedColor.h - 360;
  }
  parsedColor.s = Math.max(0, Math.min(100, parsedColor.s));
  parsedColor.l = Math.max(0, Math.min(100, parsedColor.l));
  parsedColor.a = Math.max(0, Math.min(1, parsedColor.a));
  return parsedColor;
};
var shiftHSLA = (color, { h: h15, s, l, a }) => {
  const parsedColor = parseColorToHSL(color);
  parsedColor.a = parsedColor.a ?? 1;
  parsedColor.h += h15 ?? 0;
  parsedColor.s += s ?? 0;
  parsedColor.l += l ?? 0;
  parsedColor.a += a ?? 0;
  if (parsedColor.h < 0) {
    parsedColor.h = 360 + parsedColor.h;
  }
  if (parsedColor.h > 360) {
    parsedColor.h = parsedColor.h - 360;
  }
  parsedColor.s = Math.max(0, Math.min(100, parsedColor.s));
  parsedColor.l = Math.max(0, Math.min(100, parsedColor.l));
  parsedColor.a = Math.max(0, Math.min(1, parsedColor.a));
  return parsedColor;
};

// node_modules/vuestic-ui/dist/es/src/services/color/utils.js
var isCSSVariable = (strColor) => /var\(--.+\)/.test(strColor);
var cssVariableName = (colorName) => `--va-${camelCaseToKebabCase(colorName)}`;
var normalizeColorName = (colorName) => kebabCaseToCamelCase(colorName);
var colorToRgba = (color, opacity) => {
  const { r, g, b } = parseColorToRGB(color);
  return rgbToString({ r, g, b, a: opacity });
};
var getColorLightness = (color) => {
  const { r, g, b } = parseColorToRGB(color);
  return Math.sqrt(r * r * 0.241 + g * g * 0.691 + b * b * 0.068);
};
var getBoxShadowColor = (color, opacity = 0.4) => {
  return colorToRgba(color, opacity);
};
var getBoxShadowColorFromBg = (background, opacity = 0.4) => {
  return colorToRgba(background, opacity);
};
var getHoverColor = (color, opacity = 0.2) => {
  return colorToRgba(color, opacity);
};
var getFocusColor = (color, opacity = 0.3) => {
  return colorToRgba(color, opacity);
};
var shiftHSLAColor = (color, shift2) => {
  return hslToString(shiftHSLA(parseColorToHSL(color), shift2));
};
var setHSLAColor = (color, shift2) => {
  return hslToString(setHSLA(parseColorToHSL(color), shift2));
};
var shiftGradientColor = (color) => {
  const newColor = parseColorToHSL(color);
  if (newColor.s < 10) {
    return shiftHSLAColor(newColor, { h: 2, s: 5, l: 10 });
  }
  if (newColor.s < 30) {
    return shiftHSLAColor(newColor, { s: -14, l: 11 });
  }
  if (newColor.h >= 0 && newColor.h < 44 || newColor.h >= 285) {
    return shiftHSLAColor(newColor, { h: 11, s: 27, l: 8 });
  }
  if (newColor.h >= 44 && newColor.h < 85) {
    return shiftHSLAColor(newColor, { h: 3, l: 9 });
  }
  if (newColor.h >= 85 && newColor.h < 165) {
    return shiftHSLAColor(newColor, { h: 16, l: 14 });
  }
  if (newColor.h >= 165 && newColor.h < 285) {
    return shiftHSLAColor(newColor, { h: -15, s: 3, l: 2 });
  }
  throw new Error("This method should handle all colors. But it didn't for some reason.");
};
var getGradientBackground = (color) => {
  const colorLeft = shiftGradientColor(color);
  return `linear-gradient(to right, ${colorLeft}, ${colorToString(color)})`;
};
var getStateMaskGradientBackground = (color, maskColor, maskOpacity) => {
  const mask = colorToRgba(maskColor, maskOpacity);
  return `linear-gradient(0deg, ${mask}, ${mask}), ${color}`;
};
var applyColors = (color1, color2) => {
  const c1 = parseColorToRGB(color1);
  const c2 = parseColorToRGB(color2);
  const weight = c2.a;
  if (weight === 1) {
    return rgbToString(c2);
  }
  if (weight === 0) {
    return rgbToString(c1);
  }
  return rgbToString({
    r: Math.round(c1.r * (1 - weight) + c2.r * weight),
    g: Math.round(c1.g * (1 - weight) + c2.g * weight),
    b: Math.round(c1.b * (1 - weight) + c2.b * weight),
    a: c1.a
  });
};
var isColorTransparent = (color) => {
  if (!color) {
    return false;
  }
  if (color === "transparent") {
    return true;
  }
  return parseColorToRGB(color).a <= 0.1;
};

// node_modules/vuestic-ui/dist/es/src/composables/useColors.js
var useColorProps = {
  color: {
    type: String,
    default: ""
  }
};
var useColors = () => {
  const gc = useGlobalConfig();
  if (!gc) {
    throw new Error("useColors must be used in setup function or Vuestic GlobalConfigPlugin is not registered!");
  }
  const { globalConfig } = gc;
  const colors = useReactiveComputed({
    get: () => globalConfig.value.colors.presets[globalConfig.value.colors.currentPresetName],
    set: (v) => {
      setColors(v);
    }
  });
  const setColors = (colors2) => {
    globalConfig.value.colors.presets[globalConfig.value.colors.currentPresetName] = {
      ...globalConfig.value.colors.variables,
      ...colors2
    };
  };
  const getColors = () => {
    return colors;
  };
  const getColor = (prop, defaultColor, preferVariables) => {
    if (!defaultColor) {
      defaultColor = colors.primary;
    }
    if (prop === "transparent") {
      return "#ffffff00";
    }
    if (prop === "currentColor") {
      return prop;
    }
    if (prop == null ? void 0 : prop.startsWith("on")) {
      const colorName = prop.slice(2);
      if (colors[normalizeColorName(colorName)]) {
        return getColor(getTextColor(getColor(colorName)), void 0, preferVariables);
      }
    }
    if (!prop) {
      prop = getColor(defaultColor);
    }
    const colorValue = colors[prop] || colors[normalizeColorName(prop)];
    if (colorValue) {
      return preferVariables ? `var(${cssVariableName(prop)})` : colorValue;
    }
    if (isColor(prop)) {
      return prop;
    }
    if (preferVariables && isCSSVariable(prop)) {
      return prop;
    }
    warn(`'${prop}' is not a proper color! Use HEX or default color themes
      names (https://vuestic.dev/en/styles/colors#default-color-themes)`);
    return getColor(defaultColor);
  };
  const getComputedColor = (color) => {
    return computed8({
      get() {
        return getColor(color);
      },
      set(v) {
        setColors({ [color]: v });
      }
    });
  };
  const colorsToCSSVariable = (colors2, prefix2 = "va") => {
    return Object.keys(colors2).filter((key) => colors2[key] !== void 0).reduce((acc, colorName) => {
      acc[`--${prefix2}-${camelCaseToKebabCase(colorName)}`] = getColor(colors2[colorName], void 0, true);
      acc[`--${prefix2}-on-${camelCaseToKebabCase(colorName)}`] = getColor(getTextColor(getColor(colors2[colorName])), void 0, true);
      return acc;
    }, {});
  };
  const cache = useCache();
  const getColorLightnessFromCache = (color) => {
    if (typeof color !== "string") {
      return getColorLightness(color);
    }
    if (!cache.colorContrast[color]) {
      cache.colorContrast[color] = getColorLightness(color);
    }
    return cache.colorContrast[color];
  };
  const computedDarkColor = computed8(() => {
    return getColorLightnessFromCache(getColor("textPrimary")) > 255 / 2 ? "textInverted" : "textPrimary";
  });
  const computedLightColor = computed8(() => {
    return getColorLightnessFromCache(getColor("textPrimary")) > 255 / 2 ? "textPrimary" : "textInverted";
  });
  const getTextColor = (color, darkColor, lightColor) => {
    const onColorName = `on${capitalize2(String(color))}`;
    if (colors[onColorName]) {
      return colors[onColorName];
    }
    darkColor = darkColor || computedDarkColor.value;
    lightColor = lightColor || computedLightColor.value;
    return getColorLightnessFromCache(color) > globalConfig.value.colors.threshold ? darkColor : lightColor;
  };
  const currentPresetName = computed8({
    get: () => globalConfig.value.colors.currentPresetName,
    set: (v) => {
      applyPreset(v);
    }
  });
  const presets2 = computed8(() => globalConfig.value.colors.presets);
  const applyPreset = (presetName) => {
    globalConfig.value.colors.currentPresetName = presetName;
    if (!globalConfig.value.colors.presets[presetName]) {
      return warn(`Preset ${presetName} does not exist`);
    }
  };
  return {
    colors,
    currentPresetName,
    presets: presets2,
    applyPreset,
    setColors,
    getColors,
    getColor,
    getComputedColor,
    getBoxShadowColor,
    getBoxShadowColorFromBg,
    getHoverColor,
    getFocusColor,
    getGradientBackground,
    getTextColor,
    shiftHSLAColor,
    setHSLAColor,
    colorsToCSSVariable,
    colorToRgba,
    getStateMaskGradientBackground
  };
};

// node_modules/vuestic-ui/dist/es/src/components/va-icon/VaIcon.vue_vue_type_script_setup_true_lang.js
import "D:/Desktop/forntend/Front_End_Web_Hotel_Nhom_2/my-nuxt-app/node_modules/vuestic-ui/dist/es/VaIcon.css";
var _sfc_main = defineComponent({
  ...{
    name: "VaIcon"
  },
  __name: "VaIcon",
  props: {
    ...useSizeProps,
    ...useComponentPresetProp,
    name: { type: String, default: "" },
    tag: { type: String },
    component: { type: Object },
    color: { type: String },
    rotation: { type: [String, Number] },
    spin: { type: [String, Boolean] },
    flip: {
      type: String,
      default: "off",
      validator: (value) => ["off", "horizontal", "vertical", "both"].includes(value)
    }
  },
  setup(__props) {
    const props = __props;
    const { getColor } = useColors();
    const { sizeComputed } = useSize(props);
    const { getIcon } = useIcon();
    const iconConfig = computed9(() => getIcon(props.name));
    const computedTag = computed9(() => props.component || props.tag || iconConfig.value.component || iconConfig.value.tag || "i");
    const attrs = useAttrs();
    const computedAttrs = computed9(() => ({ ...iconConfig.value.attrs, ...omit(attrs, ["class"]) }));
    const getSpinClass = (spin) => {
      if (spin === void 0 || spin === false) {
        return;
      }
      return spin === "counter-clockwise" ? "va-icon--spin-reverse" : "va-icon--spin";
    };
    const computedClass = computed9(() => [
      iconConfig.value.class,
      getSpinClass(props.spin ?? iconConfig.value.spin)
    ]);
    const transformStyle = computed9(() => {
      const rotation = props.rotation ? `rotate(${props.rotation}deg)` : "";
      const flipY = props.flip === "vertical" || props.flip === "both" ? -1 : 1;
      const flipX = props.flip === "horizontal" || props.flip === "both" ? -1 : 1;
      const scale = props.flip === "off" ? "" : `scale(${flipY}, ${flipX})`;
      return `${scale} ${rotation}`.trim();
    });
    const computedStyle = computed9(() => ({
      transform: transformStyle.value,
      cursor: attrs.onClick ? "pointer" : null,
      color: props.color ? getColor(props.color, void 0, true) : iconConfig.value.color,
      fontSize: sizeComputed.value,
      height: sizeComputed.value,
      lineHeight: sizeComputed.value
    }));
    const tabindexComputed = computed9(() => attrs.tabindex ?? -1);
    const ariaHiddenComputed = computed9(() => attrs.role !== "button" || tabindexComputed.value < 0);
    return (_ctx, _cache) => {
      return openBlock(), createBlock2(resolveDynamicComponent(computedTag.value), mergeProps({
        class: ["va-icon", computedClass.value],
        style: computedStyle.value,
        "aria-hidden": ariaHiddenComputed.value,
        notranslate: ""
      }, computedAttrs.value), {
        default: withCtx2(() => [
          renderSlot(_ctx.$slots, "default", {}, () => [
            iconConfig.value.content ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
              createTextVNode(toDisplayString(iconConfig.value.content), 1)
            ], 64)) : createCommentVNode("", true)
          ])
        ]),
        _: 3
      }, 16, ["class", "style", "aria-hidden"]);
    };
  }
});

// node_modules/vuestic-ui/dist/es/src/components/va-icon/index.js
var VaIcon = withConfigTransport$1(_sfc_main);

// node_modules/vuestic-ui/dist/es/src/components/va-message-list/hooks/useMessageListAria.js
import { computed as computed11 } from "vue";

// node_modules/vuestic-ui/dist/es/src/composables/useComponentUuid.js
import { getCurrentInstance as getCurrentInstance7 } from "vue";

// node_modules/vuestic-ui/dist/es/src/composables/useAppGlobal.js
import { computed as computed10, getCurrentInstance as getCurrentInstance6, reactive as reactive2 } from "vue";
var getGlobalObject = () => {
  const vm = getCurrentInstance6();
  const app = vm == null ? void 0 : vm.appContext.app;
  const { globalProperties } = app.config;
  if ("$vaGlobalVariable" in globalProperties) {
    return globalProperties.$vaGlobalVariable;
  }
  globalProperties.$vaGlobalVariable = reactive2({});
  return globalProperties.$vaGlobalVariable;
};
var useAppGlobal = (key, defaultValue) => {
  const globalObject = getGlobalObject();
  if (!(key in globalObject)) {
    globalObject[key] = defaultValue;
  }
  return computed10({
    get: () => globalObject[key],
    set: (value) => {
      globalObject[key] = value;
    }
  });
};

// node_modules/vuestic-ui/dist/es/src/composables/useComponentUuid.js
var useComponentUuid = () => {
  const vm = getCurrentInstance7();
  const counter2 = useAppGlobal("uuidCounter", 0);
  vm.$vaUuid = vm.$vaUuid || `va-${counter2.value++}`;
  return `va-${counter2.value}`;
};

// node_modules/vuestic-ui/dist/es/src/components/va-message-list/hooks/useMessageListAria.js
var useMessageListAria = (props) => {
  const id = useComponentUuid();
  const messageListId = `message-list-${id}`;
  const messageListAttributes = computed11(() => ({
    id: messageListId,
    role: "alert"
  }));
  const doHaveMessages = computed11(() => {
    if (typeof props.modelValue === "string" && props.modelValue.length > 0) {
      return true;
    }
    if (Array.isArray(props.modelValue) && props.modelValue.length > 0) {
      return true;
    }
    return false;
  });
  const childAttributes = computed11(() => ({
    "aria-describedby": doHaveMessages.value ? messageListId : void 0,
    "aria-invalid": props.hasError
  }));
  return {
    messageListAttributes,
    childAttributes
  };
};

// node_modules/vuestic-ui/dist/es/src/composables/useNumericProp.js
import { getCurrentInstance as getCurrentInstance8, computed as computed12 } from "vue";
var useNumericProp = (key) => {
  const props = getCurrentInstance8().props;
  const numericComputed = computed12(() => {
    const numeric = props == null ? void 0 : props[key];
    if (numeric === void 0) {
      return numeric;
    }
    return Number(numeric);
  });
  return numericComputed;
};

// node_modules/vuestic-ui/dist/es/src/components/va-message-list/VaMessageList.vue_vue_type_script_setup_true_lang.js
import "D:/Desktop/forntend/Front_End_Web_Hotel_Nhom_2/my-nuxt-app/node_modules/vuestic-ui/dist/es/VaMessageList.css";
var _hoisted_1 = { class: "va-message-list__list" };
var _sfc_main2 = defineComponent2({
  ...{
    name: "VaMessageList",
    inheritAttrs: false
  },
  __name: "VaMessageList",
  props: {
    modelValue: {
      type: [String, Array],
      default: ""
    },
    limit: { type: [Number, String], default: 1 },
    color: { type: String },
    hasError: { type: Boolean, default: false }
  },
  setup(__props, { expose: __expose }) {
    const props = __props;
    const { getColor } = useColors();
    const { childAttributes, messageListAttributes } = useMessageListAria(props);
    const limitComputed = useNumericProp("limit");
    const messages = computed13(() => {
      if (!props.modelValue) {
        return [];
      }
      if (!Array.isArray(props.modelValue)) {
        return [props.modelValue];
      }
      return props.modelValue.slice(0, limitComputed.value);
    });
    const computedStyle = computed13(() => props.color ? { color: getColor(props.color) } : {});
    __expose({
      messages
    });
    return (_ctx, _cache) => {
      return openBlock2(), createElementBlock2(Fragment2, null, [
        renderSlot2(_ctx.$slots, "default", normalizeProps(guardReactiveProps({ ariaAttributes: unref2(childAttributes), messages: messages.value, attrs: _ctx.$attrs }))),
        renderSlot2(_ctx.$slots, "messages", normalizeProps(guardReactiveProps({ ariaAttributes: unref2(messageListAttributes), messages: messages.value })), () => [
          messages.value.length > 0 ? (openBlock2(), createElementBlock2("div", mergeProps2({
            key: 0,
            class: "va-message-list",
            style: computedStyle.value
          }, unref2(messageListAttributes)), [
            createElementVNode("ul", _hoisted_1, [
              (openBlock2(true), createElementBlock2(Fragment2, null, renderList(messages.value, (message, index) => {
                return openBlock2(), createElementBlock2("li", {
                  key: index,
                  class: "va-message-list__message"
                }, [
                  renderSlot2(_ctx.$slots, "message", normalizeProps(guardReactiveProps({ messages: messages.value, message })), () => [
                    __props.hasError ? (openBlock2(), createBlock3(unref2(VaIcon), {
                      key: 0,
                      class: "va-message-list__icon",
                      name: "va-warning",
                      size: 16
                    })) : createCommentVNode2("", true),
                    createTextVNode2(toDisplayString2(message), 1)
                  ])
                ]);
              }), 128))
            ])
          ], 16)) : createCommentVNode2("", true)
        ])
      ], 64);
    };
  }
});

// node_modules/vuestic-ui/dist/es/src/components/va-message-list/VaMessageList.js
import "D:/Desktop/forntend/Front_End_Web_Hotel_Nhom_2/my-nuxt-app/node_modules/vuestic-ui/dist/es/VaMessageList.css";
var VaMessageList = withConfigTransport$1(_sfc_main2);

// node_modules/vuestic-ui/dist/es/src/composables/useValidation.js
import { ref as ref4, computed as computed16, watchEffect, toRef, watch as watch2, nextTick } from "vue";

// node_modules/vuestic-ui/dist/es/src/composables/useSyncProp.js
import { getCurrentInstance as getCurrentInstance9, computed as computed14, ref as ref2, watch } from "vue";
function useSyncProp(propName, props, emit, defaultValue) {
  const vm = getCurrentInstance9();
  const isPropPassed = computed14(() => {
    const t = props[propName];
    if (!(vm == null ? void 0 : vm.vnode.props)) {
      return t !== void 0;
    }
    return propName in vm.vnode.props && vm.vnode.props[propName] !== void 0;
  });
  if (defaultValue === void 0) {
    return [
      computed14({
        set(value) {
          emit(`update:${propName}`, value);
        },
        get() {
          return props[propName];
        }
      })
    ];
  }
  const currentValue = props[propName];
  const statefulValue = ref2(currentValue === void 0 ? defaultValue : currentValue);
  watch(() => props[propName], (newVal) => {
    if (newVal === void 0) {
      return;
    }
    statefulValue.value = newVal;
  });
  return [
    computed14({
      set(value) {
        statefulValue.value = value;
        emit(`update:${propName}`, value);
      },
      get() {
        if (isPropPassed.value) {
          return props[propName];
        }
        return statefulValue.value;
      }
    })
  ];
}

// node_modules/vuestic-ui/dist/es/src/utils/watch-setter.js
var isComputedRef = (value) => {
  return typeof value === "object" && "_setter" in value;
};
var watchSetter = (ref87, cb) => {
  if (!isComputedRef(ref87)) {
    return;
  }
  const originalSetter = ref87._setter;
  ref87._setter = (newValue) => {
    cb(newValue);
    originalSetter(newValue);
  };
};

// node_modules/vuestic-ui/dist/es/src/utils/is-function.js
var isFunction = (value) => typeof value === "function";

// node_modules/vuestic-ui/dist/es/src/utils/is-string.js
var isString = (value) => typeof value === "string";

// node_modules/vuestic-ui/dist/es/src/composables/useForm/useFormChild.js
import { inject as inject4, ref as ref3, computed as computed15, onMounted, onBeforeUnmount } from "vue";

// node_modules/vuestic-ui/dist/es/src/composables/useForm/consts.js
var FormServiceKey = Symbol("FormService");

// node_modules/vuestic-ui/dist/es/src/composables/useForm/useFormChild.js
var useFormChild = (context) => {
  const formContext = inject4(FormServiceKey, null);
  if (!formContext) {
    return {
      forceDirty: ref3(false),
      forceHideErrorMessages: ref3(false),
      forceHideErrors: ref3(false),
      forceHideLoading: ref3(false),
      fields: computed15(() => []),
      registerField: () => {
      },
      unregisterField: () => {
      },
      immediate: computed15(() => false)
    };
  }
  const uid = useComponentUuid();
  onMounted(() => {
    formContext.registerField(uid, context);
  });
  onBeforeUnmount(() => {
    formContext.unregisterField(uid);
  });
  return formContext;
};

// node_modules/vuestic-ui/dist/es/src/composables/useValidation.js
var normalizeValidationRules = (rules = [], callArguments = null) => {
  if (isString(rules)) {
    rules = [rules];
  }
  return rules.map((rule) => isFunction(rule) ? rule(callArguments) : rule);
};
var useValidationProps = {
  name: { type: String, default: void 0 },
  rules: { type: Array, default: () => [] },
  dirty: { type: Boolean, default: false },
  error: { type: Boolean, default: void 0 },
  errorMessages: { type: [Array, String], default: void 0 },
  errorCount: { type: [String, Number], default: 1 },
  success: { type: Boolean, default: false },
  messages: { type: [Array, String], default: () => [] },
  immediateValidation: { type: Boolean, default: false },
  modelValue: {}
};
var useValidationEmits = ["update:error", "update:errorMessages", "update:dirty"];
var isPromise = (value) => {
  return typeof value === "object" && typeof value.then === "function";
};
var useDirtyValue = (value, props, emit) => {
  const isDirty = ref4(props.dirty || false);
  watchSetter(value, () => {
    isDirty.value = true;
    emit("update:dirty", true);
  });
  watch2(value, (newValue, oldValue) => {
    if (newValue === oldValue) {
      isDirty.value = true;
    }
  }, { deep: true });
  watch2(() => props.dirty, (newValue) => {
    if (isDirty.value === newValue) {
      return;
    }
    isDirty.value = newValue;
  });
  return { isDirty };
};
var useTouched = () => {
  const isTouched = ref4(false);
  const onBlur = () => {
    isTouched.value = true;
  };
  return { isTouched, onBlur };
};
var useOncePerTick = (fn) => {
  let canBeCalled = true;
  return (...args) => {
    if (!canBeCalled) {
      return;
    }
    canBeCalled = false;
    const result = fn(...args);
    nextTick(() => {
      canBeCalled = true;
    });
    return result;
  };
};
var useValidation = (props, emit, options) => {
  const { reset, focus } = options;
  const [isError] = useSyncProp("error", props, emit, false);
  const [errorMessages] = useSyncProp("errorMessages", props, emit, []);
  const isLoading = ref4(false);
  const { isTouched, onBlur } = useTouched();
  const validationAriaAttributes = computed16(() => ({
    "aria-invalid": isError.value,
    "aria-errormessage": typeof errorMessages.value === "string" ? errorMessages.value : errorMessages.value.join(", ")
  }));
  const resetValidation = () => {
    errorMessages.value = [];
    isError.value = false;
    isDirty.value = false;
    isTouched.value = false;
    isLoading.value = false;
  };
  const processResults = (results) => {
    let error = false;
    let eMessages = [];
    results.forEach((result) => {
      if (isString(result)) {
        eMessages = [...eMessages, result];
        error = true;
      } else if (result === false) {
        error = true;
      }
    });
    errorMessages.value = eMessages;
    isError.value = error;
    return !error;
  };
  const validateAsync = async () => {
    if (!props.rules || !props.rules.length) {
      return true;
    }
    const results = normalizeValidationRules(props.rules.flat(), options.value.value);
    const asyncPromiseResults = results.filter((result) => isPromise(result));
    const syncRules = results.filter((result) => !isPromise(result));
    if (!asyncPromiseResults.length) {
      return processResults(syncRules);
    }
    isLoading.value = true;
    return Promise.all(asyncPromiseResults).then((asyncResults) => {
      return processResults([...syncRules, ...asyncResults]);
    }).finally(() => {
      isLoading.value = false;
    });
  };
  const validate = useOncePerTick(() => {
    if (!props.rules || !props.rules.length) {
      return true;
    }
    const rules = props.rules.flat();
    const results = normalizeValidationRules(rules, options.value.value);
    const asyncPromiseResults = results.filter((result) => isPromise(result));
    const syncRules = results.filter((result) => !isPromise(result));
    const isSyncedError = syncRules.some((result) => isString(result) ? result : result === false);
    if (asyncPromiseResults.length && !isSyncedError) {
      isLoading.value = true;
      Promise.all(asyncPromiseResults).then((asyncResults) => {
        processResults([...syncRules, ...asyncResults]);
        isLoading.value = false;
      });
      return isSyncedError;
    }
    return processResults(syncRules);
  });
  watchEffect(() => validate());
  const { isDirty } = useDirtyValue(options.value, props, emit);
  const {
    // Renamed to forceHideError because it's not clear what it does
    forceHideErrors,
    forceHideLoading,
    forceHideErrorMessages,
    forceDirty,
    immediate: isFormImmediate
  } = useFormChild({
    isTouched,
    isDirty,
    isValid: computed16(() => !isError.value),
    isLoading,
    errorMessages,
    validate,
    validateAsync,
    resetValidation,
    focus,
    reset: () => {
      reset();
      resetValidation();
      validate();
    },
    value: computed16(() => options.value || props.modelValue),
    name: toRef(props, "name")
  });
  const immediateValidation = computed16(() => props.immediateValidation || isFormImmediate.value);
  let canValidate = true;
  const withoutValidation = (cb) => {
    canValidate = false;
    cb();
    nextTick(() => {
      canValidate = true;
    });
  };
  watch2(options.value, () => {
    if (!canValidate) {
      return;
    }
    return validate();
  }, { immediate: immediateValidation.value });
  return {
    isDirty,
    isValid: computed16(() => !isError.value),
    isError,
    isTouched,
    isLoading: computed16({
      get: () => {
        if (forceHideErrors.value) {
          return false;
        }
        if (immediateValidation.value) {
          return isLoading.value;
        }
        if (isTouched.value || isDirty.value || forceDirty.value) {
          return isLoading.value;
        }
        return false;
      },
      set(value) {
        isLoading.value = value;
      }
    }),
    computedError: computed16(() => {
      if (forceHideErrors.value) {
        return false;
      }
      if (immediateValidation.value) {
        return isError.value;
      }
      if (isTouched.value || isDirty.value || forceDirty.value) {
        return isError.value;
      }
      return false;
    }),
    computedErrorMessages: computed16(() => forceHideErrorMessages.value ? [] : errorMessages.value),
    listeners: { onBlur },
    validate,
    resetValidation,
    withoutValidation,
    validationAriaAttributes
  };
};

// node_modules/vuestic-ui/dist/es/src/components/va-message-list/VaMessageListWrapper.vue_vue_type_script_setup_true_lang.js
import "D:/Desktop/forntend/Front_End_Web_Hotel_Nhom_2/my-nuxt-app/node_modules/vuestic-ui/dist/es/VaMessageListWrapper.css";
var _hoisted_12 = { class: "va-message-list-wrapper" };
var _sfc_main3 = defineComponent3({
  ...{
    name: "VaMessageListWrapper"
  },
  __name: "VaMessageListWrapper",
  props: {
    ...useValidationProps
  },
  setup(__props) {
    const props = __props;
    const messagesColor = computed17(() => {
      if (props.error) {
        return "danger";
      }
      if (props.success) {
        return "success";
      }
      return "";
    });
    const hasError = toRef2(props, "error");
    const messagesComputed = computed17(() => props.error ? props.errorMessages : props.messages);
    const errorLimit = computed17(() => props.error ? Number(props.errorCount) : 99);
    return (_ctx, _cache) => {
      return openBlock3(), createElementBlock3("div", _hoisted_12, [
        createVNode(unref3(VaMessageList), {
          color: messagesColor.value,
          limit: errorLimit.value,
          "has-error": hasError.value,
          "model-value": messagesComputed.value,
          "inherit-slots": ["message"]
        }, {
          default: withCtx3((bind) => [
            renderSlot3(_ctx.$slots, "default", normalizeProps2(guardReactiveProps2(bind)))
          ]),
          _: 3
        }, 8, ["color", "limit", "has-error", "model-value"])
      ]);
    };
  }
});

// node_modules/vuestic-ui/dist/es/src/components/va-config/VaConfig.vue_vue_type_script_setup_true_lang.js
import { defineComponent as defineComponent4, computed as computed19, openBlock as openBlock4, createBlock as createBlock4, unref as unref4, normalizeProps as normalizeProps3, mergeProps as mergeProps3, withCtx as withCtx4, renderSlot as renderSlot4, h as h3, Fragment as Fragment4 } from "vue";

// node_modules/vuestic-ui/dist/es/src/components/va-config/hooks/useGlobalConfigProvider.js
import { computed as computed18, provide as provide3 } from "vue";
var useGlobalConfigProvider = (next) => {
  const { globalConfig, mergeGlobalConfig, setGlobalConfig, getGlobalConfig } = useGlobalConfig();
  const nextChain = computed18(() => {
    var _a2;
    const gcCopy = cloneDeep(globalConfig.value);
    const compiledCopy = {
      ...gcCopy,
      colors: makeColorsConfig(gcCopy.colors)
    };
    const config = mergeDeep(compiledCopy, next.value);
    if ((_a2 = next.value.colors) == null ? void 0 : _a2.variables) {
      Object.keys(next.value.colors.variables).forEach((key) => {
        config.colors.variables[key] = next.value.colors.variables[key];
      });
    }
    return config;
  });
  provide3(GLOBAL_CONFIG, {
    mergeGlobalConfig,
    setGlobalConfig,
    getGlobalConfig,
    globalConfig: nextChain
  });
  return nextChain;
};

// node_modules/vuestic-ui/dist/es/src/utils/headless.js
import { Comment, h as h2, normalizeClass as normalizeClass2, Text as Text2, Suspense, Teleport, Fragment as Fragment3 } from "vue";
var toNode = (v, attrs) => {
  if (!v) {
    return null;
  }
  if (!("type" in v) || v.type === Text2 || typeof v === "string") {
    return h2("div", attrs, v);
  }
  if (v.type === Comment) {
    return v;
  }
  if ("$el" in v) {
    return toNode(v.$el, attrs);
  }
  if (v.type === Suspense) {
    return h2(v.ssContent, attrs);
  }
  if (v.type === Teleport) {
    if (v.children === null) {
      return v;
    }
    const anchor = toNode(v.children[0], attrs);
    if (anchor) {
      v.children[0] = h2(anchor, attrs);
    }
    return v;
  }
  if (v.type === Fragment3) {
    if (v.children === null) {
      return v;
    }
    if (v.children.length === 1) {
      return h2(Fragment3, v.props, [toNode(v.children[0], attrs)]);
    }
    return h2("div", attrs, v);
  }
  if (typeof v.type.render === "function") {
    const component = h2(v, attrs);
    if (Array.isArray(component.children) && component.children.length > 1) {
      return h2("div", attrs, component.children);
    }
  }
  return h2(v, attrs);
};
var renderSlotNode2 = (slot, slotBind = {}, nodeAttributes = {}) => {
  const children = slot == null ? void 0 : slot(slotBind);
  if (!children) {
    return null;
  }
  const nonCommentChildren = children.filter((v) => v.type !== Comment);
  if (nonCommentChildren.length === 0) {
    return null;
  }
  if (nonCommentChildren.length === 1) {
    return toNode(nonCommentChildren[0], nodeAttributes);
  }
  return h2("div", {
    ...nodeAttributes,
    class: normalizeClass2([nodeAttributes.class, "va-headless-wrapper"])
  }, children);
};
var renderSlotNodes = (slot, slotBind = {}, nodeAttributes = {}) => {
  const children = slot == null ? void 0 : slot(slotBind);
  if (!children) {
    return null;
  }
  return children.map((v) => toNode(v, nodeAttributes));
};

// node_modules/vuestic-ui/dist/es/src/components/va-config/VaConfig.vue_vue_type_script_setup_true_lang.js
var CssVarsRenderer = defineComponent4({
  name: "VaCssVarsRenderer",
  inheritAttrs: false,
  setup(props, { slots, attrs }) {
    const { colorsToCSSVariable, colors } = useColors();
    const style = computed19(() => {
      return colorsToCSSVariable(colors);
    });
    return () => h3(Fragment4, attrs, renderSlotNodes(slots.default, {}, {
      style: style.value
    }) || void 0);
  }
});
var _sfc_main4 = defineComponent4({
  ...{
    name: "VaConfig",
    inheritAttrs: false
  },
  __name: "VaConfig",
  props: {
    ...useComponentPresetProp,
    components: { type: Object, default: () => ({}) },
    colors: { type: Object },
    i18n: { type: Object }
  },
  setup(__props) {
    const props = __props;
    const prevChain = useLocalConfig();
    const nextChain = computed19(() => [...prevChain.value, props.components]);
    provideLocalConfig(nextChain);
    useGlobalConfigProvider(computed19(() => {
      const config = {};
      if (props.colors) {
        config.colors = props.colors;
      }
      if (props.i18n) {
        config.i18n = props.i18n;
      }
      return config;
    }));
    const doRenderCssVars = computed19(() => {
      return Boolean(props.colors);
    });
    return (_ctx, _cache) => {
      return doRenderCssVars.value ? (openBlock4(), createBlock4(unref4(CssVarsRenderer), normalizeProps3(mergeProps3({ key: 0 }, _ctx.$attrs)), {
        default: withCtx4(() => [
          renderSlot4(_ctx.$slots, "default")
        ]),
        _: 3
      }, 16)) : renderSlot4(_ctx.$slots, "default", { key: 1 });
    };
  }
});

// node_modules/vuestic-ui/dist/es/src/components/va-separator/VaSeparator.vue_vue_type_script_setup_true_lang.js
import { defineComponent as defineComponent5, openBlock as openBlock5, createElementBlock as createElementBlock4 } from "vue";
import "D:/Desktop/forntend/Front_End_Web_Hotel_Nhom_2/my-nuxt-app/node_modules/vuestic-ui/dist/es/VaSeparator.css";
var _hoisted_13 = {
  class: "va-separator",
  "aria-hidden": "true"
};
var _sfc_main5 = defineComponent5({
  ...{
    name: "VaSeparator"
  },
  __name: "VaSeparator",
  setup(__props) {
    return (_ctx, _cache) => {
      return openBlock5(), createElementBlock4("div", _hoisted_13);
    };
  }
});

// node_modules/vuestic-ui/dist/es/src/components/va-spacer/VaSpacer.vue_vue_type_script_setup_true_lang.js
import { defineComponent as defineComponent6, openBlock as openBlock6, createElementBlock as createElementBlock5 } from "vue";
import "D:/Desktop/forntend/Front_End_Web_Hotel_Nhom_2/my-nuxt-app/node_modules/vuestic-ui/dist/es/VaSpacer.css";
var _hoisted_14 = {
  class: "va-spacer",
  "aria-hidden": "true"
};
var _sfc_main6 = defineComponent6({
  ...{
    name: "VaSpacer"
  },
  __name: "VaSpacer",
  setup(__props) {
    return (_ctx, _cache) => {
      return openBlock6(), createElementBlock5("div", _hoisted_14);
    };
  }
});

// node_modules/vuestic-ui/dist/es/src/components/va-sticky-scrollbar/VaStickyScrollbar.vue_vue_type_script_setup_true_lang.js
import { defineComponent as defineComponent7, ref as ref7, computed as computed21, openBlock as openBlock7, createElementBlock as createElementBlock6, normalizeStyle as normalizeStyle2, createElementVNode as createElementVNode2 } from "vue";

// node_modules/vuestic-ui/dist/es/src/utils/scrollbar-size.js
var getScrollbarSize = (element) => {
  if (!element) {
    return 0;
  }
  const scrollbarWidth = element.offsetWidth - element.clientWidth;
  const scrollbarHeight = element.offsetHeight - element.clientHeight;
  return Math.max(scrollbarWidth, scrollbarHeight);
};

// node_modules/vuestic-ui/dist/es/src/composables/useElementRect.js
import { ref as ref5, onMounted as onMounted2, onBeforeUnmount as onBeforeUnmount2 } from "vue";
var useElementRect = (element) => {
  const rect = ref5({ top: 0, left: 0, width: 0, height: 0, bottom: 0, right: 0 });
  let resizeObserver;
  let mutationObserver;
  const updateRect = () => {
    if (element.value) {
      rect.value = element.value.getBoundingClientRect();
    }
  };
  onMounted2(() => {
    resizeObserver = new ResizeObserver(updateRect);
    mutationObserver = new MutationObserver(updateRect);
    element.value && resizeObserver.observe(element.value);
    element.value && mutationObserver.observe(element.value, { attributes: true, childList: true, subtree: true });
    window.addEventListener("resize", updateRect);
    window.addEventListener("scroll", updateRect);
    updateRect();
  });
  onBeforeUnmount2(() => {
    resizeObserver == null ? void 0 : resizeObserver.disconnect();
    mutationObserver == null ? void 0 : mutationObserver.disconnect();
    window.removeEventListener("resize", updateRect);
    window.removeEventListener("scroll", updateRect);
    resizeObserver = void 0;
    mutationObserver = void 0;
  });
  return rect;
};

// node_modules/vuestic-ui/dist/es/src/composables/useEvent.js
import { watch as watch4, unref as unref6 } from "vue";

// node_modules/vuestic-ui/dist/es/src/composables/useClientOnly.js
import { computed as computed20, ref as ref6, watch as watch3 } from "vue";

// node_modules/vuestic-ui/dist/es/src/utils/ssr.js
var isServer = () => typeof window === "undefined";
var isClient = () => !isServer();
var getWindow = () => typeof window === "undefined" ? void 0 : window;
var fakeGlobal = {};
var getGlobal = () => {
  if (isServer()) {
    if (typeof globalThis === "undefined") {
      return fakeGlobal;
    }
    return globalThis;
  } else {
    return window;
  }
};

// node_modules/vuestic-ui/dist/es/src/composables/useClientOnly.js
var useClientOnly = (cb) => {
  const isMounted = computed20(isClient);
  const result = ref6(null);
  watch3(isMounted, () => {
    if (isMounted.value) {
      result.value = cb();
    }
  }, { immediate: true });
  return result;
};

// node_modules/vuestic-ui/dist/es/src/composables/useWindow.js
var useWindow = () => useClientOnly(() => window);

// node_modules/vuestic-ui/dist/es/src/utils/unwrapEl.js
import { unref as unref5 } from "vue";
var unwrapEl = (el) => {
  if (!el) {
    return;
  }
  if (typeof el !== "object") {
    return;
  }
  el = unref5(el);
  if (!el) {
    return;
  }
  if (typeof el.$el !== "undefined") {
    return el.$el;
  }
  return el;
};

// node_modules/vuestic-ui/dist/es/src/utils/add-event-listener.js
var addEventListener = (target, ...args) => {
  if (!target || typeof target !== "object") {
    return;
  }
  if ("addEventListener" in target && typeof target.addEventListener === "function") {
    target.addEventListener(...args);
    return;
  }
  if ("parentElement" in target) {
    addEventListener(target.parentElement, ...args);
  }
};
var removeEventListener = (target, ...args) => {
  if (!target || typeof target !== "object") {
    return;
  }
  if ("removeEventListener" in target && typeof target.removeEventListener === "function") {
    target.removeEventListener(...args);
    return;
  }
  if ("parentElement" in target) {
    removeEventListener(target.parentElement, ...args);
  }
};

// node_modules/vuestic-ui/dist/es/src/composables/useEvent.js
var useEvent = (event, listener, target) => {
  const source = target && typeof target !== "boolean" ? target : useWindow();
  const capture = typeof target === "boolean" ? target : false;
  watch4(source, (newValue, oldValue) => {
    if (!Array.isArray(event)) {
      addEventListener(unwrapEl(unref6(newValue)), event, listener, capture);
      removeEventListener(unwrapEl(unref6(oldValue)), event, listener, capture);
    } else {
      event.forEach((e) => {
        addEventListener(unwrapEl(unref6(newValue)), e, listener, capture);
        removeEventListener(unwrapEl(unref6(oldValue)), e, listener, capture);
      });
    }
  }, { immediate: true });
};

// node_modules/vuestic-ui/dist/es/src/composables/useResizeObserver.js
import { watch as watch5, onMounted as onMounted3, onBeforeUnmount as onBeforeUnmount3, unref as unref7 } from "vue";
var normalizeElements = (elements) => {
  if (Array.isArray(elements)) {
    return elements.map(unref7);
  }
  const unrefArray = unref7(elements);
  return Array.isArray(unrefArray) ? unrefArray : [unrefArray];
};
var useResizeObserver = (elementsList, cb) => {
  let resizeObserver;
  const observeAll = (elements) => {
    elements.forEach((element) => {
      const unrefElement2 = unref7(element);
      if (!unrefElement2) {
        return;
      }
      if (!(unrefElement2 instanceof Element)) {
        console.error("Vuestic: Trying to observe non-HTMLElement", {
          target: unrefElement2,
          array: elementsList
        });
        throw new Error("Vuestic: Unable to observe non-HTMLElement");
      }
      unrefElement2 && (resizeObserver == null ? void 0 : resizeObserver.observe(unrefElement2));
    });
  };
  watch5(elementsList, (newValue) => {
    resizeObserver == null ? void 0 : resizeObserver.disconnect();
    observeAll(normalizeElements(newValue));
  });
  onMounted3(() => {
    resizeObserver = new ResizeObserver(cb);
    observeAll(normalizeElements(elementsList));
  });
  onBeforeUnmount3(() => resizeObserver == null ? void 0 : resizeObserver.disconnect());
  return resizeObserver;
};

// node_modules/vuestic-ui/dist/es/src/components/va-sticky-scrollbar/VaStickyScrollbar.vue_vue_type_script_setup_true_lang.js
var _sfc_main7 = defineComponent7({
  __name: "VaStickyScrollbar",
  props: {
    el: {},
    direction: { default: "horizontal" },
    offset: { default: 0 }
  },
  setup(__props) {
    const props = __props;
    const currentEl = ref7(null);
    const offsetProp = useNumericProp("offset");
    const parentElement = computed21(() => {
      var _a2;
      if (props.el) {
        return props.el;
      }
      return ((_a2 = currentEl.value) == null ? void 0 : _a2.parentNode) ?? null;
    });
    const parentRect = useElementRect(parentElement);
    const stickyScrollWrapperStyle = computed21(() => {
      const el = parentElement.value;
      if (!el) {
        return {};
      }
      const parentEl = el;
      const scrollSize = getScrollbarSize(parentEl);
      const { bottom, left, right, top } = parentRect.value;
      if (props.direction === "vertical") {
        if (left > window.innerWidth) {
          return { display: "none" };
        }
        if (right < window.innerWidth) {
          return { display: "none" };
        }
        return {
          position: "fixed",
          top: `${top}px`,
          right: 0,
          height: `${parentEl.clientHeight}px`,
          overflowY: "auto",
          overflowX: "hidden"
        };
      }
      if (top > window.innerHeight) {
        return { display: "none" };
      }
      if (bottom < window.innerHeight) {
        return { display: "none" };
      }
      return {
        position: "fixed",
        top: `${Math.min(bottom, window.innerHeight) - scrollSize - Number(offsetProp.value)}px`,
        width: `${parentEl.clientWidth}px`,
        overflowX: "auto",
        overflowY: "hidden"
      };
    });
    useEvent("scroll", (e) => {
      var _a2, _b;
      if (!currentEl.value) {
        return;
      }
      if (props.direction === "horizontal") {
        (_a2 = parentElement.value) == null ? void 0 : _a2.scrollTo({
          left: currentEl.value.scrollLeft
        });
      } else {
        (_b = parentElement.value) == null ? void 0 : _b.scrollTo({
          top: currentEl.value.scrollTop
        });
      }
    }, currentEl);
    useEvent("scroll", (e) => {
      var _a2, _b, _c, _d;
      if (!currentEl.value) {
        return;
      }
      if (props.direction === "horizontal") {
        if (((_a2 = parentElement.value) == null ? void 0 : _a2.scrollLeft) === currentEl.value.scrollLeft) {
          return;
        }
        currentEl.value.scrollTo({
          left: (_b = parentElement.value) == null ? void 0 : _b.scrollLeft
        });
      } else {
        if (((_c = parentElement.value) == null ? void 0 : _c.scrollTop) === currentEl.value.scrollTop) {
          return;
        }
        currentEl.value.scrollTo({
          top: (_d = parentElement.value) == null ? void 0 : _d.scrollTop
        });
      }
    }, parentElement);
    const scrollWidth = ref7(0);
    const scrollHeight = ref7(0);
    useResizeObserver(computed21(() => {
      if (!parentElement.value) {
        return [];
      }
      return [...parentElement.value.children];
    }), () => {
      scrollWidth.value = parentElement.value.scrollWidth;
      scrollHeight.value = parentElement.value.scrollHeight;
    });
    const fakeContentStyle = computed21(() => {
      if (props.direction === "vertical") {
        return {
          width: "1px",
          height: `${scrollHeight.value}px`
        };
      }
      return {
        height: "1px",
        width: `${scrollWidth.value}px`
      };
    });
    return (_ctx, _cache) => {
      return openBlock7(), createElementBlock6("div", {
        style: normalizeStyle2(stickyScrollWrapperStyle.value),
        ref_key: "currentEl",
        ref: currentEl
      }, [
        createElementVNode2("div", {
          style: normalizeStyle2(fakeContentStyle.value)
        }, null, 4)
      ], 4);
    };
  }
});

// node_modules/vuestic-ui/dist/es/src/composables/useBreakpoint.js
import { inject as inject5, computed as computed22 } from "vue";

// node_modules/vuestic-ui/dist/es/src/composables/useIsMounted.js
import { ref as ref8, onMounted as onMounted4, onBeforeUnmount as onBeforeUnmount4 } from "vue";
var useIsMounted = () => {
  const isMounted = ref8(false);
  onMounted4(() => {
    isMounted.value = true;
  });
  onBeforeUnmount4(() => {
    isMounted.value = false;
  });
  return isMounted;
};

// node_modules/vuestic-ui/dist/es/src/composables/useBreakpoint.js
var helpersKeys = ["xs", "sm", "md", "lg", "xl", "smUp", "mdUp", "lgUp", "smDown", "mdDown", "lgDown"];
var defaultHelpers = helpersKeys.reduce((acc, key) => {
  acc[key] = false;
  return acc;
}, {});
var useBreakpoint = () => {
  const injected = inject5(vaBreakpointSymbol, {});
  const isMounted = useIsMounted();
  const { globalConfig } = useGlobalConfig();
  const breakpointConfig = computed22(() => {
    const breakpoint = globalConfig.value.breakpoint;
    if (!breakpoint) {
      warn("useBreakpoint: breakpointConfig is not defined!");
    }
    return breakpoint ?? {};
  });
  const defaultBreakpoint = computed22(() => breakpointConfig.value.enabled ? {
    width: void 0,
    height: void 0,
    current: void 0,
    thresholds: breakpointConfig.value.thresholds,
    ...defaultHelpers
  } : {});
  return useReactiveComputed(() => isMounted.value ? injected : defaultBreakpoint.value);
};

// node_modules/vuestic-ui/dist/es/src/composables/useI18n.js
import { computed as computed23 } from "vue";
var useI18nConfig = () => {
  const { globalConfig, mergeGlobalConfig } = useGlobalConfig();
  const config = computed23(() => globalConfig.value.i18n);
  const mergeIntoConfig = (newConfig) => {
    mergeGlobalConfig({
      i18n: {
        ...config.value,
        ...newConfig
      }
    });
  };
  return {
    config,
    mergeIntoConfig
  };
};

// node_modules/vuestic-ui/dist/es/src/composables/useForm/useForm.js
import { ref as ref9, computed as computed24 } from "vue";

// node_modules/vuestic-ui/dist/es/src/composables/useTemplateRef.js
import { getCurrentInstance as getCurrentInstance10, customRef, onMounted as onMounted5, onUpdated } from "vue";
var useTemplateRef = (key) => {
  const vm = getCurrentInstance10();
  let _trigger = () => {
  };
  const el = customRef((track, trigger) => {
    _trigger = trigger;
    return {
      get() {
        var _a2;
        track();
        return (_a2 = vm.proxy) == null ? void 0 : _a2.$refs[key];
      },
      set(value) {
      }
    };
  });
  onMounted5(_trigger);
  onUpdated(_trigger);
  return el;
};

// node_modules/vuestic-ui/dist/es/src/composables/useForm/useForm.js
var useForm = (elRef) => {
  const form = typeof elRef === "string" ? useTemplateRef(elRef) : typeof elRef === "undefined" ? ref9() : elRef;
  return {
    formRef: form,
    isValid: computed24(() => {
      var _a2;
      return ((_a2 = form.value) == null ? void 0 : _a2.isValid) || false;
    }),
    immediate: computed24(() => {
      var _a2;
      return ((_a2 = form.value) == null ? void 0 : _a2.immediate) || false;
    }),
    isLoading: computed24(() => {
      var _a2;
      return ((_a2 = form.value) == null ? void 0 : _a2.isLoading) || false;
    }),
    isDirty: computed24(() => {
      var _a2;
      return ((_a2 = form.value) == null ? void 0 : _a2.isDirty) || false;
    }),
    isTouched: computed24(() => {
      var _a2;
      return ((_a2 = form.value) == null ? void 0 : _a2.isTouched) || false;
    }),
    fields: computed24(() => {
      var _a2;
      return ((_a2 = form.value) == null ? void 0 : _a2.fields) ?? [];
    }),
    fieldsNamed: computed24(() => {
      var _a2;
      return ((_a2 = form.value) == null ? void 0 : _a2.fieldsNamed) ?? [];
    }),
    fieldNames: computed24(() => {
      var _a2;
      return ((_a2 = form.value) == null ? void 0 : _a2.fieldNames) ?? [];
    }),
    formData: computed24(() => {
      var _a2;
      return ((_a2 = form.value) == null ? void 0 : _a2.formData) ?? {};
    }),
    errorMessages: computed24(() => {
      var _a2;
      return ((_a2 = form.value) == null ? void 0 : _a2.errorMessages) || [];
    }),
    errorMessagesNamed: computed24(() => {
      var _a2;
      return ((_a2 = form.value) == null ? void 0 : _a2.errorMessagesNamed) || {};
    }),
    validate: () => {
      var _a2;
      return (_a2 = form.value) == null ? void 0 : _a2.validate();
    },
    validateAsync: () => {
      var _a2;
      return (_a2 = form.value) == null ? void 0 : _a2.validateAsync();
    },
    reset: () => {
      var _a2;
      return (_a2 = form.value) == null ? void 0 : _a2.reset();
    },
    resetValidation: () => {
      var _a2;
      return (_a2 = form.value) == null ? void 0 : _a2.resetValidation();
    },
    focus: () => {
      var _a2;
      return (_a2 = form.value) == null ? void 0 : _a2.focus();
    },
    focusInvalidField: () => {
      var _a2;
      return (_a2 = form.value) == null ? void 0 : _a2.focusInvalidField();
    }
  };
};

// node_modules/vuestic-ui/dist/es/src/composables/useInputMask/useInputMask.js
import { ref as ref10, computed as computed25, watch as watch6, unref as unref8 } from "vue";

// node_modules/vuestic-ui/dist/es/src/composables/useInputMask/cursor.js
var CursorPosition = ((CursorPosition2) => {
  CursorPosition2[CursorPosition2["BeforeChar"] = -1] = "BeforeChar";
  CursorPosition2[CursorPosition2["Any"] = 0] = "Any";
  CursorPosition2[CursorPosition2["AfterChar"] = 1] = "AfterChar";
  return CursorPosition2;
})(CursorPosition || {});
var Cursor = class extends Number {
  constructor(position, tokens, reversed = false) {
    super(position);
    this.position = position;
    this.tokens = tokens;
    this.reversed = reversed;
  }
  move(direction, amount, cursorPosition = 0) {
    if (this.tokens.every((t) => t.static)) {
      if (direction === 1) {
        this.position = this.tokens.length;
        return this.position;
      } else {
        this.position = 0;
        return this.position;
      }
    }
    for (let i = this.position; i <= this.tokens.length && i >= -1; i += direction) {
      const current = this.tokens[i];
      const next = this.tokens[i + direction] || void 0;
      this.tokens[i - direction] || void 0;
      if (amount === 0) {
        this.position = i;
        return this.position;
      }
      if (next === void 0 && current === void 0) {
        this.position = i;
        return this.position;
      }
      if (cursorPosition === 1) {
        if (current && !current.static && direction > 0) {
          amount--;
          continue;
        }
        if (!(next == null ? void 0 : next.static) && direction < 0 && i !== this.position) {
          amount--;
          if (amount === 0) {
            this.position = i;
            return this.position;
          }
          continue;
        }
      }
      if (cursorPosition === -1) {
        if (!(next == null ? void 0 : next.static)) {
          amount--;
          continue;
        }
      }
      if (cursorPosition === 0) {
        if ((!(current == null ? void 0 : current.static) || !(next == null ? void 0 : next.static)) && direction > 0) {
          amount--;
          continue;
        }
        if (direction < 0) {
          if (next && !next.static) {
            amount--;
            if (i !== this.position) {
              this.position = i;
              return this.position;
            }
          }
        }
      }
    }
    return this.position;
  }
  moveBack(amount, cursorPosition = 0) {
    return this.move(-1, amount, cursorPosition);
  }
  moveForward(amount, cursorPosition = 0) {
    return this.move(1, amount, cursorPosition);
  }
  updateTokens(newTokens, fromEnd = false) {
    if (fromEnd) {
      this.position = this.tokens.length - this.position;
      this.tokens = newTokens;
      this.position = this.tokens.length - this.position;
    } else {
      this.tokens = newTokens;
    }
  }
  valueOf() {
    if (this.position < 0) {
      return 0;
    }
    if (this.position > this.tokens.length) {
      return this.tokens.length;
    }
    return this.position;
  }
};

// node_modules/vuestic-ui/dist/es/src/composables/useInputMask/useInputMask.js
var extractInput = (el) => {
  const htmlEl = unwrapEl(el);
  if (!htmlEl) {
    return null;
  }
  if (htmlEl.tagName === "INPUT") {
    return htmlEl;
  }
  return htmlEl.querySelector("input");
};
var useInputMask = (mask, el) => {
  const inputText = ref10("");
  const formatted = ref10({
    text: "",
    tokens: [],
    data: void 0
  });
  const input = computed25(() => extractInput(el.value));
  const setInputValue = (value, options) => {
    if (input.value.value === value) {
      return;
    }
    input.value.value = value;
    input.value.dispatchEvent(new InputEvent("input", options));
  };
  const onBeforeInput = (e) => {
    const { inputType } = e;
    const eventTarget = e.target;
    const data = e.data === null ? "" : e.data;
    const currentValue = eventTarget.value;
    const selectionStart = eventTarget.selectionStart ?? 0;
    const selectionEnd = eventTarget.selectionEnd ?? 0;
    const cursorStart = new Cursor(selectionStart, formatted.value.tokens);
    const cursorEnd = new Cursor(selectionEnd, formatted.value.tokens);
    if (inputType === "deleteContentBackward") {
      e.preventDefault();
      if (+cursorStart === +cursorEnd) {
        cursorStart.moveBack(1, CursorPosition.AfterChar);
      }
    } else if (inputType === "deleteContentForward" || inputType === "deleteContent" || inputType === "deleteByCut") {
      e.preventDefault();
      if (+cursorStart === +cursorEnd) {
        cursorEnd.moveForward(1, CursorPosition.AfterChar);
      }
    } else if (inputType === "insertText" || inputType === "insertFromPaste") {
      e.preventDefault();
    }
    const tokens = formatted.value.tokens;
    inputText.value = currentValue.slice(0, +cursorStart) + data + currentValue.slice(+cursorEnd);
    formatted.value = unref8(mask).format(inputText.value);
    if (inputType === "insertFromPaste") {
      cursorStart.position += formatted.value.text.length - currentValue.length;
    }
    unref8(mask).handleCursor(cursorStart, cursorEnd, tokens, formatted.value.tokens, data, formatted.value.data);
    setInputValue(formatted.value.text, e);
    eventTarget.setSelectionRange(+cursorStart, +cursorEnd);
  };
  const onKeydown = (e) => {
    const el2 = e.target;
    if (e.key === "ArrowLeft") {
      if (el2.selectionStart === el2.selectionEnd) {
        const cursor = new Cursor(el2.selectionStart ?? 0, formatted.value.tokens);
        cursor.moveBack(1);
        el2.setSelectionRange(+cursor, +cursor);
      } else {
        el2.setSelectionRange(el2.selectionStart, el2.selectionStart);
      }
      e.preventDefault();
    }
    if (e.key === "ArrowRight") {
      if (el2.selectionStart === el2.selectionEnd) {
        const cursor = new Cursor(el2.selectionEnd ?? 0, formatted.value.tokens);
        cursor.moveForward(1);
        el2.setSelectionRange(+cursor, +cursor);
      } else {
        el2.setSelectionRange(el2.selectionEnd, el2.selectionEnd);
      }
      e.preventDefault();
    }
  };
  watch6(input, (newValue, oldValue) => {
    if (newValue) {
      formatted.value = unref8(mask).format(newValue.value);
      const cursor = new Cursor(newValue.selectionEnd ?? 0, formatted.value.tokens);
      cursor.moveForward(1);
      setInputValue(formatted.value.text);
      newValue.setSelectionRange(+cursor, +cursor);
      newValue.addEventListener("beforeinput", onBeforeInput);
      newValue.addEventListener("keydown", onKeydown);
    }
    if (oldValue) {
      oldValue.removeEventListener("beforeinput", onBeforeInput);
      oldValue.removeEventListener("keydown", onKeydown);
    }
  }, { immediate: true });
  const unmasked = computed25(() => {
    return unref8(mask).unformat(formatted.value.text, formatted.value.tokens);
  });
  return {
    inputText: formatted,
    masked: computed25(() => {
      var _a2;
      return ((_a2 = formatted.value) == null ? void 0 : _a2.text) ?? "";
    }),
    unmasked
  };
};

// node_modules/vuestic-ui/dist/es/src/composables/useInputMask/masks/parser.js
var or = (...args) => new RegExp(args.map((r) => r.source).join("|"), "g");
var TOKEN_SPLIT_REGEX = or(
  /(\{[^}]*\})/,
  // Token required to have limits {1, 3}, {1,}, {1}
  /(\\[dws.])/,
  /(^\([^)]*\)$)/,
  // group like (test)
  /(\[[^\]]*\])/,
  // split by [^3]{1}, [a-z], [0-9]{1, 3}
  /(?:)/
  // split for each letter
);
var isMaskSingleGroup = (symbol) => {
  if (!symbol.startsWith("(") || !symbol.endsWith(")")) {
    return false;
  }
  let groupDepth = 0;
  for (let i = 0; i < symbol.length; i++) {
    const char = symbol[i];
    if (char === "(") {
      groupDepth += 1;
    } else if (char === ")") {
      groupDepth -= 1;
      if (groupDepth === 0 && i !== symbol.length - 1) {
        return false;
      }
    }
  }
  return groupDepth === 0;
};
var parseRawTokens = (symbol) => {
  let group = 0;
  const groups = [];
  let currentChunk = "";
  let i = 0;
  while (i < symbol.length) {
    if (symbol[i] === "(" && symbol[i - 1] !== "\\") {
      if (group === 0 && currentChunk.length > 0) {
        groups.push(...currentChunk.split(TOKEN_SPLIT_REGEX).filter((v) => v !== "" && v !== void 0));
        currentChunk = "";
      }
      group += 1;
    }
    currentChunk += symbol[i];
    if (symbol[i] === ")" && symbol[i - 1] !== "\\") {
      group -= 1;
      if (group === 0 && currentChunk.length > 0) {
        groups.push(currentChunk);
        currentChunk = "";
      }
    }
    i++;
  }
  if (currentChunk.length > 0) {
    groups.push(...currentChunk.split(TOKEN_SPLIT_REGEX).filter((v) => v !== "" && v !== void 0));
  }
  return groups.map((g) => g.replace(/^\?[:!>]/, "")).filter((v) => v !== "" && v !== void 0);
};
var RESERVED_SLASH_SYMBOLS = ["d", "D", "w", "W", "s", "S", "."];
var MAX_REPEATED = 10;
var parseTokens = (mask, directlyInGroup = false) => {
  let tokens = [];
  if (isMaskSingleGroup(mask)) {
    mask = mask.slice(1, -1);
    directlyInGroup = true;
  }
  const rawTokens = parseRawTokens(mask);
  for (let i = 0; i < rawTokens.length; i++) {
    const rawToken = rawTokens[i];
    if (rawToken === "\\") {
      continue;
    }
    if (!RESERVED_SLASH_SYMBOLS.includes(rawToken) && rawTokens[i - 1] === "\\") {
      tokens.push({ type: "char", expect: rawToken });
      continue;
    }
    if (rawToken === "|") {
      if (directlyInGroup) {
        tokens = [{
          type: "or regex",
          expect: mask,
          left: [...tokens],
          right: parseTokens(`(${rawTokens.slice(i + 1).join("")})`)
        }];
        break;
      }
      const prevToken = tokens.pop();
      const nextToken = parseTokens(rawTokens[i + 1]);
      tokens.push({
        type: "or regex",
        expect: `${prevToken}|${rawTokens[i + 1]}`,
        left: [prevToken],
        right: nextToken
      });
      continue;
    }
    if (rawToken.startsWith("{") && rawToken.endsWith("}") && rawToken.length > 2) {
      const [v, min, delimiter, max] = rawToken.split(/\{(\d+)(,\s?)?(\d+)?\}$/);
      const prevToken = tokens.pop();
      tokens.push({
        type: "repeated",
        expect: prevToken.expect + rawToken,
        tree: [prevToken],
        min: parseInt(min),
        max: max ? parseInt(max) : delimiter ? MAX_REPEATED : parseInt(min),
        content: rawToken
      });
      continue;
    }
    if (rawToken.endsWith("*")) {
      const prevToken = tokens.pop();
      tokens.push({ type: "repeated", expect: prevToken.expect + rawToken, tree: [prevToken], min: 0, max: MAX_REPEATED, content: prevToken.expect });
      continue;
    }
    if (rawToken.endsWith("+")) {
      const prevToken = tokens.pop();
      tokens.push({ type: "repeated", expect: prevToken.expect + rawToken, tree: [prevToken], min: 1, max: MAX_REPEATED, content: prevToken.expect });
      continue;
    }
    if (rawToken.endsWith("?")) {
      const prevToken = tokens.pop();
      tokens.push({ type: "repeated", expect: prevToken.expect + rawToken, tree: [prevToken], min: 0, max: 1, content: prevToken.expect });
      continue;
    }
    if (["$", "^"].includes(rawToken)) {
      continue;
    }
    if (rawToken.startsWith("(") && rawToken.endsWith(")")) {
      const tree = parseTokens(rawToken.slice(1, -1), true);
      tokens.push({ type: "group", expect: rawToken, tree });
      continue;
    }
    if (rawToken.length === 1 && rawToken !== ".") {
      tokens.push({ type: "char", expect: rawToken });
      continue;
    }
    tokens.push({ type: "regex", expect: rawToken });
  }
  return tokens;
};

// node_modules/vuestic-ui/dist/es/src/composables/useInputMask/masks/regex.js
var normalizeTokens = (tokens, dynamic = false) => {
  let possibleResults = [[]];
  for (const token of tokens) {
    if (token.type === "group") {
      const newResults = [];
      possibleResults.forEach((result) => {
        normalizeTokens(token.tree, dynamic).forEach((result2) => {
          newResults.push([...result, ...result2]);
        });
      });
      possibleResults = newResults;
    }
    if (token.type === "char" || token.type === "regex") {
      const newResults = [];
      possibleResults.forEach((result) => {
        newResults.push([...result, {
          type: token.type,
          expect: token.expect,
          static: token.type === "char",
          // && (!dynamic || result.length > 0),
          dynamic
        }]);
      });
      possibleResults = newResults;
    }
    if (token.type === "repeated") {
      const possibleResults2 = [];
      for (let i = token.min; i <= token.max && i <= 100; i++) {
        const isDynamic = i !== token.min;
        normalizeTokens(token.tree, isDynamic || dynamic).forEach((result) => {
          const repeated = new Array(i).fill(result).flat();
          possibleResults2.push(repeated);
        });
      }
      const newResults = [];
      possibleResults.forEach((result) => {
        possibleResults2.forEach((result2) => {
          newResults.push([...result, ...result2]);
        });
      });
      possibleResults = newResults;
    }
    if (token.type === "or regex") {
      const newPossibleResults = [];
      possibleResults.forEach((existingResult) => {
        normalizeTokens(token.left, true).forEach((result) => {
          newPossibleResults.push([...existingResult, ...result]);
        });
        normalizeTokens(token.right, true).forEach((result) => {
          newPossibleResults.push([...existingResult, ...result]);
        });
      });
      possibleResults = newPossibleResults;
    }
  }
  return possibleResults.reduce((acc, result) => {
    if (acc.find((r) => r.length === result.length && r.every((t, i) => t.expect === result[i].expect))) {
      return acc;
    }
    return [...acc, result];
  }, []);
};
var compareWithMask = (mask, value) => {
  if (!value) {
    return true;
  }
  for (let i = 0; i < mask.length; i++) {
    if (value[i] === void 0) {
      return true;
    }
    if (mask[i].type === "char" && mask[i].expect !== (value == null ? void 0 : value[i])) {
      return false;
    }
    if (mask[i].type === "regex" && !new RegExp(mask[i].expect).test(value[i])) {
      return false;
    }
  }
  return value.length <= mask.length;
};
var compareWithToken = (token, value) => {
  if (token.type === "char" && token.expect !== value) {
    return false;
  }
  if (token.type === "regex" && !new RegExp(token.expect).test(value)) {
    return false;
  }
  return true;
};
var formatByRegexTokens = (possibleResults, value, reverse = false) => {
  var _a2, _b, _c, _d;
  if (reverse) {
    possibleResults = possibleResults.map((result) => result.slice().reverse());
    value = value.split("").reverse().join("");
  }
  let suggestedCharsCount = 0;
  let text = "";
  let valueOffset = 0;
  let tokensOffset = 0;
  const maxPossibleMask = possibleResults.reduce((acc, mask) => Math.max(acc, mask.length), 0);
  const foundTokens = [];
  while (valueOffset < value.length || tokensOffset < maxPossibleMask) {
    possibleResults = possibleResults.filter((tokens) => {
      return compareWithMask(tokens, text);
    });
    const possibleToken = possibleResults.map((mask) => mask[tokensOffset]).filter((token) => token !== void 0);
    if (possibleToken.length === 0) {
      break;
    }
    const possibleSuggestions = possibleToken.filter((token) => token.type === "char");
    const staticCharts = possibleToken.filter((token) => token.static);
    const isOnePossibleStaticChar = staticCharts.reduce((acc, char) => {
      if (acc === null) {
        return char;
      }
      if (acc.expect !== char.expect) {
        return null;
      }
      return acc;
    }, null);
    if (possibleSuggestions.length > 0) {
      const suggestedChar = ((_a2 = possibleSuggestions[0]) == null ? void 0 : _a2.expect) ?? "";
      let canBeSuggested = possibleSuggestions.every((token) => token.expect === suggestedChar) && ((_b = value[valueOffset]) == null ? void 0 : _b.length) > 0;
      const onlyStaticLeft = possibleResults.length === 1 && possibleResults[0].slice(tokensOffset).every((token) => token.static);
      if (possibleSuggestions[0].dynamic) {
        canBeSuggested = canBeSuggested && ((_c = value[valueOffset]) == null ? void 0 : _c.length) > 0;
      }
      if (isOnePossibleStaticChar && ((_d = value[valueOffset]) == null ? void 0 : _d.length) > 0) {
        canBeSuggested = value[valueOffset] !== isOnePossibleStaticChar.expect;
      }
      if (possibleToken.some((token) => compareWithToken(token, value[valueOffset]))) {
        canBeSuggested = false;
      }
      if (onlyStaticLeft) {
        canBeSuggested = true;
      }
      if (canBeSuggested) {
        if (suggestedChar !== value[valueOffset]) {
          text += suggestedChar;
          foundTokens.push(possibleSuggestions[0]);
          tokensOffset += 1;
          suggestedCharsCount += 1;
          continue;
        }
      }
    }
    if (valueOffset >= value.length) {
      break;
    }
    const charCorrectTokens = possibleToken.filter((token) => {
      if (token.type === "char") {
        return token.expect === value[valueOffset];
      }
      if (token.type === "regex") {
        return new RegExp(token.expect).test(value[valueOffset]);
      }
      return false;
    });
    if (value[valueOffset] !== void 0) {
      if (charCorrectTokens.length > 0) {
        text += value[valueOffset];
        foundTokens.push(charCorrectTokens[0]);
        tokensOffset++;
      }
    }
    valueOffset++;
  }
  if (reverse) {
    return {
      text: text.split("").reverse().join(""),
      tokens: foundTokens.reverse(),
      data: suggestedCharsCount
    };
  }
  return {
    text,
    tokens: foundTokens,
    data: suggestedCharsCount
  };
};
var unformat = (text, tokens) => {
  const value = text;
  if (!value) {
    return "";
  }
  return tokens.reduce((acc, token, i) => {
    if (token.static) {
      return acc;
    }
    if (compareWithToken(token, value[i]) && value[i] !== void 0) {
      return acc + value[i];
    }
    return acc;
  }, "");
};
var createRegexMask = (regex, options = { reverse: false }) => {
  const tokens = parseTokens(regex.source);
  const possibleResults = normalizeTokens(tokens);
  return {
    format: (text) => {
      return formatByRegexTokens(possibleResults, text, options.reverse);
    },
    handleCursor(cursorStart, cursorEnd, oldTokens, newTokens, data, suggestedCount = 0) {
      cursorStart.updateTokens(newTokens, options.reverse);
      cursorEnd.updateTokens(newTokens, options.reverse);
      if (!options.reverse) {
        cursorStart.moveForward(data.length, CursorPosition.AfterChar);
        cursorEnd.position = cursorStart.position;
      } else {
        cursorStart.position = cursorEnd.position;
      }
    },
    unformat
  };
};

// node_modules/vuestic-ui/dist/es/src/composables/useInputMask/masks/numeral.js
var createNumeralMask = (options = {}) => {
  const intMask = createRegexMask(/(\d{3} )*(\d{3})/, { reverse: true });
  const { decimal = true, decimalChar = "." } = options;
  const decimalRegex = new RegExp(`[.|,|${decimalChar}]`, "g");
  if (!decimal) {
    return intMask;
  }
  const decimalMask = createRegexMask(/(\d{3} )*(\d{3})/, { reverse: false });
  return {
    format: (text) => {
      const foundDecimal = text.match(decimalRegex);
      if (!foundDecimal) {
        return intMask.format(text);
      }
      const [int = "", decimal2 = "", ...rest] = text.split(foundDecimal[0]);
      const intResult = intMask.format(int);
      const decimalResult = decimalMask.format(decimal2 + rest.join(""));
      return {
        text: intResult.text + decimalChar + decimalResult.text,
        tokens: [...intResult.tokens, { type: "char", static: false, expect: decimalChar, isDecimal: true }, ...decimalResult.tokens]
      };
    },
    handleCursor(selectionStart, selectionEnd, oldTokens, newTokens, data) {
      const decimalIndex = newTokens.findIndex((token) => token.isDecimal);
      if (decimalIndex === -1) {
        return intMask.handleCursor(selectionStart, selectionEnd, oldTokens, newTokens, data);
      }
      if (selectionStart.position < decimalIndex) {
        intMask.handleCursor(selectionStart, selectionEnd, oldTokens, newTokens, data);
      } else {
        decimalMask.handleCursor(selectionStart, selectionEnd, oldTokens, newTokens, data);
      }
    },
    unformat: (text, tokens) => {
      const [int = 0, decimal2 = 0] = text.replace(/ /g, "").split(decimalChar);
      return parseFloat(int + "." + decimal2).toString();
    }
  };
};

// node_modules/vuestic-ui/dist/es/src/composables/useInputMask/masks/date.js
var parseTokens2 = (format) => {
  return format.split("").map((char) => {
    if (char === "m" || char === "d" || char === "y") {
      return { static: false, expect: char };
    }
    return { static: true, expect: char };
  });
};
var getFebMaxDays = (year) => {
  if (Number.isNaN(year)) {
    return 29;
  }
  return year % 4 === 0 ? 29 : 28;
};
var getMaxDays = (year, month) => {
  if (Number.isNaN(month)) {
    return 31;
  }
  if (month === 2) {
    return getFebMaxDays(year);
  }
  if ([4, 6, 9, 11].includes(month)) {
    return 30;
  }
  return 31;
};
var removeStaticCharsFromEnd = (tokens) => {
  let i = tokens.length - 1;
  while (tokens[i] && tokens[i].static) {
    i--;
  }
  return tokens.slice(0, i + 1);
};
var createDateMask = (format = "yyyy/mm/dd") => {
  const tokens = parseTokens2(format);
  const cache = /* @__PURE__ */ new Map();
  return {
    format(text) {
      const minorTokens = [];
      let valueOffset = 0;
      let tokenOffset = 0;
      for (let i = 0; i < tokens.length; i++) {
        const token = tokens[tokenOffset];
        if (token.static) {
          minorTokens.push({ value: token.expect, expect: token.expect, static: true });
          tokenOffset++;
          if (token.expect === text[valueOffset]) {
            valueOffset++;
          }
          continue;
        }
        if (text[valueOffset] === void 0) {
          break;
        }
        if (!/\d/.test(text[valueOffset])) {
          const nextTokensHasStatic = tokens.slice(tokenOffset, text.length).some((t) => t.static);
          if (nextTokensHasStatic) {
            tokenOffset++;
          } else {
            valueOffset++;
          }
          continue;
        }
        minorTokens.push({ value: text[valueOffset], expect: token.expect, static: false });
        valueOffset++;
        tokenOffset++;
      }
      const majorTokens = removeStaticCharsFromEnd(minorTokens).reduce((acc, p, index) => {
        var _a2;
        if (((_a2 = acc[acc.length - 1]) == null ? void 0 : _a2.expect) === p.expect) {
          acc[acc.length - 1].value += p.value;
          acc[acc.length - 1].tree.push(p);
          return acc;
        }
        acc.push({
          value: p.value,
          expect: p.expect,
          tree: [p]
        });
        return acc;
      }, []);
      majorTokens.forEach((t, index, array) => {
        if (t.expect === "m") {
          const num = parseInt(t.value);
          if (num > 12) {
            t.value = "12";
            t.tree[0].static = true;
            t.tree[1].static = false;
          }
          if (num < 1 && t.value.length === 2) {
            t.value = "01";
            t.tree[0].static = true;
            t.tree[1].static = false;
          }
          if (num > 1 && num < 10 && t.value.length === 1) {
            t.value = "0" + num;
            t.tree.unshift({ value: "0", expect: "m", static: true });
            t.tree[1].static = false;
          }
        }
        if (t.expect === "d") {
          const year = majorTokens.find((t2) => t2.expect === "y" && t2.used === void 0);
          const month = majorTokens.find((t2) => t2.expect === "m" && t2.used === void 0);
          if (year) {
            year.used = true;
          }
          if (month) {
            month.used = true;
          }
          const m = Number(month == null ? void 0 : month.value);
          const maxDays = getMaxDays(Number(year == null ? void 0 : year.value), m);
          if (m === 2) {
            if (Number(t.value) >= 29) {
              t.value = "29";
            }
            if (t.value === "28" && cache.get(index) === "29") {
              t.value = "29";
            }
            cache.set(index, t.value);
          }
          const num = parseInt(t.value);
          if (num > maxDays && t.value.length === 2) {
            t.value = maxDays.toString();
            t.tree[0].static = true;
            t.tree[1].static = false;
          }
          if (num < 1 && t.value.length === 2) {
            t.value = "01";
            t.tree[0].static = true;
            t.tree[1].static = false;
          }
          if (num > 3 && num < 10 && t.value.length === 1) {
            t.value = "0" + num;
            t.tree.unshift({ value: "0", expect: "d", static: true });
            t.tree[1].static = false;
          }
        }
      });
      const newText = majorTokens.reduce((acc, p) => acc + p.value, "");
      const newTokens = tokens.map((t) => ({
        ...t,
        static: false
      }));
      return {
        text: newText,
        tokens: newTokens,
        data: majorTokens.reduce((acc, p) => acc.concat(p.tree), [])
      };
    },
    handleCursor(cursorStart, cursorEnd, oldTokens, newTokens, data, minorTokens) {
      cursorStart.updateTokens(minorTokens);
      cursorEnd.updateTokens(minorTokens);
      cursorStart.moveForward(data.length, CursorPosition.AfterChar);
      cursorEnd.position = cursorStart.position;
    },
    unformat: (text, tokens2) => {
      return text.replace(/\//g, "");
    }
  };
};

// node_modules/vuestic-ui/dist/es/src/composables/useStickyTableHeaders/useStickyTableHeaders.js
import { computed as computed26, watchEffect as watchEffect3 } from "vue";

// node_modules/vuestic-ui/dist/es/src/composables/useElementBackground.js
import { ref as ref11, watchEffect as watchEffect2 } from "vue";
var parseRgba = (rgba) => {
  let values;
  if (rgba.startsWith("rgba")) {
    values = rgba.substring(5, rgba.length - 1).split(",");
  } else {
    values = rgba.substring(4, rgba.length - 1).split(",");
  }
  values[0] = Number(values[0]);
  values[1] = Number(values[1]);
  values[2] = Number(values[2]);
  if (values[3] === void 0) {
    values[3] = 1;
  } else {
    values[3] = Number(values[3]);
  }
  return values;
};
var toHex = (color) => {
  return "#" + (color[0] | 1 << 8).toString(16).slice(1) + (color[1] | 1 << 8).toString(16).slice(1) + (color[2] | 1 << 8).toString(16).slice(1) + (color[3] * 255 | 1 << 8).toString(16).slice(1);
};
var getParentsWithBackground = (el) => {
  const parents = [];
  let currentEl = el;
  while (currentEl) {
    if (!(currentEl instanceof HTMLElement) || !currentEl) {
      return parents;
    }
    const { backgroundColor, willChange } = window.getComputedStyle(currentEl);
    const bgWillChange = willChange.includes("background");
    const parsedColor = parseRgba(backgroundColor);
    if (parsedColor[3] === 1 && !bgWillChange) {
      parents.push(currentEl);
      return parents;
    }
    if (parsedColor[3] !== 0 || bgWillChange) {
      parents.push(currentEl);
    }
    currentEl = currentEl.parentElement;
  }
  return parents;
};
var WATCHER_CLASS = "va-background-watcher";
var watchElementBackground = (el, cb) => {
  el.className = WATCHER_CLASS + " " + el.className;
  el.addEventListener("transitionend", (e) => {
    if (e.target !== el) {
      return;
    }
    cb();
  });
  return () => {
    el.className = el.className.replace(WATCHER_CLASS, "");
    el.removeEventListener("transitionend", cb);
  };
};
var watchElementsBackground = (els, cb) => {
  const unwatchers = els.map((el) => watchElementBackground(el, cb));
  return () => {
    unwatchers.forEach((unwatch) => unwatch());
  };
};
var applyColors2 = (color1, color2) => {
  const weight = color2[3];
  if (weight === 1) {
    return color2;
  }
  if (weight === 0) {
    return color1;
  }
  const c1 = Math.round(color1[0] * (1 - weight) + color2[0] * weight);
  const c2 = Math.round(color1[1] * (1 - weight) + color2[1] * weight);
  const c3 = Math.round(color1[2] * (1 - weight) + color2[2] * weight);
  return [c1, c2, c3, 1];
};
var getColorFromElements = (els) => {
  let currentColor = [0, 0, 0, 0];
  for (let i = els.length - 1; i >= 0; i--) {
    currentColor = applyColors2(currentColor, parseRgba(window.getComputedStyle(els[i]).backgroundColor));
  }
  return currentColor;
};
var useElementBackground = (el) => {
  const color = ref11("#000000");
  let unWatchAll = () => void 0;
  watchEffect2(() => {
    unWatchAll();
    if (el.value) {
      const parents = getParentsWithBackground(el.value);
      unWatchAll = watchElementsBackground(parents, () => {
        color.value = toHex(getColorFromElements(parents));
      });
      color.value = toHex(getColorFromElements(parents));
    }
  });
  return color;
};

// node_modules/vuestic-ui/dist/es/src/composables/useStickyTableHeaders/useStickyTableHeaders.js
var syncTh = (thead1, thead2) => {
  const ths1 = thead1.querySelectorAll("th");
  const ths2 = thead2.querySelectorAll("th");
  ths1.forEach((th, index) => {
    const th2 = ths2[index];
    th2.style.width = `${th.getBoundingClientRect().width}px`;
  });
};
var recursiveGetOffset = (el, offset2 = 0) => {
  if (!el) {
    return offset2;
  }
  return recursiveGetOffset(el.offsetParent, offset2 + el.offsetTop);
};
var useStickyTableHeaders = (tableEl, offset2 = 0) => {
  let mutationObserver = null;
  let headClone = null;
  let head = null;
  let table = null;
  let headOffset = 0;
  let hasTransform = false;
  let tableHeight = 0;
  let headHeight = 0;
  const htmlTable = computed26(() => {
    if (!tableEl.value) {
      return null;
    }
    const el = "$el" in tableEl.value ? tableEl.value.$el : tableEl.value;
    return el.tagName === "TABLE" ? el : el.querySelector("table");
  });
  const htmlTableHead = computed26(() => {
    if (!htmlTable.value) {
      return null;
    }
    return htmlTable.value.querySelector("thead");
  });
  const bg = useElementBackground(htmlTableHead);
  watchEffect3(() => {
    if (!tableEl.value) {
      return;
    }
    const rootEl = htmlTable.value;
    if (!rootEl) {
      return;
    }
    table = htmlTable.value;
    head = htmlTableHead.value;
    if (!head) {
      return;
    }
    table.style.position = "relative";
    headClone = head.cloneNode(true);
    headClone.style.position = "fixed";
    headClone.style.top = "0px";
    headClone.style.width = `${table.clientWidth}px`;
    headClone.style.zIndex = "1";
    headClone.style.backgroundColor = bg.value;
    headClone.style.display = "none";
    table.appendChild(headClone);
    syncTh(head, headClone);
    headOffset = recursiveGetOffset(head);
    hasTransform = window.getComputedStyle(table).transform !== "none";
    tableHeight = table.clientHeight;
    headHeight = head.clientHeight;
    mutationObserver = new MutationObserver(() => {
      if (!headClone) {
        return;
      }
      if (!head) {
        return;
      }
      if (!table) {
        return;
      }
      headClone.style.width = `${table.clientWidth}px`;
      syncTh(head, headClone);
      headOffset = recursiveGetOffset(head);
      tableHeight = table.clientHeight;
      headHeight = head.clientHeight;
    });
    mutationObserver.observe(table, {
      childList: true,
      subtree: true,
      attributes: true
    });
  });
  useEvent("scroll", () => {
    if (!headClone) {
      return;
    }
    const y = window.scrollY;
    if (y > headOffset - offset2 && y < headOffset + tableHeight - offset2 - headHeight) {
      headClone.style.display = "block";
      if (hasTransform) {
        headClone.style.top = `${y - headOffset + offset2 - 2}px`;
      } else {
        headClone.style.top = `${offset2}px`;
      }
    } else {
      headClone.style.top = "0px";
      headClone.style.display = "none";
    }
  });
};

// node_modules/vuestic-ui/dist/es/src/services/vue-plugin/utils/global-properties.js
var extractGlobalProperties = (app) => app.config.globalProperties;
var defineGlobalProperty = (app, key, v) => {
  const globalProperties = extractGlobalProperties(app);
  globalProperties[key] = v;
};
var getGlobalProperty = (app, key) => {
  return extractGlobalProperties(app)[key];
};

// node_modules/vuestic-ui/dist/es/src/services/global-config/plugin/index.js
var GlobalConfigPlugin = defineVuesticPlugin((config = {}) => ({
  install(app) {
    const globalConfig = createGlobalConfig(config);
    if (config == null ? void 0 : config.componentsAll) {
      console.warn("Global config -> `componentsAll` was moved to Global config -> components.all. Please replace this to make it work. More info here: https://github.com/epicmaxco/vuestic-ui/issues/1967");
    }
    app.provide(GLOBAL_CONFIG, globalConfig);
    defineGlobalProperty(app, "$vaConfig", globalConfig);
  }
}));

// node_modules/vuestic-ui/dist/es/src/services/color/plugin/create-color-config-plugin.js
import { computed as computed27, watch as watch7 } from "vue";

// node_modules/vuestic-ui/dist/es/src/utils/dom.js
var addOrUpdateStyleElement = (id, getStyles) => {
  if (isServer()) {
    return;
  }
  let stylesElement = document.getElementById(id);
  if (stylesElement) {
    stylesElement.innerHTML = getStyles();
  } else {
    stylesElement = document.createElement("style");
    stylesElement.setAttribute("type", "text/css");
    stylesElement.setAttribute("id", id);
    stylesElement.innerHTML = getStyles();
    document.head.append(stylesElement);
  }
};
var removeStyleElement = (id) => {
  var _a2;
  (_a2 = document.getElementById(id)) == null ? void 0 : _a2.remove();
};

// node_modules/vuestic-ui/dist/es/src/services/color/plugin/create-color-config-plugin.js
var generateCSSVariable = (key, value) => {
  return `${cssVariableName(key)}: ${value};
`;
};
var STYLE_ROOT_ATTR = "data-va-app";
var getStyleElementId = (id) => `va-color-variables-${id}`;
var createColorConfigPlugin = (app, config) => {
  const { colors: configColors, getTextColor, getColor, currentPresetName, applyPreset } = useColors();
  const renderCSSVariables = (colors = configColors) => {
    if (!colors) {
      return;
    }
    const colorNames = Object.keys(colors);
    const renderedColors = colorNames.map((key) => `${cssVariableName(key)}: ${colors[key]}`).join(";");
    const renderedOnColors = colorNames.map((key) => `${cssVariableName(`on-${key}`)}: ${getColor(getTextColor(colors[key]))}`).join(";");
    return `${renderedColors};${renderedOnColors}`;
  };
  const renderCSSVariablesStyleContent = (colors = configColors, selector = ":root, :host") => {
    const colorNames = Object.keys(colors);
    let result = `${selector} {
`;
    colorNames.forEach((key) => {
      result += generateCSSVariable(key, colors[key]);
    });
    colorNames.forEach((key) => {
      result += generateCSSVariable(`on-${key}`, getColor(getTextColor(colors[key])));
    });
    result += "}\n";
    return result;
  };
  const uniqueId = computed27(() => app._uid);
  const stylesRootSelector = computed27(() => ":root, :host");
  const updateColors = (newValue) => {
    if (!newValue || isServer()) {
      return;
    }
    const styleContent = renderCSSVariablesStyleContent(newValue, stylesRootSelector.value);
    addOrUpdateStyleElement(getStyleElementId(uniqueId.value), () => styleContent);
  };
  function getAppStylesRootAttribute() {
    return { [STYLE_ROOT_ATTR]: uniqueId.value };
  }
  const origMount = app.mount;
  app.mount = function(...args) {
    const result = origMount.apply(this, args);
    const appRootElement = app._container;
    const existingStylesId = appRootElement.getAttribute(STYLE_ROOT_ATTR);
    if (existingStylesId && existingStylesId !== uniqueId.value.toString()) {
      removeStyleElement(getStyleElementId(existingStylesId));
    }
    appRootElement.setAttribute(STYLE_ROOT_ATTR, uniqueId.value.toString());
    return result;
  };
  watch7(configColors, (newValue) => {
    updateColors(newValue);
  }, { immediate: true, deep: true });
  return {
    colors: configColors,
    currentPresetName,
    getAppStylesRootAttribute,
    renderCSSVariables,
    updateColors,
    renderCSSVariablesStyleContent
  };
};

// node_modules/vuestic-ui/dist/es/src/services/color/plugin/index.js
var ColorConfigPlugin = defineVuesticPlugin((config) => ({
  install(app) {
    defineGlobalProperty(app, "$vaColorConfig", createColorConfigPlugin(app));
  }
}));

// node_modules/vuestic-ui/dist/es/src/services/breakpoint/plugin/create-service.js
import { computed as computed29, watch as watch9 } from "vue";

// node_modules/vuestic-ui/dist/es/src/utils/uuid.js
var counter = 0;
var getRandomString = (stringLength = 4) => {
  return Math.random().toString(36).substring(2, stringLength + 2);
};
var generateUniqueId = () => {
  return `${getRandomString(8)}-${getRandomString(4)}-${getRandomString(4)}-${++counter}`;
};

// node_modules/vuestic-ui/dist/es/src/composables/useWindowSize.js
import { reactive as reactive3, computed as computed28, watch as watch8 } from "vue";
function useWindowSize() {
  const windowSizes = reactive3({
    width: void 0,
    height: void 0
  });
  const setCurrentWindowSizes = () => {
    windowSizes.width = window == null ? void 0 : window.innerWidth;
    windowSizes.height = window == null ? void 0 : window.innerHeight;
  };
  const isMounted = computed28(isClient);
  watch8(isMounted, (newValue) => {
    if (!newValue) {
      return;
    }
    setCurrentWindowSizes();
  }, { immediate: true });
  useEvent("resize", setCurrentWindowSizes, true);
  return { windowSizes };
}

// node_modules/vuestic-ui/dist/es/src/composables/useDocument.js
var useDocument = () => useClientOnly(() => document);

// node_modules/vuestic-ui/dist/es/src/services/breakpoint/plugin/create-service.js
var createBreakpointConfigPlugin = (app) => {
  var _a2;
  const globalConfig = (_a2 = getGlobalProperty(app, "$vaConfig")) == null ? void 0 : _a2.globalConfig;
  if (!globalConfig) {
    warn("createBreakpointConfigPlugin: globalConfig is not defined!");
    return {};
  }
  const breakpointConfig = computed29(() => {
    const breakpoint = globalConfig.value.breakpoint;
    if (!breakpoint) {
      warn("createBreakpointConfigPlugin: breakpointConfig is not defined!");
    }
    return breakpoint ?? {};
  });
  if (!breakpointConfig.value.enabled) {
    return {};
  }
  if (!breakpointConfig.value.thresholds || !Object.values(breakpointConfig.value.thresholds).length) {
    warn("createBreakpointConfigPlugin: there are no defined thresholds!");
    return {};
  }
  const { windowSizes } = useWindowSize();
  const isMounted = computed29(isClient);
  const currentBreakpoint = computed29(() => {
    if (!isMounted.value || !windowSizes.width) {
      return;
    }
    return Object.entries(breakpointConfig.value.thresholds).reduce((acc, [key, value]) => {
      if (windowSizes.width >= value) {
        acc = key;
      }
      return acc;
    }, "xs");
  });
  const screenClasses = computed29(() => Object.keys(breakpointConfig.value.thresholds).reduce((acc, threshold) => {
    acc[threshold] = `va-screen-${threshold}`;
    return acc;
  }, {}));
  const generateHelpersMediaCss = () => {
    let result = "";
    Object.values(breakpointConfig.value.thresholds).forEach((thresholdValue, index) => {
      result += `@media screen and (min-width: ${thresholdValue}px) {`;
      result += `:root { --va-media-ratio: ${(index + 1) * 0.2} }`;
      result += "}\n";
    });
    return result;
  };
  const uniqueId = computed29(generateUniqueId);
  addOrUpdateStyleElement(`va-helpers-media-${uniqueId.value}`, generateHelpersMediaCss);
  const getDocument = useDocument();
  watch9(currentBreakpoint, (newValue) => {
    if (!newValue || !breakpointConfig.value.bodyClass || !getDocument.value) {
      return;
    }
    getDocument.value.body.classList.forEach((className) => {
      if (Object.values(screenClasses.value).includes(className)) {
        getDocument.value.body.classList.remove(className);
      }
    });
    getDocument.value.body.classList.add(screenClasses.value[newValue]);
  }, { immediate: true });
  const breakpointHelpers = computed29(() => {
    const isXs = currentBreakpoint.value === "xs";
    const isSm = currentBreakpoint.value === "sm";
    const isMd = currentBreakpoint.value === "md";
    const isLg = currentBreakpoint.value === "lg";
    const isXl = currentBreakpoint.value === "xl";
    return {
      xs: isXs,
      sm: isSm,
      md: isMd,
      lg: isLg,
      xl: isXl,
      smUp: isSm || isMd || isLg || isXl,
      mdUp: isMd || isLg || isXl,
      lgUp: isLg || isXl,
      smDown: isXs || isSm,
      mdDown: isXs || isSm || isMd,
      lgDown: isXs || isSm || isMd || isLg
    };
  });
  return useReactiveComputed(() => ({
    width: windowSizes.width,
    height: windowSizes.height,
    current: currentBreakpoint.value,
    thresholds: breakpointConfig.value.thresholds,
    ...breakpointHelpers.value
  }));
};

// node_modules/vuestic-ui/dist/es/src/services/breakpoint/plugin/index.js
var BreakpointConfigPlugin = defineVuesticPlugin(() => ({
  install(app) {
    const breakpointConfig = createBreakpointConfigPlugin(app);
    app.provide(vaBreakpointSymbol, breakpointConfig);
    defineGlobalProperty(app, "$vaBreakpoint", breakpointConfig);
  }
}));

// node_modules/vuestic-ui/dist/es/src/components/va-toast/toast.js
import { createVNode as createVNode3, render } from "vue";

// node_modules/vuestic-ui/dist/es/src/components/va-toast/VaToast.vue_vue_type_script_setup_true_lang.js
import { defineComponent as defineComponent8, shallowRef, computed as computed33, ref as ref13, onMounted as onMounted7, openBlock as openBlock8, createBlock as createBlock5, Transition, withCtx as withCtx5, withDirectives, createElementVNode as createElementVNode3, normalizeClass as normalizeClass3, normalizeStyle as normalizeStyle3, unref as unref10, createElementBlock as createElementBlock7, toDisplayString as toDisplayString3, createCommentVNode as createCommentVNode3, vShow, createVNode as createVNode2, withModifiers, withKeys } from "vue";

// node_modules/vuestic-ui/dist/es/src/components/va-toast/hooks/useToastService.js
import { ref as ref12, getCurrentInstance as getCurrentInstance11, computed as computed30, onMounted as onMounted6, onBeforeUnmount as onBeforeUnmount5 } from "vue";
var GAP = 5;
var toastInstances = ref12([]);
var getNodeProps = (vNode) => {
  var _a2;
  return ((_a2 = vNode.component) == null ? void 0 : _a2.props) || {};
};
var getTranslateValue = (item) => {
  if (item.el) {
    return item.el.offsetHeight + GAP;
  }
  return 0;
};
var useToastService = (props) => {
  const currentInstance = getCurrentInstance11();
  const yOffset = computed30(() => {
    const currentIndex = toastInstances.value.findIndex((instance) => instance === currentInstance.vnode);
    if (currentIndex === -1) {
      return 0;
    }
    return toastInstances.value.slice(currentIndex + 1).reduce((acc, instance) => {
      const {
        position: itemPosition
      } = getNodeProps(instance);
      const { position } = props;
      if (position === itemPosition) {
        return getTranslateValue(instance) + acc;
      }
      return acc;
    }, 0);
  });
  onMounted6(() => {
    toastInstances.value.unshift(currentInstance.vnode);
  });
  onBeforeUnmount5(() => {
    toastInstances.value = toastInstances.value.filter((item) => item !== currentInstance.vnode);
  });
  return {
    yOffset,
    updateYOffset: () => {
      toastInstances.value = toastInstances.value.filter((item) => item !== currentInstance.vnode);
    }
  };
};

// node_modules/vuestic-ui/dist/es/src/composables/useTimer.js
var useTimer = () => {
  let timer;
  const start = (...args) => {
    timer = window.setTimeout(...args);
    return timer;
  };
  const clear = () => timer && window.clearTimeout(timer);
  return {
    start,
    clear
  };
};

// node_modules/vuestic-ui/dist/es/src/composables/useTranslation.js
import { computed as computed31, getCurrentInstance as getCurrentInstance12 } from "vue";
var isTranslationKey = (value) => value.startsWith("$t:");
var useTranslationProp = (defaultValue) => {
  return { type: String, default: defaultValue };
};
var applyI18nTemplate = (key, values) => {
  if (!values) {
    return key;
  }
  Object.keys(values).forEach((valueKey) => {
    key = key.replace(`{${valueKey}}`, String(values[valueKey]));
  });
  return key;
};
var useTranslation = () => {
  const { globalConfig } = useGlobalConfig();
  const config = computed31(() => globalConfig.value.i18n);
  function t(key, values) {
    var _a2;
    const $t = (_a2 = getCurrentInstance12()) == null ? void 0 : _a2.appContext.config.globalProperties.$t;
    if (typeof $t === "function") {
      const translated2 = $t(`vuestic.${key}`, values);
      if (translated2) {
        return translated2;
      }
    }
    const translated = config.value[key];
    if (!translated) {
      warn(`${key} not found in VuesticUI i18n config`);
      return key;
    }
    return applyI18nTemplate(translated, values) || key;
  }
  function tp(key, values) {
    if (!key) {
      return "";
    }
    if (isTranslationKey(key)) {
      return t(key.slice(3), values);
    }
    return applyI18nTemplate(key, values) || key;
  }
  return {
    tp,
    t
  };
};

// node_modules/vuestic-ui/dist/es/src/composables/useTextColor.js
import { getCurrentInstance as getCurrentInstance13, computed as computed32, unref as unref9 } from "vue";
var useTextColor = (componentColor, isTransparent = false) => {
  const { props } = getCurrentInstance13();
  const { getColor, getTextColor } = useColors();
  const textColorComputed = computed32(() => {
    if (props.textColor) {
      return getColor(props.textColor);
    }
    const bg = componentColor ? unref9(componentColor) : props.color;
    if (!bg) {
      return "currentColor";
    }
    const componentColorHex = getColor(bg);
    if (isColorTransparent(componentColorHex)) {
      return "currentColor";
    }
    return unref9(isTransparent) ? componentColorHex : getColor(getTextColor(componentColorHex));
  });
  return { textColorComputed };
};

// node_modules/vuestic-ui/dist/es/src/components/va-toast/VaToast.vue_vue_type_script_setup_true_lang.js
import "D:/Desktop/forntend/Front_End_Web_Hotel_Nhom_2/my-nuxt-app/node_modules/vuestic-ui/dist/es/VaToast.css";
var _hoisted_15 = ["role", "aria-live"];
var _hoisted_2 = { class: "va-toast__group" };
var _hoisted_3 = ["textContent"];
var _hoisted_4 = { class: "va-toast__content" };
var _hoisted_5 = ["innerHTML"];
var _hoisted_6 = ["textContent"];
var _hoisted_7 = {
  key: 1,
  class: "va-toast__content"
};
var _sfc_main8 = defineComponent8({
  ...{
    name: "VaToast"
  },
  __name: "VaToast",
  props: {
    ...useComponentPresetProp,
    title: { type: String, default: "" },
    offsetY: { type: [Number, String], default: 16 },
    offsetX: { type: [Number, String], default: 16 },
    message: { type: [String, Function], default: "" },
    dangerouslyUseHtmlString: { type: Boolean, default: false },
    icon: { type: String, default: "close" },
    customClass: { type: String, default: "" },
    duration: { type: [Number, String], default: 5e3 },
    color: { type: String, default: "primary" },
    closeable: { type: Boolean, default: true },
    onClose: { type: Function },
    onClick: { type: Function },
    multiLine: { type: Boolean, default: false },
    position: {
      type: String,
      default: "top-right",
      validator: (value) => ["top-right", "top-center", "top-left", "bottom-right", "bottom-center", "bottom-left"].includes(value)
    },
    render: { type: Function },
    ariaCloseLabel: useTranslationProp("$t:close"),
    role: { type: String, default: void 0 },
    inline: { type: Boolean, default: false }
  },
  emits: ["on-click", "on-close"],
  setup(__props, { emit: __emit }) {
    const VaToastRenderer = defineComponent8({
      name: "VaToastRenderer",
      props: {
        render: { type: Function, required: true }
      },
      setup: (props2) => () => props2.render()
    });
    const { tp } = useTranslation();
    const props = __props;
    const emit = __emit;
    const rootElement = shallowRef();
    const { getColor } = useColors();
    const { textColorComputed } = useTextColor(computed33(() => getColor(props.color)));
    const offsetYComputed = useNumericProp("offsetY");
    const offsetXComputed = useNumericProp("offsetX");
    const durationComputed = useNumericProp("duration");
    const visible = ref13(false);
    const {
      yOffset,
      updateYOffset
    } = useToastService(props);
    const positionObject = computed33(() => ({
      vertical: props.position.includes("top") ? "top" : "bottom",
      horizontal: props.position.includes("center") ? "center" : props.position.includes("right") ? "right" : "left"
    }));
    const getPositionStyle = () => {
      const vertical = positionObject.value.vertical;
      const horizontal = positionObject.value.horizontal;
      if (horizontal === "center") {
        return {
          [vertical]: `${offsetYComputed.value + yOffset.value}px`,
          left: "50%",
          "--va-toast-x-shift": "-50%"
        };
      }
      return {
        [vertical]: `${offsetYComputed.value + yOffset.value}px`,
        [horizontal]: `${offsetXComputed.value}px`
      };
    };
    const toastClasses = computed33(() => [
      props.customClass,
      props.multiLine ? "va-toast--multiline" : "",
      props.inline ? "va-toast--inline" : "",
      [`va-toast--${props.position}`]
    ]);
    const toastStyles = computed33(() => ({
      ...getPositionStyle(),
      backgroundColor: getColor(props.color),
      color: textColorComputed.value
    }));
    const computedAriaLive = computed33(() => {
      if (props.role === "status") {
        return "polite";
      } else {
        return "assertive";
      }
    });
    const computedMessage = computed33(() => typeof props.message === "function" ? props.message() : props.message);
    const destroyElement = () => {
      var _a2, _b;
      (_a2 = rootElement.value) == null ? void 0 : _a2.removeEventListener("transitionend", destroyElement);
      (_b = rootElement.value) == null ? void 0 : _b.remove();
    };
    const onToastClick = () => {
      if (typeof props.onClick === "function") {
        props.onClick();
      } else {
        emit("on-click");
      }
    };
    const onToastClose = () => {
      visible.value = false;
      updateYOffset();
    };
    const onHidden = () => {
      if (typeof props.onClose === "function") {
        props.onClose();
      } else {
        emit("on-close");
      }
      destroyElement();
    };
    const timer = useTimer();
    const clearTimer = timer.clear;
    const startTimer = () => {
      if (durationComputed.value > 0) {
        timer.start(() => visible.value && onToastClose(), durationComputed.value);
      }
    };
    onMounted7(() => {
      visible.value = true;
      startTimer();
    });
    return (_ctx, _cache) => {
      return openBlock8(), createBlock5(Transition, {
        name: "va-toast-fade",
        onAfterLeave: onHidden
      }, {
        default: withCtx5(() => [
          withDirectives(createElementVNode3("div", {
            ref_key: "rootElement",
            ref: rootElement,
            role: _ctx.$props.role ?? _ctx.$props.closeable ? "alertdialog" : "alert",
            "aria-live": computedAriaLive.value,
            "aria-atomic": "true",
            class: normalizeClass3(["va-toast", toastClasses.value]),
            style: normalizeStyle3(toastStyles.value),
            onMouseenter: _cache[0] || (_cache[0] = //@ts-ignore
            (...args) => unref10(clearTimer) && unref10(clearTimer)(...args)),
            onMouseleave: startTimer,
            onClick: onToastClick
          }, [
            createElementVNode3("div", _hoisted_2, [
              _ctx.$props.title ? (openBlock8(), createElementBlock7("h2", {
                key: 0,
                class: "va-toast__title",
                textContent: toDisplayString3(_ctx.$props.title)
              }, null, 8, _hoisted_3)) : createCommentVNode3("", true),
              withDirectives(createElementVNode3("div", _hoisted_4, [
                _ctx.$props.dangerouslyUseHtmlString ? (openBlock8(), createElementBlock7("div", {
                  key: 0,
                  innerHTML: computedMessage.value
                }, null, 8, _hoisted_5)) : (openBlock8(), createElementBlock7("p", {
                  key: 1,
                  textContent: toDisplayString3(computedMessage.value)
                }, null, 8, _hoisted_6))
              ], 512), [
                [vShow, _ctx.$props.message]
              ]),
              _ctx.$props.render ? (openBlock8(), createElementBlock7("div", _hoisted_7, [
                createVNode2(unref10(VaToastRenderer), {
                  render: _ctx.$props.render
                }, null, 8, ["render"])
              ])) : createCommentVNode3("", true),
              _ctx.$props.closeable ? (openBlock8(), createBlock5(_sfc_main, {
                key: 2,
                class: "va-toast__close-icon",
                role: "button",
                "aria-label": unref10(tp)(_ctx.$props.ariaCloseLabel),
                tabindex: "0",
                size: "1rem",
                name: _ctx.$props.icon,
                onClick: withModifiers(onToastClose, ["stop"]),
                onKeydown: withKeys(withModifiers(onToastClose, ["stop"]), ["enter"])
              }, null, 8, ["aria-label", "name", "onKeydown"])) : createCommentVNode3("", true)
            ])
          ], 46, _hoisted_15), [
            [vShow, visible.value]
          ])
        ]),
        _: 1
      });
    };
  }
});

// node_modules/vuestic-ui/dist/es/src/components/va-toast/toast.js
var VaToast = withConfigTransport(_sfc_main8);
var seed = 1;
getGlobal().vaToastInstances = [];
var getNodeProps2 = (vNode) => {
  var _a2;
  return ((_a2 = vNode.component) == null ? void 0 : _a2.props) || {};
};
var closeNotification = (targetInstance, destroyElementFn) => {
  if (!targetInstance) {
    return;
  }
  if (!getGlobal().vaToastInstances.length) {
    seed = 1;
    return;
  }
  const targetInstanceIndex = getGlobal().vaToastInstances.findIndex((instance) => instance === targetInstance);
  if (targetInstanceIndex < 0) {
    return;
  }
  destroyElementFn();
  getGlobal().vaToastInstances = getGlobal().vaToastInstances.reduce((acc, instance, index) => {
    if (instance === targetInstance) {
      return acc;
    }
    return [...acc, instance];
  }, []);
  if (!getGlobal().vaToastInstances.length) {
    seed = 1;
  }
};
var destroy = (el, node) => {
  if (el) {
    render(null, el);
    el.remove();
  }
  el = null;
};
var mount = (component, {
  props,
  children,
  element,
  appContext
} = {}) => {
  let el = element;
  let vNode;
  const onClose = () => {
    closeNotification(vNode, () => destroy(el));
    if (props == null ? void 0 : props.onClose) {
      props.onClose();
    }
  };
  vNode = createVNode3(component, { ...props, onClose }, children);
  if (appContext) {
    vNode.appContext = appContext;
  }
  if (el) {
    render(vNode, el);
  } else if (typeof document !== "undefined") {
    render(vNode, el = document.createElement("div"));
  }
  return { vNode, el };
};
var closeAllNotifications = (appContext) => {
  if (!getGlobal().vaToastInstances.length) {
    seed = 1;
    return;
  }
  getGlobal().vaToastInstances.forEach((instance) => {
    if (appContext && instance.appContext !== appContext) {
      return;
    }
    getNodeProps2(instance).onClose();
  });
};
var closeById = (id) => {
  const targetInstance = getGlobal().vaToastInstances.find((instance) => {
    var _a2;
    return ((_a2 = instance.el) == null ? void 0 : _a2.id) === id;
  });
  if (targetInstance) {
    const nodeProps = getNodeProps2(targetInstance);
    nodeProps.onClose();
  }
};
var getToastOptions = (options) => {
  if (typeof options === "string") {
    return {
      message: options
    };
  }
  return options;
};
var createToastInstance = (customProps, appContext) => {
  const { vNode, el } = mount(VaToast, { appContext, props: getToastOptions(customProps) });
  const nodeProps = getNodeProps2(vNode);
  if (el && vNode.el && nodeProps) {
    document.body.appendChild(el.childNodes[0]);
    vNode.el.id = "notification_" + seed;
    seed += 1;
    getGlobal().vaToastInstances.push(vNode);
    return vNode.el.id;
  }
  return null;
};

// node_modules/vuestic-ui/dist/es/src/components/va-toast/plugin/index.js
var createVaToastPlugin = (app) => ({
  /** Returns toast instance id */
  init(options) {
    return createToastInstance(options, app == null ? void 0 : app._context);
  },
  close(id) {
    closeById(id);
  },
  closeAll(allApps = false) {
    closeAllNotifications(allApps ? void 0 : app == null ? void 0 : app._context);
  }
});
var VaToastPlugin = defineVuesticPlugin(() => ({
  install(app) {
    defineGlobalProperty(app, "$vaToast", createVaToastPlugin(app));
  }
}));

// node_modules/vuestic-ui/dist/es/src/components/va-dropdown/plugin/index.js
var vaDropdownPlugin = {
  closeDropdown() {
    let vm = this;
    while (vm = vm.$parent) {
      const name = vm.$options.name;
      if (name === "VaDropdown") {
        vm.hide();
        break;
      }
    }
  }
};
var VaDropdownPlugin = defineVuesticPlugin(() => ({
  install(app) {
    defineGlobalProperty(app, "$closeDropdown", vaDropdownPlugin.closeDropdown);
    defineGlobalProperty(app, "$vaDropdown", vaDropdownPlugin);
  }
}));

// node_modules/vuestic-ui/dist/es/src/components/va-modal/VaModal.vue_vue_type_script_setup_true_lang.js
import { defineComponent as defineComponent11, h as h4, Transition as Transition2, shallowRef as shallowRef5, toRef as toRef3, computed as computed48, watchEffect as watchEffect5, watch as watch13, onMounted as onMounted11, onBeforeUnmount as onBeforeUnmount9, openBlock as openBlock11, createElementBlock as createElementBlock9, normalizeClass as normalizeClass5, mergeProps as mergeProps6, unref as unref14, renderSlot as renderSlot7, normalizeProps as normalizeProps5, guardReactiveProps as guardReactiveProps4, createCommentVNode as createCommentVNode6, createBlock as createBlock7, Teleport as Teleport2, createVNode as createVNode5, withCtx as withCtx7, normalizeStyle as normalizeStyle5, createElementVNode as createElementVNode6, withKeys as withKeys2, toDisplayString as toDisplayString4, createTextVNode as createTextVNode3, nextTick as nextTick2 } from "vue";

// node_modules/vuestic-ui/dist/es/src/components/va-button/VaButton.vue_vue_type_script_setup_true_lang.js
import { defineComponent as defineComponent10, computed as computed43, toRefs, shallowRef as shallowRef4, openBlock as openBlock10, createBlock as createBlock6, resolveDynamicComponent as resolveDynamicComponent2, unref as unref12, mergeProps as mergeProps5, withCtx as withCtx6, createElementVNode as createElementVNode5, normalizeClass as normalizeClass4, renderSlot as renderSlot6, normalizeProps as normalizeProps4, guardReactiveProps as guardReactiveProps3, createCommentVNode as createCommentVNode5, createVNode as createVNode4 } from "vue";

// node_modules/vuestic-ui/dist/es/src/components/va-button/hooks/useButtonBackground.js
import { getCurrentInstance as getCurrentInstance14, computed as computed34 } from "vue";
var useButtonBackground = (colorComputed, isPressed, isHovered) => {
  const instance = getCurrentInstance14();
  if (!instance) {
    throw new Error("`useButtonBackground` hook must be used only inside of setup function!");
  }
  const props = instance.props;
  const { getColor, getGradientBackground: getGradientBackground2 } = useColors();
  const backgroundColor = computed34(() => {
    if (props.plain) {
      return "transparent";
    }
    return props.gradient ? getGradientBackground2(colorComputed.value) : colorComputed.value;
  });
  const hoveredBgState = computed34(() => !props.plain && isHovered.value);
  const pressedBgState = computed34(() => !props.plain && isPressed.value);
  const backgroundColorOpacity = computed34(() => {
    if (pressedBgState.value && props.pressedBehavior === "opacity") {
      return props.pressedOpacity;
    }
    if (hoveredBgState.value && props.hoverBehavior === "opacity") {
      return Number(props.hoverOpacity);
    }
    return Number(props.backgroundOpacity);
  });
  const hoveredMaskState = computed34(() => hoveredBgState.value && props.hoverBehavior === "mask");
  const pressedMaskState = computed34(() => pressedBgState.value && props.pressedBehavior === "mask");
  const backgroundMaskOpacity = computed34(() => {
    if (pressedMaskState.value) {
      return props.pressedOpacity;
    }
    if (hoveredMaskState.value) {
      return Number(props.hoverOpacity);
    }
    return 0;
  });
  const backgroundMaskColor = computed34(() => {
    if (pressedMaskState.value) {
      return getColor(props.pressedMaskColor);
    }
    if (hoveredMaskState.value) {
      return getColor(props.hoverMaskColor);
    }
    return "transparent";
  });
  return {
    backgroundColor,
    backgroundColorOpacity,
    backgroundMaskOpacity,
    backgroundMaskColor
  };
};

// node_modules/vuestic-ui/dist/es/src/components/va-button/hooks/useButtonAttributes.js
import { computed as computed36 } from "vue";

// node_modules/vuestic-ui/dist/es/src/composables/useRouterLink.js
import { getCurrentInstance as getCurrentInstance15, computed as computed35 } from "vue";
var useRouterLinkProps = {
  tag: { type: String, default: "span" },
  to: { type: [String, Object], default: void 0 },
  replace: { type: Boolean, default: void 0 },
  append: { type: Boolean, default: void 0 },
  exact: { type: Boolean, default: void 0 },
  activeClass: { type: String, default: void 0 },
  exactActiveClass: { type: String, default: void 0 },
  href: { type: String, default: void 0 },
  target: { type: String, default: void 0 },
  disabled: { type: Boolean, default: false }
};
var useRouterLink = (props) => {
  const currentInstance = getCurrentInstance15();
  const globalProperties = computed35(() => currentInstance == null ? void 0 : currentInstance.appContext.config.globalProperties);
  const vueRouter = computed35(() => {
    var _a2;
    return (_a2 = globalProperties.value) == null ? void 0 : _a2.$router;
  });
  const vueRoute = computed35(() => {
    var _a2;
    return (_a2 = globalProperties.value) == null ? void 0 : _a2.$route;
  });
  const { getGlobalConfig } = useGlobalConfig();
  const tagComputed = computed35(() => {
    if (props.disabled) {
      return props.tag;
    }
    if (props.href && !props.to) {
      return "a";
    }
    const globalConfig = getGlobalConfig();
    if (globalConfig.routerComponent && props.to) {
      return globalConfig.routerComponent;
    }
    if (props.to && vueRouter.value !== void 0) {
      return "router-link";
    }
    if (props.to && vueRouter.value === void 0) {
      return "a";
    }
    return props.tag || "div";
  });
  const isLinkTag = computed35(() => {
    if (props.disabled) {
      return false;
    }
    return Boolean(props.href || props.to);
  });
  const linkAttributesComputed = computed35(() => {
    if (!isLinkTag.value) {
      return {};
    }
    return tagComputed.value === "a" ? {
      target: props.target,
      href: hrefComputed.value
    } : {
      target: props.target,
      to: props.to,
      replace: props.replace,
      append: props.append,
      activeClass: props.activeClass,
      exact: props.exact,
      exactActiveClass: props.exactActiveClass
    };
  });
  const isActiveRouterLink = computed35(() => {
    if (!vueRouter.value || !props.to) {
      return false;
    }
    const to = vueRouter.value.resolve(props.to).href;
    const currentHref = vueRouter.value.currentRoute.value.path;
    return to.replace("#", "") === currentHref.replace("#", "");
  });
  const hrefComputed = computed35(() => {
    var _a2;
    if (props.href) {
      return props.href;
    }
    if (vueRoute.value === void 0 && props.to) {
      return props.to;
    }
    return props.to ? (_a2 = vueRouter.value) == null ? void 0 : _a2.resolve(props.to, vueRoute.value).href : void 0;
  });
  return {
    isLinkTag,
    tagComputed,
    hrefComputed,
    isActiveRouterLink,
    linkAttributesComputed
  };
};

// node_modules/vuestic-ui/dist/es/src/components/va-button/hooks/useButtonAttributes.js
var useButtonAttributes = (props) => {
  const { linkAttributesComputed, isLinkTag } = useRouterLink(props);
  const typeComputed = computed36(() => isLinkTag.value ? void 0 : props.type);
  const buttonAttributesComputed = computed36(() => {
    const disabledAttributes = {
      "aria-disabled": !!props.disabled,
      disabled: !!props.disabled
    };
    if (isLinkTag.value) {
      return disabledAttributes;
    }
    return {
      type: typeComputed.value,
      tabindex: props.loading || props.disabled ? -1 : 0,
      ...disabledAttributes
    };
  });
  return computed36(() => ({ ...linkAttributesComputed.value, ...buttonAttributesComputed.value }));
};

// node_modules/vuestic-ui/dist/es/src/components/va-button/hooks/useButtonTextColor.js
import { getCurrentInstance as getCurrentInstance16, computed as computed37 } from "vue";
var getOpacity = (opacity) => {
  var _a2, _b, _c;
  if (isServer()) {
    return opacity;
  }
  if (opacity > 0) {
    const userAgent = (_a2 = window == null ? void 0 : window.navigator) == null ? void 0 : _a2.userAgent;
    const isSafari = userAgent && /^((?!chrome|android).)*safari/i.test((_b = window == null ? void 0 : window.navigator) == null ? void 0 : _b.userAgent);
    const isLatestSafari = userAgent && /(version.)15|16/i.test((_c = window == null ? void 0 : window.navigator) == null ? void 0 : _c.userAgent);
    if (isSafari && !isLatestSafari) {
      return opacity < 1 ? 1 - opacity : opacity;
    }
  }
  return opacity;
};
var useButtonTextColor = (textColorComputed, colorComputed, isPressed, isHovered) => {
  const instance = getCurrentInstance16();
  if (!instance) {
    throw new Error("`useButtonTextColor` hook must be used only inside of setup function!");
  }
  const props = instance.props;
  const { getColor, colorToRgba: colorToRgba2, getStateMaskGradientBackground: getStateMaskGradientBackground2 } = useColors();
  const plainColorStyles = computed37(() => ({
    background: "transparent",
    color: textColorComputed.value,
    "-webkit-background-clip": "text",
    "background-clip": "text",
    opacity: getPlainTextOpacity.value
  }));
  const getStateColor = (maskColor, stateOpacity, stateBehavior) => {
    const maskStateColor = getColor(maskColor);
    let stateStyles;
    if (stateBehavior === "opacity") {
      stateStyles = { color: colorToRgba2(textColorComputed.value, stateOpacity) };
    } else {
      stateStyles = {
        background: getStateMaskGradientBackground2(colorComputed.value, maskStateColor, stateOpacity),
        color: stateOpacity < 1 ? colorToRgba2(textColorComputed.value, getOpacity(stateOpacity)) : maskStateColor
      };
    }
    return { ...plainColorStyles.value, ...stateStyles };
  };
  const hoverTextColorComputed = computed37(() => {
    return getStateColor(props.hoverMaskColor, Number(props.hoverOpacity), props.hoverBehavior);
  });
  const pressedTextColorComputed = computed37(() => {
    return getStateColor(props.pressedMaskColor, props.pressedOpacity, props.pressedBehavior);
  });
  const getPlainTextOpacity = computed37(() => {
    if (props.disabled) {
      return void 0;
    }
    if (props.textOpacity === 1 || isHovered.value && !isPressed.value) {
      return 1;
    }
    return isPressed.value ? 0.9 : props.textOpacity;
  });
  return computed37(() => {
    const defaultColorStyles = {
      color: textColorComputed.value,
      background: "transparent"
    };
    props.plain && Object.assign(defaultColorStyles, plainColorStyles.value, { background: textColorComputed.value });
    if (!props.plain) {
      return defaultColorStyles;
    }
    if (isPressed.value) {
      return pressedTextColorComputed.value;
    }
    if (isHovered.value) {
      return hoverTextColorComputed.value;
    }
    return defaultColorStyles;
  });
};

// node_modules/vuestic-ui/dist/es/src/components/va-progress-circle/VaProgressCircle.vue_vue_type_script_setup_true_lang.js
import { defineComponent as defineComponent9, computed as computed38, openBlock as openBlock9, createElementBlock as createElementBlock8, mergeProps as mergeProps4, createElementVNode as createElementVNode4, normalizeStyle as normalizeStyle4, renderSlot as renderSlot5, createCommentVNode as createCommentVNode4 } from "vue";

// node_modules/vuestic-ui/dist/es/src/utils/clamp.js
var clamp = (value, min, max) => {
  return Math.min(Math.max(value, min), max);
};

// node_modules/vuestic-ui/dist/es/src/components/va-progress-circle/VaProgressCircle.vue_vue_type_script_setup_true_lang.js
import "D:/Desktop/forntend/Front_End_Web_Hotel_Nhom_2/my-nuxt-app/node_modules/vuestic-ui/dist/es/VaProgressCircle.css";
var _hoisted_16 = {
  class: "va-progress-circle__wrapper",
  viewBox: "0 0 40 40"
};
var _hoisted_22 = ["r", "stroke", "stroke-width", "stroke-dasharray", "stroke-dashoffset"];
var _sfc_main9 = defineComponent9({
  ...{
    name: "VaProgressCircle"
  },
  __name: "VaProgressCircle",
  props: {
    ...useSizeProps,
    ...useComponentPresetProp,
    modelValue: { type: [Number, String], default: 0 },
    indeterminate: { type: Boolean, default: false },
    thickness: { type: [Number, String], default: 0.06 },
    color: { type: String, default: "primary" },
    ariaLabel: useTranslationProp("$t:progressState")
  },
  setup(__props) {
    const props = __props;
    const { getColor } = useColors();
    const { sizeComputed } = useSize(props);
    const cappedThickness = computed38(() => clamp(Number(props.thickness), 0, 1) / 2 * 100);
    const radius = computed38(() => 20 - 20 * cappedThickness.value / 100);
    const dasharray = computed38(() => 2 * Math.PI * radius.value);
    const dashoffset = computed38(() => dasharray.value * (1 - clamp(Number(props.modelValue), 0, 100) / 100));
    const colorComputed = computed38(() => getColor(props.color, void 0, true));
    const { tp } = useTranslation();
    const infoStyle = computed38(() => ({ color: colorComputed.value }));
    const rootStyle = computed38(() => ({
      width: sizeComputed.value,
      height: sizeComputed.value
    }));
    const rootClass = computed38(() => ({
      "va-progress-circle--indeterminate": props.indeterminate
    }));
    const ariaAttributesComputed = computed38(() => ({
      role: "progressbar",
      "aria-label": tp(props.ariaLabel),
      "aria-valuenow": !props.indeterminate ? props.modelValue : void 0
    }));
    return (_ctx, _cache) => {
      return openBlock9(), createElementBlock8("div", mergeProps4({
        class: ["va-progress-circle", rootClass.value],
        style: rootStyle.value
      }, ariaAttributesComputed.value), [
        (openBlock9(), createElementBlock8("svg", _hoisted_16, [
          createElementVNode4("circle", {
            class: "va-progress-circle__overlay",
            cx: "50%",
            cy: "50%",
            r: radius.value,
            fill: "none",
            stroke: colorComputed.value,
            "stroke-width": cappedThickness.value + "%",
            "stroke-dasharray": dasharray.value,
            "stroke-dashoffset": dashoffset.value
          }, null, 8, _hoisted_22)
        ])),
        _ctx.$slots.default ? (openBlock9(), createElementBlock8("div", {
          key: 0,
          style: normalizeStyle4(infoStyle.value),
          class: "va-progress-circle__info"
        }, [
          renderSlot5(_ctx.$slots, "default")
        ], 4)) : createCommentVNode4("", true)
      ], 16);
    };
  }
});

// node_modules/vuestic-ui/dist/es/src/components/va-progress-circle/index.js
var VaProgressCircle = withConfigTransport$1(_sfc_main9);

// node_modules/vuestic-ui/dist/es/src/utils/pick.js
var pick = (o, keys) => {
  return Object.keys(o).filter((key) => keys.includes(key)).reduce((acc, key) => {
    acc[key] = o[key];
    return acc;
  }, {});
};

// node_modules/vuestic-ui/dist/es/src/composables/useHoverStyle.js
var useHoverStyleProps = {
  hoverBehavior: {
    type: String,
    default: "mask",
    validator: (value) => ["opacity", "mask"].includes(value)
  },
  hoverOpacity: { type: [Number, String], default: 0.15 },
  hoverMaskColor: { type: String, default: "textInverted" }
};

// node_modules/vuestic-ui/dist/es/src/composables/usePressedStyle.js
var usePressedStyleProps = {
  pressedBehavior: {
    type: String,
    default: "mask",
    validator: (value) => ["opacity", "mask"].includes(value)
  },
  pressedOpacity: { type: Number, default: 0.13 },
  pressedMaskColor: { type: String, default: "textPrimary" }
};

// node_modules/vuestic-ui/dist/es/src/composables/useLoading.js
var useLoadingProps = {
  loading: { type: Boolean, default: false }
};

// node_modules/vuestic-ui/dist/es/src/utils/focus.js
var isHTMLElement = (el) => {
  return el instanceof HTMLElement;
};
var focusElement = (el) => {
  if (!el || !isHTMLElement(el)) {
    return;
  }
  el.focus();
  el.dispatchEvent(new FocusEvent("focus", { bubbles: true }));
};
var blurElement = (el) => {
  if (!el || !isHTMLElement(el)) {
    return;
  }
  el.blur();
  el.dispatchEvent(new Event("blur", { bubbles: true }));
};
var focusFirstFocusableChild = (el) => {
  if (el.tabIndex !== -1) {
    focusElement(el);
    return;
  }
  const focusable = el.querySelector('button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])');
  if (focusable) {
    focusElement(focusable);
  }
};

// node_modules/vuestic-ui/dist/es/src/composables/useFocus.js
import { computed as computed39 } from "vue";

// node_modules/vuestic-ui/dist/es/src/composables/useActiveElement.js
import { shallowRef as shallowRef2, onMounted as onMounted9 } from "vue";

// node_modules/vuestic-ui/dist/es/src/composables/useCaptureEvent.js
import { onMounted as onMounted8, onBeforeUnmount as onBeforeUnmount6 } from "vue";
var useCaptureEvent = (event, cb, options = {}) => {
  onMounted8(() => window.addEventListener(event, cb, { capture: true, ...options }));
  onBeforeUnmount6(() => window.removeEventListener(event, cb, { capture: true, ...options }));
};

// node_modules/vuestic-ui/dist/es/src/composables/useActiveElement.js
var useActiveElement = () => {
  const activeEl = shallowRef2();
  const updateActiveElement = () => {
    activeEl.value = document.activeElement;
  };
  onMounted9(updateActiveElement);
  useCaptureEvent("focus", updateActiveElement);
  useCaptureEvent("blur", updateActiveElement);
  return activeEl;
};

// node_modules/vuestic-ui/dist/es/src/composables/useFocus.js
var useFocusEmits = ["focus", "blur"];
function useFocus(el, emit) {
  const activeElement = useActiveElement();
  const isFocused = computed39({
    get: () => {
      if (isNilValue(activeElement.value)) {
        return false;
      }
      if (isNilValue(el == null ? void 0 : el.value)) {
        return false;
      }
      return activeElement.value === (el == null ? void 0 : el.value);
    },
    set: (value) => {
      if (value) {
        focus();
      } else {
        blur();
      }
    }
  });
  const onFocus = (e) => {
    emit == null ? void 0 : emit("focus", e);
  };
  const onBlur = (e) => {
    emit == null ? void 0 : emit("blur", e);
  };
  const focus = () => {
    if (!(el == null ? void 0 : el.value)) {
      return;
    }
    focusElement(unwrapEl(el == null ? void 0 : el.value));
  };
  const blur = () => {
    if (!(el == null ? void 0 : el.value)) {
      return;
    }
    blurElement(unwrapEl(el == null ? void 0 : el.value));
  };
  useEvent("focus", onFocus, el);
  useEvent("blur", onBlur, el);
  return {
    isFocused,
    onFocus,
    onBlur,
    focus,
    blur
  };
}

// node_modules/vuestic-ui/dist/es/src/composables/useHover.js
import { ref as ref14, watch as watch10 } from "vue";

// node_modules/vuestic-ui/dist/es/src/composables/useHTMLElement.js
import { isRef as isRef2, computed as computed40, shallowRef as shallowRef3 } from "vue";
var useHTMLElement = (key) => {
  if (isRef2(key)) {
    return computed40({
      get() {
        return unwrapEl(key.value);
      },
      set(value) {
        key.value = value;
      }
    });
  }
  if (key) {
    const el2 = useTemplateRef(key);
    return computed40({
      get() {
        return unwrapEl(el2.value);
      },
      set(value) {
        el2.value = value;
      }
    });
  }
  const el = shallowRef3();
  return computed40({
    set(value) {
      el.value = unwrapEl(value);
    },
    get() {
      return el.value;
    }
  });
};

// node_modules/vuestic-ui/dist/es/src/composables/useHover.js
function useHover(el, disabled) {
  const isHovered = ref14(false);
  const onMouseEnter = () => {
    if (disabled == null ? void 0 : disabled.value) {
      return;
    }
    isHovered.value = true;
  };
  const onMouseLeave = () => {
    isHovered.value = false;
  };
  disabled && watch10(disabled, (v) => {
    if (v) {
      isHovered.value = false;
    }
  });
  const target = useHTMLElement(el);
  useEvent("mouseenter", onMouseEnter, target);
  useEvent("mouseleave", onMouseLeave, target);
  return { isHovered, onMouseEnter, onMouseLeave };
}

// node_modules/vuestic-ui/dist/es/src/composables/usePressed.js
import { ref as ref15 } from "vue";
function usePressed(el) {
  const isPressed = ref15(false);
  const onMouseDown = () => {
    isPressed.value = true;
  };
  const onMouseUp = () => {
    isPressed.value = false;
  };
  const target = useHTMLElement(el);
  useEvent(["mousedown", "touchstart", "dragstart"], onMouseDown, target);
  useEvent([
    "mouseup",
    "mouseleave",
    "touchend",
    "touchcancel",
    "drop",
    "dragend"
  ], onMouseUp, true);
  return { isPressed, onMouseDown, onMouseUp };
}

// node_modules/vuestic-ui/dist/es/src/composables/useSlotPassed.js
import { getCurrentInstance as getCurrentInstance17, computed as computed41, isVNode as isVNode2 } from "vue";
var checkSlotChildrenDeep = (v, initial = true) => {
  var _a2;
  if (isVNode2(v)) {
    return true;
  }
  if (!v || initial && (!isFunction(v) || !((_a2 = v()) == null ? void 0 : _a2.length))) {
    return false;
  }
  const slotData = initial ? v() : v;
  if (Array.isArray(slotData)) {
    return slotData.some((el) => {
      return Array.isArray(el.children) ? checkSlotChildrenDeep(el.children, false) : el.children || el.props;
    });
  }
  return !!slotData.children;
};
var useSlotPassed = (name = "default") => {
  const { slots } = getCurrentInstance17();
  return computed41(() => checkSlotChildrenDeep(slots[name]));
};

// node_modules/vuestic-ui/dist/es/src/composables/useBem.js
import { computed as computed42, unref as unref11 } from "vue";
var useBem = (prefix2, modifiers) => {
  if (isDev && !prefix2) {
    console.warn('You must pass the @param "prefix" to the useBem hook!');
  }
  const modifiersList = computed42(() => typeof modifiers === "function" ? modifiers() : unref11(modifiers));
  const computedBemClassesObject = computed42(() => {
    return Object.entries(unref11(modifiersList)).reduce((classesObj, [modifierName, value]) => {
      if (value) {
        classesObj[`${prefix2}--${camelCaseToKebabCase(modifierName)}`] = true;
      }
      return classesObj;
    }, {});
  });
  const computedBemClassesArray = computed42(() => Object.keys(computedBemClassesObject.value));
  const computedBemClassesString = computed42(() => computedBemClassesArray.value.join(" "));
  return new Proxy({}, {
    ownKeys() {
      return Reflect.ownKeys(computedBemClassesObject.value);
    },
    getOwnPropertyDescriptor(_, key) {
      return Reflect.getOwnPropertyDescriptor(computedBemClassesObject.value, key);
    },
    get(_, key, receiver) {
      switch (key) {
        case "asArray":
          return computedBemClassesArray;
        case "asString":
          return computedBemClassesString;
        case "asObject":
          return computedBemClassesObject;
        default:
          return Reflect.get(computedBemClassesObject.value, key, receiver);
      }
    }
  });
};

// node_modules/vuestic-ui/dist/es/src/components/va-button/VaButton.vue_vue_type_script_setup_true_lang.js
import "D:/Desktop/forntend/Front_End_Web_Hotel_Nhom_2/my-nuxt-app/node_modules/vuestic-ui/dist/es/VaButton.css";
var _sfc_main10 = defineComponent10({
  ...{
    name: "VaButton"
  },
  __name: "VaButton",
  props: {
    ...useComponentPresetProp,
    ...useSizeProps,
    ...useHoverStyleProps,
    ...usePressedStyleProps,
    ...useLoadingProps,
    ...useRouterLinkProps,
    tag: { type: String, default: "button" },
    type: { type: String, default: "button" },
    block: { type: Boolean, default: false },
    disabled: { type: Boolean, default: false },
    color: { type: String, default: "primary" },
    textColor: { type: String, default: "" },
    textOpacity: { type: [Number, String], default: 1 },
    backgroundOpacity: { type: [Number, String], default: 1 },
    borderColor: { type: String, default: "" },
    // only for filled bg state
    gradient: { type: Boolean, default: false },
    plain: { type: Boolean, default: false },
    round: { type: Boolean, default: false },
    size: {
      type: String,
      default: "medium",
      validator: (v) => ["small", "medium", "large"].includes(v)
    },
    icon: { type: String, default: "" },
    iconRight: { type: String, default: "" },
    iconColor: { type: String, default: "" }
  },
  setup(__props, { expose: __expose }) {
    const props = __props;
    const { getColor } = useColors();
    const colorComputed = computed43(() => getColor(props.color));
    const { sizeComputed } = useSize(props);
    const iconSizeComputed = computed43(() => {
      const size2 = /([0-9]*)(px)/.exec(sizeComputed.value);
      return size2 ? `${+size2[1] / 2}${size2[2]}` : sizeComputed.value;
    });
    const { tagComputed } = useRouterLink(props);
    const attributesComputed = useButtonAttributes(props);
    const { disabled } = toRefs(props);
    const button = shallowRef4();
    const { focus, blur } = useFocus(button);
    const { isHovered } = useHover(button, disabled);
    const { isPressed } = usePressed(button);
    const iconColorComputed = computed43(() => props.iconColor ? getColor(props.iconColor) : textColorComputed.value);
    const iconAttributesComputed = computed43(() => ({
      color: iconColorComputed.value,
      size: props.size
    }));
    const wrapperClassComputed = computed43(() => ({ "va-button__content--loading": props.loading }));
    const isSlotContentPassed = useSlotPassed();
    const isOneIcon = computed43(() => !!(props.iconRight && !props.icon || !props.iconRight && props.icon));
    const isOnlyIcon = computed43(() => !isSlotContentPassed.value && isOneIcon.value);
    const textOpacityComputed = useNumericProp("textOpacity");
    const backgroundOpacityComputed = useNumericProp("backgroundOpacity");
    const computedClass = useBem("va-button", () => ({
      ...pick(props, ["disabled", "block", "loading", "round", "plain"]),
      small: props.size === "small",
      normal: !props.size || props.size === "medium",
      large: props.size === "large",
      opacity: textOpacityComputed.value < 1,
      bordered: !!props.borderColor,
      iconOnly: isOnlyIcon.value,
      leftIcon: !isOnlyIcon.value && !!props.icon && !props.iconRight,
      rightIcon: !isOnlyIcon.value && !props.icon && !!props.iconRight
    }));
    const isTransparentBg = computed43(() => props.plain || backgroundOpacityComputed.value < 0.5);
    const { textColorComputed } = useTextColor(colorComputed, isTransparentBg);
    const {
      backgroundColor,
      backgroundColorOpacity,
      backgroundMaskOpacity,
      backgroundMaskColor
    } = useButtonBackground(colorComputed, isPressed, isHovered);
    const contentColorComputed = useButtonTextColor(textColorComputed, colorComputed, isPressed, isHovered);
    const computedStyle = computed43(() => ({
      borderColor: props.borderColor ? getColor(props.borderColor) : "transparent",
      ...contentColorComputed.value
    }));
    __expose({
      focus,
      blur
    });
    return (_ctx, _cache) => {
      return openBlock10(), createBlock6(resolveDynamicComponent2(unref12(tagComputed)), mergeProps5({
        ref_key: "button",
        ref: button,
        class: ["va-button", unref12(computedClass)],
        style: [computedStyle.value, `--va-background-color: ${String(unref12(backgroundColor))};--va-background-color-opacity: ${String(unref12(backgroundColorOpacity))};--va-background-mask-color: ${String(unref12(backgroundMaskColor))};--va-background-mask-opacity: ${String(unref12(backgroundMaskOpacity))}`]
      }, unref12(attributesComputed)), {
        default: withCtx6(() => [
          createElementVNode5("span", {
            class: normalizeClass4(["va-button__content", wrapperClassComputed.value])
          }, [
            renderSlot6(_ctx.$slots, "prepend", normalizeProps4(guardReactiveProps3({ icon: __props.icon, iconAttributes: iconAttributesComputed.value })), () => [
              __props.icon ? (openBlock10(), createBlock6(unref12(VaIcon), mergeProps5({
                key: 0,
                class: "va-button__left-icon",
                name: __props.icon
              }, iconAttributesComputed.value), null, 16, ["name"])) : createCommentVNode5("", true)
            ]),
            renderSlot6(_ctx.$slots, "default"),
            renderSlot6(_ctx.$slots, "append", normalizeProps4(guardReactiveProps3({ icon: __props.iconRight, iconAttributes: iconAttributesComputed.value })), () => [
              __props.iconRight ? (openBlock10(), createBlock6(unref12(VaIcon), mergeProps5({
                key: 0,
                class: "va-button__right-icon",
                name: __props.iconRight
              }, iconAttributesComputed.value), null, 16, ["name"])) : createCommentVNode5("", true)
            ])
          ], 2),
          _ctx.loading ? renderSlot6(_ctx.$slots, "loading", normalizeProps4(mergeProps5({ key: 0 }, {
            size: iconSizeComputed.value,
            color: unref12(textColorComputed)
          })), () => [
            createVNode4(unref12(VaProgressCircle), {
              class: "va-button__loader",
              size: iconSizeComputed.value,
              color: unref12(textColorComputed),
              thickness: 0.15,
              indeterminate: ""
            }, null, 8, ["size", "color"])
          ]) : createCommentVNode5("", true)
        ]),
        _: 3
      }, 16, ["class", "style"]);
    };
  }
});

// node_modules/vuestic-ui/dist/es/src/components/va-button/index.js
var VaButton = withConfigTransport$1(_sfc_main10);

// node_modules/vuestic-ui/dist/es/src/components/va-modal/hooks/useBlur.js
import { watchEffect as watchEffect4, onBeforeUnmount as onBeforeUnmount7 } from "vue";

// node_modules/vuestic-ui/dist/es/src/composables/useCurrentComponentId.js
import { getCurrentInstance as getCurrentInstance18 } from "vue";
var useCurrentComponentId = () => {
  const instance = getCurrentInstance18();
  if (!instance.appContext.app) {
    return String(instance.uid);
  }
  return `${instance.appContext.app._uid}_${instance.uid}`;
};

// node_modules/vuestic-ui/dist/es/src/components/va-modal/hooks/useBlur.js
var openedModals = [];
var useBlur = (shouldBlur, isModalShown) => {
  const id = useCurrentComponentId();
  const document2 = useDocument();
  const blur = () => {
    var _a2;
    if (openedModals.includes(id)) {
      return;
    }
    openedModals.push(id);
    (_a2 = document2.value) == null ? void 0 : _a2.body.classList.add("va-modal-overlay-background--blurred");
  };
  const removeBlur = () => {
    var _a2;
    const modalIndex = openedModals.indexOf(id);
    if (modalIndex === -1) {
      return;
    }
    openedModals.splice(modalIndex, 1);
    if (openedModals.length === 0) {
      (_a2 = document2.value) == null ? void 0 : _a2.body.classList.remove("va-modal-overlay-background--blurred");
    }
  };
  watchEffect4(() => {
    if (!shouldBlur.value) {
      return;
    }
    if (isModalShown.value) {
      blur();
    } else {
      removeBlur();
    }
  });
  onBeforeUnmount7(removeBlur);
};

// node_modules/vuestic-ui/dist/es/src/composables/useZIndex.js
import { shallowReactive, computed as computed44, onMounted as onMounted10, onBeforeUnmount as onBeforeUnmount8, watch as watch11 } from "vue";
var createInstance = () => {
  return generateUniqueId();
};
var zIndexStack = shallowReactive([]);
var useZIndex = (isVisible) => {
  const instance = createInstance();
  const register = () => {
    if (zIndexStack.includes(instance)) {
      return;
    }
    zIndexStack.push(instance);
  };
  const unregister = () => {
    const index = zIndexStack.findIndex((item) => item === instance);
    if (index !== -1) {
      zIndexStack.splice(index, 1);
    }
  };
  const zIndex = computed44(() => {
    const index = zIndexStack.findIndex((item) => item === instance);
    if (index === -1) {
      return -1;
    }
    return index + 1;
  });
  const isTop = computed44(() => zIndex.value === zIndexStack.length - 1);
  const isLowest = computed44(() => zIndex.value === 0);
  onMounted10(() => {
    if (isVisible.value) {
      register();
    }
  });
  onBeforeUnmount8(() => {
    unregister();
  });
  watch11(isVisible, (value) => {
    if (value) {
      register();
    } else {
      unregister();
    }
  });
  return {
    zIndex,
    isTop,
    isLowest,
    register,
    unregister
  };
};

// node_modules/vuestic-ui/dist/es/src/composables/useStateful.js
import { ref as ref16, watch as watch12, computed as computed46 } from "vue";

// node_modules/vuestic-ui/dist/es/src/composables/useUserProvidedProp.js
import { getCurrentInstance as getCurrentInstance19, computed as computed45 } from "vue";
var NOT_PROVIDED = Symbol("NOT_PROVIDED");
var useUserProvidedProp = (propName, props) => {
  const vm = getCurrentInstance19();
  return computed45(() => {
    if (!(vm == null ? void 0 : vm.vnode.props)) {
      return NOT_PROVIDED;
    }
    const originalProp = props[propName];
    return propName in vm.vnode.props ? originalProp : NOT_PROVIDED;
  });
};

// node_modules/vuestic-ui/dist/es/src/composables/useStateful.js
var useStatefulProps = {
  stateful: { type: Boolean, default: false },
  modelValue: { type: void 0 }
};
var createStatefulProps = (statefulDefault = false) => {
  return {
    stateful: { type: Boolean, default: statefulDefault }
  };
};
var useStatefulEmits = ["update:modelValue"];
var useStateful = (props, emit, key = "modelValue", options = {}) => {
  const { eventName, defaultValue } = options;
  const event = eventName || `update:${key.toString()}`;
  const passedProp = useUserProvidedProp(key, props);
  const defaultValuePassed = "defaultValue" in options;
  const valueState = ref16(
    passedProp.value === NOT_PROVIDED ? defaultValuePassed ? defaultValue : props[key] : passedProp.value
  );
  let unwatchModelValue;
  const watchModelValue = () => {
    unwatchModelValue = watch12(() => props[key], (modelValue) => {
      valueState.value = modelValue;
    });
  };
  watch12(() => props.stateful, (stateful) => {
    stateful ? watchModelValue() : unwatchModelValue == null ? void 0 : unwatchModelValue();
  }, { immediate: true });
  const valueComputed = computed46({
    get: () => {
      if (props.stateful) {
        return valueState.value;
      }
      return props[key];
    },
    set: (value) => {
      if (props.stateful) {
        valueState.value = value;
      }
      emit(event, value);
    }
  });
  Object.defineProperty(valueComputed, "stateful", {
    get: () => props.stateful
  });
  Object.defineProperty(valueComputed, "userProvided", {
    get: () => passedProp.value !== NOT_PROVIDED
  });
  return { valueComputed };
};

// node_modules/vuestic-ui/dist/es/src/composables/useTrapFocus.js
var FOCUSABLE_ELEMENTS_SELECTOR = ":where(a, button, input, textarea, select):not([disabled]), *[tabindex]";
var useTrapFocus = () => {
  const document2 = useDocument();
  const window2 = useWindow();
  const trapInEl = useAppGlobal("trapInEl", null);
  let focusableElements = [];
  let firstFocusableElement = null;
  let lastFocusableElement = null;
  const isFocusIn = (evt) => {
    var _a2;
    return ((_a2 = trapInEl.value) == null ? void 0 : _a2.contains(evt.target)) || false;
  };
  const focusFirstElement = () => {
    firstFocusableElement == null ? void 0 : firstFocusableElement.focus();
  };
  const focusLastElement = () => {
    lastFocusableElement == null ? void 0 : lastFocusableElement.focus();
  };
  const onKeydown = (evt) => {
    var _a2, _b;
    const isTabPressed = evt.code === "Tab";
    const isShiftPressed = evt.shiftKey;
    if (!isTabPressed) {
      return;
    }
    if (!isFocusIn(evt)) {
      evt.preventDefault();
      isShiftPressed ? focusLastElement() : focusFirstElement();
      return;
    }
    if (((_a2 = document2.value) == null ? void 0 : _a2.activeElement) === lastFocusableElement && !isShiftPressed) {
      evt.preventDefault();
      focusFirstElement();
      return;
    }
    if (((_b = document2.value) == null ? void 0 : _b.activeElement) === firstFocusableElement && isShiftPressed) {
      evt.preventDefault();
      focusLastElement();
    }
  };
  const trapFocusIn = (el) => {
    trapInEl.value = el;
    freeFocus();
    trapFocus();
  };
  const trapFocus = () => {
    var _a2;
    if (!trapInEl.value) {
      return;
    }
    focusableElements = Array.from(trapInEl.value.querySelectorAll(FOCUSABLE_ELEMENTS_SELECTOR));
    firstFocusableElement = focusableElements[0];
    lastFocusableElement = focusableElements[focusableElements.length - 1];
    (_a2 = window2.value) == null ? void 0 : _a2.addEventListener("keydown", onKeydown);
  };
  const freeFocus = () => {
    var _a2;
    focusableElements = [];
    firstFocusableElement = null;
    lastFocusableElement = null;
    (_a2 = window2.value) == null ? void 0 : _a2.removeEventListener("keydown", onKeydown);
  };
  return {
    trapFocus,
    freeFocus,
    trapFocusIn
  };
};

// node_modules/vuestic-ui/dist/es/src/composables/useModalLevel.js
import { shallowReactive as shallowReactive2, computed as computed47 } from "vue";
var modalsStack = shallowReactive2([]);
var useModalLevel = () => {
  const modalId = useComponentUuid();
  const modalLevel = computed47(
    () => modalsStack.findIndex(({ id }) => id === String(modalId))
  );
  const registerModal = () => {
    if (modalLevel.value !== -1) {
      return;
    }
    modalsStack.push({
      id: String(modalId)
    });
  };
  const unregisterModal = () => {
    if (modalLevel.value === -1) {
      return;
    }
    modalsStack.splice(modalLevel.value, 1);
  };
  const isTopLevelModal = computed47(
    () => modalLevel.value !== -1 && modalLevel.value === modalsStack.length - 1
  );
  const isLowestLevelModal = computed47(
    () => modalLevel.value === 0
  );
  const isMoreThenOneModalOpen = computed47(() => modalsStack.length > 1);
  return {
    modalId,
    modalLevel,
    registerModal,
    unregisterModal,
    isTopLevelModal,
    isLowestLevelModal,
    isMoreThenOneModalOpen
  };
};

// node_modules/vuestic-ui/dist/es/src/composables/useTeleported.js
import { getCurrentInstance as getCurrentInstance20 } from "vue";
var TELEPORT_FROM_ATTR = "data-va-teleported-from";
var TELEPORT_ATTR = "data-va-teleported";
var findTeleportedFrom = (el) => {
  if (!el) {
    return null;
  }
  const teleportId = el.getAttribute(TELEPORT_ATTR);
  if (teleportId === null) {
    return findTeleportedFrom(el.parentElement);
  }
  return document.querySelector(`[${TELEPORT_FROM_ATTR}="${teleportId}"]`);
};
var useTeleported = () => {
  var _a2, _b;
  const componentId = useCurrentComponentId();
  const currentInstance = getCurrentInstance20();
  const scopedDataV = currentInstance == null ? void 0 : currentInstance.vnode.scopeId;
  return {
    teleportFromAttrs: {
      [TELEPORT_FROM_ATTR]: componentId
    },
    teleportedAttrs: {
      [TELEPORT_ATTR]: componentId,
      ...scopedDataV ? { [scopedDataV]: "" } : void 0,
      ...(_b = (_a2 = currentInstance == null ? void 0 : currentInstance.appContext.config) == null ? void 0 : _a2.globalProperties) == null ? void 0 : _b.$vaColorConfig.getAppStylesRootAttribute()
    },
    findTeleportedFrom
  };
};

// node_modules/vuestic-ui/dist/es/src/composables/useClickOutside.js
import { unref as unref13 } from "vue";
var checkIfElementChild = (parent, child) => {
  if (!child) {
    return false;
  }
  if (child.parentElement === parent) {
    return true;
  }
  return parent.contains(child);
};
var safeArray = (a) => Array.isArray(a) ? a : [a];
var useClickOutside = (elements, cb) => {
  useCaptureEvent("mousedown", (event) => {
    const clickTarget = event.target;
    if (event.target.shadowRoot) {
      return;
    }
    const teleportParent = findTeleportedFrom(clickTarget);
    const isClickInside = safeArray(elements).some((element) => {
      const el = unwrapEl(unref13(element));
      if (!el) {
        return false;
      }
      if (!teleportParent) {
        return checkIfElementChild(el, clickTarget);
      }
      return checkIfElementChild(el, clickTarget) || checkIfElementChild(el, teleportParent);
    });
    if (!isClickInside) {
      cb(clickTarget);
    }
  });
};

// node_modules/vuestic-ui/dist/es/src/components/va-modal/VaModal.vue_vue_type_script_setup_true_lang.js
import "D:/Desktop/forntend/Front_End_Web_Hotel_Nhom_2/my-nuxt-app/node_modules/vuestic-ui/dist/es/VaModal.css";
var _hoisted_17 = ["aria-labelledby"];
var _hoisted_23 = {
  key: 2,
  class: "va-modal__inner"
};
var _hoisted_32 = { class: "va-modal__header" };
var _hoisted_42 = {
  key: 0,
  class: "va-modal__message"
};
var _hoisted_52 = {
  key: 1,
  class: "va-modal__message"
};
var _hoisted_62 = {
  key: 2,
  class: "va-modal__footer"
};
var _hoisted_72 = {
  key: 3,
  class: "va-modal__footer"
};
var WithTransition = defineComponent11({
  name: "ModalElement",
  inheritAttrs: false,
  props: {
    ...useComponentPresetProp,
    isTransition: { type: Boolean, default: true }
  },
  setup: (props, { slots, attrs }) => () => {
    var _a2;
    return props.isTransition ? h4(Transition2, { ...attrs }, slots) : (_a2 = slots.default) == null ? void 0 : _a2.call(slots, attrs);
  }
});
var _sfc_main11 = defineComponent11({
  ...{
    name: "VaModal",
    inheritAttrs: false
  },
  __name: "VaModal",
  props: {
    ...defineChildProps({
      cancelButton: VaButton,
      okButton: VaButton,
      closeButton: VaIcon
    }),
    ...useStatefulProps,
    modelValue: { type: Boolean, default: false },
    attachElement: { type: String, default: "body" },
    allowBodyScroll: { type: Boolean, default: false },
    disableAttachment: { type: Boolean, default: false },
    title: { type: String, default: "" },
    message: { type: String, default: "" },
    okText: useTranslationProp("$t:ok"),
    cancelText: useTranslationProp("$t:cancel"),
    hideDefaultActions: { type: Boolean, default: false },
    fullscreen: { type: Boolean, default: false },
    closeButton: { type: Boolean, default: false },
    mobileFullscreen: { type: Boolean, default: true },
    noDismiss: { type: Boolean, default: false },
    noOutsideDismiss: { type: Boolean, default: false },
    noEscDismiss: { type: Boolean, default: false },
    maxWidth: { type: String, default: "" },
    maxHeight: { type: String, default: "" },
    anchorClass: { type: String },
    size: {
      type: String,
      default: "medium"
    },
    sizesConfig: {
      type: Object,
      default: () => ({
        defaultSize: "medium",
        sizes: {
          small: 576,
          medium: 768,
          large: 992,
          auto: "max-content"
        }
      })
    },
    fixedLayout: { type: Boolean, default: false },
    withoutTransitions: { type: Boolean, default: false },
    overlay: { type: Boolean, default: true },
    overlayOpacity: { type: [Number, String], default: 0.6 },
    showNestedOverlay: { type: Boolean, default: false },
    blur: { type: Boolean, default: false },
    zIndex: { type: [Number, String], default: void 0 },
    backgroundColor: { type: String, default: "background-secondary" },
    noPadding: { type: Boolean, default: false },
    beforeClose: { type: Function },
    beforeOk: { type: Function },
    beforeCancel: { type: Function },
    ariaCloseLabel: useTranslationProp("$t:close")
  },
  emits: [
    ...useStatefulEmits,
    "cancel",
    "ok",
    "before-open",
    "open",
    "before-close",
    "close",
    "click-outside"
  ],
  setup(__props, { expose: __expose, emit: __emit }) {
    const props = __props;
    useChildComponents(props);
    const emit = __emit;
    const rootElement = shallowRef5();
    const modalDialog = shallowRef5();
    const { trapFocusIn, freeFocus } = useTrapFocus();
    const {
      registerModal,
      unregisterModal,
      isTopLevelModal,
      isLowestLevelModal
    } = useModalLevel();
    const { getColor } = useColors();
    const { textColorComputed } = useTextColor(toRef3(props, "backgroundColor"));
    const { valueComputed } = useStateful(props, emit);
    const computedClass = computed48(() => ({
      "va-modal--fullscreen": props.fullscreen,
      "va-modal--mobile-fullscreen": props.mobileFullscreen,
      "va-modal--fixed-layout": props.fixedLayout,
      "va-modal--no-padding": props.noPadding
    }));
    const {
      zIndex: zIndexInherited
    } = useZIndex(valueComputed);
    const zIndexComputed = computed48(() => {
      if (props.zIndex) {
        return Number(props.zIndex);
      }
      return zIndexInherited.value;
    });
    const sizeComputed = useSizeRef(props);
    const computedDialogStyle = computed48(() => ({
      maxWidth: props.maxWidth || sizeComputed.value,
      maxHeight: props.maxHeight,
      color: textColorComputed.value,
      background: getColor(props.backgroundColor)
    }));
    const computedOverlayClass = computed48(() => ({
      "va-modal__overlay--lowest": isLowestLevelModal.value,
      "va-modal__overlay--top": isTopLevelModal.value
    }));
    const getOverlayOpacity = () => {
      if (props.showNestedOverlay && !isLowestLevelModal.value) {
        return "var(--va-modal-overlay-nested-opacity)";
      }
      return "var(--va-modal-overlay-opacity)";
    };
    const computedOverlayStyles = computed48(() => {
      if (!props.overlay) {
        return;
      }
      if (isTopLevelModal.value || props.showNestedOverlay) {
        return {
          "background-color": "var(--va-modal-overlay-color)",
          opacity: getOverlayOpacity()
        };
      }
      return "";
    });
    const show = () => {
      valueComputed.value = true;
    };
    const hide2 = (cb) => {
      const _hide = () => {
        valueComputed.value = false;
        cb == null ? void 0 : cb();
      };
      props.beforeClose ? props.beforeClose(_hide) : _hide();
    };
    const toggle = () => {
      valueComputed.value = !valueComputed.value;
    };
    const cancel = () => {
      const _hide = () => {
        hide2(() => emit("cancel"));
      };
      props.beforeCancel ? props.beforeCancel(_hide) : _hide();
    };
    const ok = () => {
      const _hide = () => {
        hide2(() => emit("ok"));
      };
      props.beforeOk ? props.beforeOk(_hide) : _hide();
    };
    const trapFocusInModal = () => {
      nextTick2(() => {
        if (modalDialog.value) {
          trapFocusIn(modalDialog.value);
        }
      });
    };
    const onBeforeEnterTransition = (el) => emit("before-open", el);
    const onAfterEnterTransition = (el) => emit("open", el);
    const onBeforeLeaveTransition = (el) => emit("before-close", el);
    const onAfterLeaveTransition = (el) => emit("close", el);
    const listenKeyUp = (e) => {
      const hideModal = () => {
        if (e.code === "Escape" && !props.noEscDismiss && !props.noDismiss && isTopLevelModal.value) {
          cancel();
        }
      };
      setTimeout(hideModal);
    };
    useClickOutside([modalDialog], () => {
      if (!valueComputed.value || props.noOutsideDismiss || props.noDismiss || !isTopLevelModal.value) {
        return;
      }
      emit("click-outside");
      cancel();
    });
    const window2 = useWindow();
    watchEffect5(() => {
      var _a2, _b;
      if (valueComputed.value) {
        (_a2 = window2.value) == null ? void 0 : _a2.addEventListener("keyup", listenKeyUp);
      } else {
        (_b = window2.value) == null ? void 0 : _b.removeEventListener("keyup", listenKeyUp);
      }
    });
    useBlur(toRef3(props, "blur"), valueComputed);
    const documentRef = useDocument();
    const setBodyOverflow = (overflow) => {
      if (!documentRef.value || props.allowBodyScroll) {
        return;
      }
      if (overflow === "hidden") {
        documentRef.value.body.classList.add("va-modal-open");
      } else {
        documentRef.value.body.classList.remove("va-modal-open");
      }
    };
    const onShow = () => {
      registerModal();
      setBodyOverflow("hidden");
    };
    const onHide = () => {
      if (isLowestLevelModal.value) {
        freeFocus();
        setBodyOverflow("");
      }
      unregisterModal();
    };
    watch13(valueComputed, (newValue) => {
      if (newValue) {
        onShow();
      } else {
        onHide();
      }
    });
    onMounted11(() => {
      if (valueComputed.value) {
        onShow();
      }
      if (isTopLevelModal.value) {
        trapFocusInModal();
      }
    });
    onBeforeUnmount9(() => {
      onHide();
    });
    watch13(isTopLevelModal, (newIsTopLevelModal) => {
      if (newIsTopLevelModal) {
        trapFocusInModal();
      }
    }, { immediate: true });
    __expose({
      show,
      hide: hide2,
      toggle,
      cancel,
      ok,
      onBeforeEnterTransition,
      onAfterEnterTransition,
      onBeforeLeaveTransition,
      onAfterLeaveTransition,
      listenKeyUp
    });
    const { tp } = useTranslation();
    const {
      teleportFromAttrs,
      teleportedAttrs
    } = useTeleported();
    const slotBind = { show, hide: hide2, toggle, cancel, ok };
    return (_ctx, _cache) => {
      return openBlock11(), createElementBlock9("div", {
        ref_key: "rootElement",
        ref: rootElement,
        class: normalizeClass5(["va-modal-entry", _ctx.$props.anchorClass])
      }, [
        _ctx.$slots.anchor ? (openBlock11(), createElementBlock9("div", mergeProps6({
          key: 0,
          class: "va-modal__anchor"
        }, unref14(teleportFromAttrs)), [
          renderSlot7(_ctx.$slots, "anchor", normalizeProps5(guardReactiveProps4(slotBind)))
        ], 16)) : createCommentVNode6("", true),
        (openBlock11(), createBlock7(Teleport2, {
          to: __props.attachElement,
          disabled: _ctx.$props.disableAttachment
        }, [
          createVNode5(unref14(WithTransition), mergeProps6({
            name: "va-modal",
            isTransition: !_ctx.$props.withoutTransitions,
            duration: 300,
            style: { zIndex: zIndexComputed.value },
            appear: ""
          }, { ..._ctx.$attrs, ...unref14(teleportedAttrs) }, {
            onBeforeEnter: onBeforeEnterTransition,
            onAfterEnter: onAfterEnterTransition,
            onBeforeLeave: onBeforeLeaveTransition,
            onAfterLeave: onAfterLeaveTransition
          }), {
            default: withCtx7(() => [
              unref14(valueComputed) ? (openBlock11(), createElementBlock9("div", {
                key: 0,
                "aria-labelledby": __props.title,
                class: normalizeClass5([computedClass.value, "va-modal"]),
                role: "dialog",
                "aria-modal": "true"
              }, [
                _ctx.$props.overlay ? (openBlock11(), createElementBlock9("div", {
                  key: 0,
                  class: normalizeClass5(["va-modal__overlay", computedOverlayClass.value]),
                  style: normalizeStyle5(computedOverlayStyles.value)
                }, null, 6)) : createCommentVNode6("", true),
                createElementVNode6("div", {
                  ref_key: "modalDialog",
                  ref: modalDialog,
                  class: "va-modal__dialog",
                  style: normalizeStyle5([computedDialogStyle.value])
                }, [
                  _ctx.$props.fullscreen || _ctx.$props.closeButton ? (openBlock11(), createBlock7(unref14(VaIcon), {
                    key: 0,
                    "va-child": "closeButton",
                    class: normalizeClass5([{ "va-modal__close--fullscreen": _ctx.$props.fullscreen }, "va-modal__close"]),
                    "aria-label": unref14(tp)(_ctx.$props.ariaCloseLabel),
                    role: "button",
                    tabindex: "0",
                    name: "va-close",
                    onClick: cancel,
                    onKeydown: [
                      withKeys2(cancel, ["space"]),
                      withKeys2(cancel, ["enter"])
                    ]
                  }, null, 8, ["class", "aria-label"])) : createCommentVNode6("", true),
                  _ctx.$slots.content ? renderSlot7(_ctx.$slots, "content", normalizeProps5(mergeProps6({ key: 1 }, slotBind))) : (openBlock11(), createElementBlock9("div", _hoisted_23, [
                    createElementVNode6("div", _hoisted_32, [
                      renderSlot7(_ctx.$slots, "header", normalizeProps5(guardReactiveProps4(slotBind)), () => [
                        __props.title ? (openBlock11(), createElementBlock9("div", {
                          key: 0,
                          class: "va-modal__title",
                          style: normalizeStyle5({ color: unref14(getColor)("primary") })
                        }, toDisplayString4(_ctx.$props.title), 5)) : createCommentVNode6("", true)
                      ])
                    ]),
                    _ctx.$props.message ? (openBlock11(), createElementBlock9("div", _hoisted_42, toDisplayString4(_ctx.$props.message), 1)) : createCommentVNode6("", true),
                    _ctx.$slots.default ? (openBlock11(), createElementBlock9("div", _hoisted_52, [
                      renderSlot7(_ctx.$slots, "default", normalizeProps5(guardReactiveProps4(slotBind)))
                    ])) : createCommentVNode6("", true),
                    (_ctx.$props.cancelText || _ctx.$props.okText) && !_ctx.$props.hideDefaultActions ? (openBlock11(), createElementBlock9("div", _hoisted_62, [
                      _ctx.$props.cancelText ? (openBlock11(), createBlock7(unref14(VaButton), {
                        key: 0,
                        "va-child": "cancelButton",
                        preset: "secondary",
                        color: "secondary",
                        class: "va-modal__default-cancel-button",
                        onClick: cancel
                      }, {
                        default: withCtx7(() => [
                          createTextVNode3(toDisplayString4(unref14(tp)(_ctx.$props.cancelText)), 1)
                        ]),
                        _: 1
                      })) : createCommentVNode6("", true),
                      createVNode5(unref14(VaButton), {
                        "va-child": "okButton",
                        onClick: ok
                      }, {
                        default: withCtx7(() => [
                          createTextVNode3(toDisplayString4(unref14(tp)(_ctx.$props.okText)), 1)
                        ]),
                        _: 1
                      })
                    ])) : createCommentVNode6("", true),
                    _ctx.$slots.footer ? (openBlock11(), createElementBlock9("div", _hoisted_72, [
                      renderSlot7(_ctx.$slots, "footer", normalizeProps5(guardReactiveProps4(slotBind)))
                    ])) : createCommentVNode6("", true)
                  ]))
                ], 4)
              ], 10, _hoisted_17)) : createCommentVNode6("", true)
            ]),
            _: 3
          }, 16, ["isTransition", "style"])
        ], 8, ["to", "disabled"]))
      ], 2);
    };
  }
});

// node_modules/vuestic-ui/dist/es/src/components/va-modal/VaModal.js
import "D:/Desktop/forntend/Front_End_Web_Hotel_Nhom_2/my-nuxt-app/node_modules/vuestic-ui/dist/es/VaModal.css";
var VaModal = withConfigTransport$1(_sfc_main11);

// node_modules/vuestic-ui/dist/es/src/components/va-modal/modal.js
import { h as h5, render as render2, nextTick as nextTick3 } from "vue";
var getNodeProps3 = (vNode) => {
  var _a2;
  return ((_a2 = vNode.component) == null ? void 0 : _a2.props) || {};
};
var destroy2 = (el, vNode) => {
  if (el) {
    render2(null, el);
    el.remove();
  }
  el = null;
};
var mount2 = (component, { props, appContext } = {}) => {
  const el = document == null ? void 0 : document.createElement("div");
  let vNode;
  const onClose = (event) => {
    var _a2;
    (_a2 = props == null ? void 0 : props.onClose) == null ? void 0 : _a2.call(props, event);
    destroy2(el);
  };
  const onUpdateModelValue = (value) => {
    var _a2;
    (_a2 = props == null ? void 0 : props["onUpdate:modelValue"]) == null ? void 0 : _a2.call(props, value);
    if ((props == null ? void 0 : props.withoutTransitions) && !value) {
      nextTick3(() => {
        destroy2(el);
      });
    }
  };
  vNode = h5(component, {
    ...props,
    stateful: (props == null ? void 0 : props.stateful) ?? true,
    modelValue: true,
    onClose,
    "onUpdate:modelValue": onUpdateModelValue
  });
  if (appContext) {
    vNode.appContext = appContext;
  }
  if (el) {
    render2(vNode, el);
  }
  return { vNode, el };
};
var getModalOptions = (options) => typeof options === "string" ? { message: options } : options;
var createModalInstance = (customProps, appContext) => {
  const { vNode, el } = mount2(VaModal, { appContext, props: getModalOptions(customProps) });
  if (el && vNode.el && getNodeProps3(vNode)) {
    document.body.appendChild(el.childNodes[0]);
  }
  return vNode;
};

// node_modules/vuestic-ui/dist/es/src/components/va-modal/plugin/index.js
var createVaModalPlugin = (app) => ({
  init(options) {
    return createModalInstance(options, app == null ? void 0 : app._context);
  },
  confirm(options) {
    if (typeof options === "string") {
      return new Promise((resolve) => {
        createModalInstance({
          message: options,
          onOk() {
            resolve(true);
          },
          onCancel() {
            resolve(false);
          }
        }, app == null ? void 0 : app._context);
      });
    }
    return new Promise((resolve) => {
      createModalInstance({
        ...options,
        onOk() {
          var _a2;
          (_a2 = options == null ? void 0 : options.onOk) == null ? void 0 : _a2.call(options);
          resolve(true);
        },
        onCancel() {
          var _a2;
          (_a2 = options == null ? void 0 : options.onCancel) == null ? void 0 : _a2.call(options);
          resolve(false);
        }
      }, app == null ? void 0 : app._context);
    });
  }
});
var VaModalPlugin = defineVuesticPlugin(() => ({
  install(app) {
    defineGlobalProperty(app, "$vaModal", createVaModalPlugin(app));
  }
}));

// node_modules/vuestic-ui/dist/es/src/services/colors-classes/plugin/index.js
import { watch as watch14 } from "vue";
var getColorsClassesHelpers = (helpers, colors) => {
  const colorsEntries = Object.entries(colors);
  return helpers.reduce((acc, helper) => acc.concat(
    colorsEntries.map(([colorName, colorValue]) => ({
      ...helper,
      postfix: helper.postfix ?? colorName,
      value: helper.value ?? colorValue
    }))
  ), []);
};
var getColorsClassesStyles = (helpers) => {
  return helpers.reduce((styles, helper) => {
    const style = [helper.property].flat().map((prop) => `${prop}: ${helper.value};`).join("");
    styles += `.va-${helper.prefix}--${helper.postfix} { ${style} }`;
    return styles;
  }, "");
};
var handleConfigUpdate = (helpers, colors) => {
  const coloredHelpers = getColorsClassesHelpers(helpers, colors);
  addOrUpdateStyleElement(
    "va-color-helpers",
    () => getColorsClassesStyles(coloredHelpers)
  );
};
var createColorHelpersPlugin = () => {
  if (isServer()) {
    return;
  }
  const { globalConfig } = useGlobalConfig();
  watch14(() => globalConfig.value.colorsClasses, (newHelpers) => {
    if (newHelpers.length) {
      handleConfigUpdate(newHelpers, globalConfig.value.colors.variables);
    }
  }, { immediate: true, deep: true });
  watch14(() => globalConfig.value.colors.variables, (newColors) => {
    if (!newColors) {
      return;
    }
    handleConfigUpdate(globalConfig.value.colorsClasses, newColors);
  }, { immediate: true, deep: true });
  return {
    renderColorHelpers: () => {
      const coloredHelpers = getColorsClassesHelpers(globalConfig.value.colorsClasses, globalConfig.value.colors.variables);
      return getColorsClassesStyles(coloredHelpers);
    }
  };
};
var ColorsClassesPlugin = defineVuesticPlugin(() => ({
  install(app) {
    defineGlobalProperty(app, "$vaColorsClasses", createColorHelpersPlugin());
  }
}));

// node_modules/vuestic-ui/dist/es/src/components/va-accordion/VaAccordion.vue_vue_type_script_setup_true_lang.js
import { defineComponent as defineComponent12, openBlock as openBlock12, createElementBlock as createElementBlock10, renderSlot as renderSlot8 } from "vue";

// node_modules/vuestic-ui/dist/es/src/components/va-accordion/hooks/useAccordion.js
import { ref as ref17, provide as provide4, computed as computed49, inject as inject6, onBeforeUnmount as onBeforeUnmount10, nextTick as nextTick4 } from "vue";
var AccordionServiceKey = Symbol("AccordionService");
var useAccordion = (props, state) => {
  const items2 = ref17([]);
  const makeState = () => {
    const correctItemsCount = Math.max(items2.value.length, state.value.length);
    return Array.from({ length: correctItemsCount }, (_, index) => {
      return state.value[index] ?? false;
    });
  };
  const getItemValue = (item) => {
    return state.value[items2.value.indexOf(item)] ?? false;
  };
  const onItemsChanged = () => {
    state.value = makeState();
  };
  const registerItem = (item) => {
    items2.value.push(item);
    onItemsChanged();
  };
  const unregisterItem = (item) => {
    items2.value = items2.value.filter((i) => i !== item);
    nextTick4(onItemsChanged);
  };
  const setItemValue = (item, value) => {
    const index = items2.value.indexOf(item);
    if (index === -1) {
      warn("Accordion item is not registered yet");
      return;
    }
    if (!props.multiple) {
      state.value = makeState().map((el, i) => {
        if (i === index) {
          return value;
        }
        return false;
      });
    } else {
      state.value[index] = value;
    }
  };
  provide4(AccordionServiceKey, {
    registerItem,
    unregisterItem,
    getItemValue,
    setItemValue,
    props: computed49(() => props)
  });
  return { items: items2 };
};
var useAccordionItem = () => {
  const accordion = inject6(AccordionServiceKey, void 0);
  if (!accordion) {
    return { accordionProps: ref17({}) };
  }
  const item = {};
  accordion.registerItem(item);
  onBeforeUnmount10(() => accordion.unregisterItem(item));
  const accordionItemValue = computed49({
    get: () => accordion.getItemValue(item),
    set: (value) => accordion.setItemValue(item, value)
  });
  return {
    accordionItemValue,
    accordionProps: accordion.props
  };
};

// node_modules/vuestic-ui/dist/es/src/components/va-accordion/VaAccordion.vue_vue_type_script_setup_true_lang.js
import "D:/Desktop/forntend/Front_End_Web_Hotel_Nhom_2/my-nuxt-app/node_modules/vuestic-ui/dist/es/VaAccordion.css";
var _hoisted_18 = { class: "va-accordion" };
var _sfc_main12 = defineComponent12({
  ...{
    name: "VaAccordion"
  },
  __name: "VaAccordion",
  props: {
    ...useStatefulProps,
    ...useComponentPresetProp,
    modelValue: { type: Array, default: () => [] },
    multiple: { type: Boolean, default: false },
    inset: { type: Boolean, default: false },
    stateful: { type: Boolean, default: true },
    popout: { type: Boolean, default: false }
  },
  emits: [...useStatefulEmits],
  setup(__props, { expose: __expose, emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const { valueComputed } = useStateful(props, emit, "modelValue");
    const { items: items2 } = useAccordion(props, valueComputed);
    const collapses = items2;
    const value = valueComputed;
    __expose({
      collapses,
      value
    });
    return (_ctx, _cache) => {
      return openBlock12(), createElementBlock10("div", _hoisted_18, [
        renderSlot8(_ctx.$slots, "default")
      ]);
    };
  }
});

// node_modules/vuestic-ui/dist/es/src/components/va-accordion/index.js
var VaAccordion = withConfigTransport$1(_sfc_main12);

// node_modules/vuestic-ui/dist/es/src/components/va-affix/VaAffix.vue_vue_type_script_setup_true_lang.js
import { defineComponent as defineComponent13, shallowRef as shallowRef6, computed as computed50, ref as ref18, onMounted as onMounted12, nextTick as nextTick5, onBeforeUnmount as onBeforeUnmount11, openBlock as openBlock13, createElementBlock as createElementBlock11, createElementVNode as createElementVNode7, normalizeStyle as normalizeStyle6, renderSlot as renderSlot9, normalizeClass as normalizeClass6, createCommentVNode as createCommentVNode7 } from "vue";

// node_modules/vuestic-ui/dist/es/src/utils/noop.js
var noop = () => {
};

// node_modules/vuestic-ui/dist/es/src/utils/throttle.js
var throttle = (func, wait) => {
  let lastTime = 0;
  return function(...args) {
    const now = Date.now();
    if (now - lastTime < wait) {
      return;
    }
    func.apply(this, args);
    lastTime = now;
  };
};

// node_modules/vuestic-ui/dist/es/src/components/va-affix/VaAffix-utils.js
function getWindowHeight() {
  return document.documentElement.clientHeight || window.innerHeight || document.body.clientHeight;
}
function computeAffixedState({
  coordinates,
  offsetTop,
  offsetBottom,
  target
}) {
  let isTopAffixed = false;
  let isBottomAffixed = false;
  const windowHeight = getWindowHeight();
  if (offsetTop != null && windowHeight) {
    if (target === window) {
      isTopAffixed = coordinates.top <= offsetTop;
    } else {
      const { top } = target.getBoundingClientRect();
      isTopAffixed = coordinates.top - top <= offsetTop;
    }
  }
  if (offsetBottom != null && windowHeight) {
    if (target === window) {
      isBottomAffixed = coordinates.bottom >= windowHeight - offsetBottom;
    } else {
      const { bottom } = target.getBoundingClientRect();
      isBottomAffixed = bottom - coordinates.bottom <= offsetBottom;
    }
  }
  return {
    isTopAffixed,
    isBottomAffixed
  };
}
function checkAffixedStateChange(currentState, nextState) {
  return currentState.isTopAffixed !== nextState.isTopAffixed || currentState.isBottomAffixed !== nextState.isBottomAffixed;
}
function handleThrottledEvent(eventName, context) {
  const { target, element, offsetTop, offsetBottom, setState, getState, initialPosition } = context;
  if (!element) {
    return;
  }
  const isInitialCall = !eventName;
  const coordinates = element.getBoundingClientRect();
  const options = {
    offsetBottom,
    offsetTop,
    target
  };
  const nextState = isInitialCall && initialPosition ? computeAffixedState({ coordinates: initialPosition, ...options }) : computeAffixedState({ coordinates, ...options });
  const prevState = getState();
  if (checkAffixedStateChange(prevState, nextState)) {
    setState({ ...nextState, width: coordinates.width });
  } else if (prevState.width !== coordinates.width) {
    setState({ ...prevState, width: coordinates.width });
  }
}
function useCaptureDefault(eventName) {
  return eventName === "scroll";
}
function useEventsHandlerWithThrottle(events, {
  handler,
  useCapture = useCaptureDefault,
  wait = 50
}) {
  const clearHandlersArray = events.map((eventName) => {
    const _handler = throttle((event) => handler(eventName, event), wait);
    window.addEventListener(eventName, _handler, useCapture(eventName));
    return () => window.removeEventListener(eventName, _handler, useCapture(eventName));
  });
  return () => clearHandlersArray.forEach((clear) => clear());
}

// node_modules/vuestic-ui/dist/es/src/components/va-affix/VaAffix.vue_vue_type_script_setup_true_lang.js
import "D:/Desktop/forntend/Front_End_Web_Hotel_Nhom_2/my-nuxt-app/node_modules/vuestic-ui/dist/es/VaAffix.css";
var _sfc_main13 = defineComponent13({
  ...{
    name: "VaAffix"
  },
  __name: "VaAffix",
  props: {
    ...useComponentPresetProp,
    offsetTop: { type: [Number, String], default: void 0 },
    offsetBottom: { type: [Number, String], default: void 0 },
    target: { type: [Object, Function], default: getWindow }
  },
  emits: ["change"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const element = shallowRef6();
    const getTargetElement2 = () => typeof props.target === "function" ? props.target() : props.target;
    const isAffixed = computed50(() => state.value.isTopAffixed || state.value.isBottomAffixed);
    const state = ref18({
      isTopAffixed: false,
      isBottomAffixed: false
    });
    const getState = () => state.value;
    const setState = (newState) => {
      state.value = newState;
      emit("change", isAffixed);
    };
    const offsetTopComputed = useNumericProp("offsetTop");
    const offsetBottomComputed = useNumericProp("offsetBottom");
    const calculateTop = () => {
      const target = getTargetElement2();
      if (!target) {
        return 0;
      }
      if (offsetTopComputed.value === void 0) {
        return;
      }
      if (!(target instanceof Window)) {
        const { top } = target.getBoundingClientRect();
        return top + offsetTopComputed.value;
      }
      return offsetTopComputed.value;
    };
    const calculateBottom = () => {
      const target = getTargetElement2();
      if (!target) {
        return 0;
      }
      if (offsetBottomComputed.value === void 0) {
        return;
      }
      if (!(target instanceof Window)) {
        const { bottom } = target.getBoundingClientRect();
        const { borderTopWidth, borderBottomWidth } = getComputedStyle(target);
        const { offsetHeight, clientHeight } = target;
        const scrollBarHeight = offsetHeight - clientHeight - parseInt(borderTopWidth) - parseInt(borderBottomWidth);
        return getWindowHeight() - (bottom - offsetBottomComputed.value) + scrollBarHeight;
      }
      return offsetBottomComputed.value;
    };
    const convertToPixels = (calculate) => {
      const result = calculate();
      return result === void 0 ? void 0 : `${result}px`;
    };
    const computedClass = computed50(() => [{ "va-affix--affixed": isAffixed }]);
    const computedStyle = computed50(() => ({
      top: state.value.isTopAffixed ? convertToPixels(calculateTop) : void 0,
      bottom: state.value.isBottomAffixed ? convertToPixels(calculateBottom) : void 0,
      width: `${state.value.width}px`
    }));
    const initialPosition = ref18();
    const throttledEventHandler = (eventName, event) => {
      const context = {
        ...props,
        offsetTop: offsetTopComputed.value,
        offsetBottom: offsetBottomComputed.value,
        initialPosition: initialPosition.value,
        element: element.value,
        target: getTargetElement2(),
        setState,
        getState
      };
      if (!eventName || eventName === "resize") {
        handleThrottledEvent(eventName, context);
      } else if (event && event.target) {
        const target = getTargetElement2();
        if (target === event.target || target instanceof Window) {
          handleThrottledEvent(eventName, context);
        } else {
          setState({
            isBottomAffixed: false,
            isTopAffixed: false
          });
        }
      }
    };
    let clearEventListeners = noop;
    onMounted12(() => {
      var _a2;
      initialPosition.value = (_a2 = element.value) == null ? void 0 : _a2.getBoundingClientRect();
      const events = ["scroll", "resize"];
      clearEventListeners = useEventsHandlerWithThrottle(events, {
        handler: throttledEventHandler
      });
      nextTick5(() => {
        throttledEventHandler(null);
      });
    });
    onBeforeUnmount11(clearEventListeners);
    return (_ctx, _cache) => {
      return openBlock13(), createElementBlock11("div", {
        ref_key: "element",
        ref: element,
        class: "va-affix"
      }, [
        createElementVNode7("div", {
          style: normalizeStyle6({ visibility: isAffixed.value ? "hidden" : "inherit" })
        }, [
          renderSlot9(_ctx.$slots, "default")
        ], 4),
        isAffixed.value ? (openBlock13(), createElementBlock11("div", {
          key: 0,
          class: normalizeClass6(computedClass.value),
          style: normalizeStyle6(computedStyle.value)
        }, [
          renderSlot9(_ctx.$slots, "default")
        ], 6)) : createCommentVNode7("", true)
      ], 512);
    };
  }
});

// node_modules/vuestic-ui/dist/es/src/components/va-affix/index.js
var VaAffix = withConfigTransport$1(_sfc_main13);

// node_modules/vuestic-ui/dist/es/src/components/va-alert/VaAlert.vue_vue_type_script_setup_true_lang.js
import { defineComponent as defineComponent14, useSlots, computed as computed52, openBlock as openBlock14, createBlock as createBlock8, Transition as Transition3, withCtx as withCtx8, unref as unref15, createElementBlock as createElementBlock12, normalizeStyle as normalizeStyle7, createElementVNode as createElementVNode8, normalizeClass as normalizeClass7, renderSlot as renderSlot10, createVNode as createVNode6, createCommentVNode as createCommentVNode8, createTextVNode as createTextVNode4, toDisplayString as toDisplayString5, withKeys as withKeys3 } from "vue";

// node_modules/vuestic-ui/dist/es/src/components/va-alert/useAlertStyles.js
import { computed as computed51, toRef as toRef4 } from "vue";

// node_modules/vuestic-ui/dist/es/src/composables/useElementTextColor.js
var useElementTextColor = (background) => {
  const { textColorComputed } = useTextColor(background);
  return textColorComputed;
};

// node_modules/vuestic-ui/dist/es/src/composables/useCurrentElement.js
import { getCurrentInstance as getCurrentInstance21, shallowRef as shallowRef7, onMounted as onMounted13, onUpdated as onUpdated2, onBeforeUnmount as onBeforeUnmount12 } from "vue";
var useCurrentElement = (el) => {
  if (el) {
    return el;
  }
  const vm = getCurrentInstance21();
  const currentEl = shallowRef7();
  onMounted13(() => {
    currentEl.value = vm.proxy.$el ?? void 0;
  });
  onUpdated2(() => {
    currentEl.value = vm.proxy.$el ?? void 0;
  });
  onBeforeUnmount12(() => {
    currentEl.value = vm.proxy.$el ?? void 0;
  });
  return currentEl;
};

// node_modules/vuestic-ui/dist/es/src/components/va-alert/useAlertStyles.js
var useAlertStyles = (props) => {
  const { getColor } = useColors();
  const isTransparentBackground = computed51(() => Boolean(props.outline || props.border));
  const { textColorComputed } = useTextColor(toRef4(props, "color"), isTransparentBackground);
  const colorComputed = computed51(() => getColor(props.color));
  const alertStyle = computed51(() => {
    let background = colorComputed.value;
    let boxShadow = "none";
    if (props.outline) {
      background = "transparent";
    }
    if (props.border) {
      background = "var(--va-background-primary)";
      boxShadow = "var(--va-alert-box-shadow)";
    }
    return {
      border: props.outline ? `1px solid ${colorComputed.value}` : "",
      padding: props.dense ? "var(--va-alert-padding-y-dense) var(--va-alert-padding-x)" : "",
      backgroundColor: background,
      boxShadow
    };
  });
  const currentColor = useElementTextColor(useElementBackground(useCurrentElement()));
  const contentStyle = computed51(() => {
    return {
      alignItems: props.center ? "center" : "",
      color: props.border || props.outline ? currentColor.value : textColorComputed.value
    };
  });
  const titleStyle = computed51(() => {
    return { color: textColorComputed.value };
  });
  const borderStyle = computed51(() => ({
    backgroundColor: props.borderColor ? getColor(props.borderColor) : colorComputed.value
  }));
  return {
    alertStyle,
    contentStyle,
    titleStyle,
    borderStyle
  };
};

// node_modules/vuestic-ui/dist/es/src/components/va-alert/VaAlert.vue_vue_type_script_setup_true_lang.js
import "D:/Desktop/forntend/Front_End_Web_Hotel_Nhom_2/my-nuxt-app/node_modules/vuestic-ui/dist/es/VaAlert.css";
var _hoisted_19 = {
  key: 1,
  class: "va-alert__close"
};
var _hoisted_24 = ["aria-label"];
var _sfc_main14 = defineComponent14({
  ...{
    name: "VaAlert"
  },
  __name: "VaAlert",
  props: {
    ...useStatefulProps,
    ...useComponentPresetProp,
    modelValue: { type: Boolean, default: true },
    stateful: { type: Boolean, default: true },
    color: { type: String, default: "primary" },
    textColor: { type: String, default: "" },
    title: { type: String, default: "" },
    description: { type: String, default: "" },
    icon: { type: String, default: "" },
    closeText: { type: String, default: "" },
    closeIcon: { type: String, default: "close" },
    closeable: { type: Boolean, default: false },
    dense: { type: Boolean, default: false },
    outline: { type: Boolean, default: false },
    center: { type: Boolean, default: false },
    borderColor: { type: String, default: "" },
    border: {
      type: String,
      default: "",
      validator: (value) => ["top", "right", "bottom", "left", ""].includes(value)
    }
  },
  emits: [...useStatefulEmits],
  setup(__props, { expose: __expose, emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const {
      contentStyle,
      titleStyle,
      alertStyle,
      borderStyle
    } = useAlertStyles(props);
    const { valueComputed } = useStateful(props, emit);
    const hide2 = () => {
      valueComputed.value = false;
    };
    const show = () => {
      valueComputed.value = true;
    };
    const slots = useSlots();
    const hasIcon = computed52(() => props.icon || slots.icon);
    const hasTitle = computed52(() => props.title || slots.title);
    const borderClass = computed52(() => `va-alert__border--${props.border}`);
    const { tp, t } = useTranslation();
    __expose({
      hide: hide2,
      show
    });
    return (_ctx, _cache) => {
      return openBlock14(), createBlock8(Transition3, { name: "fade" }, {
        default: withCtx8(() => [
          unref15(valueComputed) ? (openBlock14(), createElementBlock12("div", {
            key: 0,
            class: "va-alert",
            style: normalizeStyle7(unref15(alertStyle)),
            role: "alert"
          }, [
            createElementVNode8("div", {
              style: normalizeStyle7(unref15(borderStyle)),
              class: normalizeClass7([borderClass.value, "va-alert__border"])
            }, null, 6),
            hasIcon.value ? (openBlock14(), createElementBlock12("div", {
              key: 0,
              style: normalizeStyle7(unref15(contentStyle)),
              class: "va-alert__icon",
              "aria-hidden": "true"
            }, [
              renderSlot10(_ctx.$slots, "icon", {}, () => [
                createVNode6(unref15(VaIcon), { name: __props.icon }, null, 8, ["name"])
              ])
            ], 4)) : createCommentVNode8("", true),
            createElementVNode8("div", {
              style: normalizeStyle7(unref15(contentStyle)),
              class: "va-alert__content"
            }, [
              hasTitle.value ? (openBlock14(), createElementBlock12("div", {
                key: 0,
                style: normalizeStyle7(unref15(titleStyle)),
                class: "va-alert__title"
              }, [
                renderSlot10(_ctx.$slots, "title", {}, () => [
                  createTextVNode4(toDisplayString5(__props.title), 1)
                ])
              ], 4)) : createCommentVNode8("", true),
              createElementVNode8("span", null, [
                renderSlot10(_ctx.$slots, "default", {}, () => [
                  createTextVNode4(toDisplayString5(_ctx.$props.description), 1)
                ])
              ])
            ], 4),
            __props.closeable ? (openBlock14(), createElementBlock12("div", _hoisted_19, [
              createElementVNode8("div", {
                role: "button",
                class: "va-alert__close--closeable",
                tabindex: "0",
                "aria-label": __props.closeText || unref15(t)("closeAlert"),
                style: normalizeStyle7(unref15(contentStyle)),
                onClick: hide2,
                onKeydown: [
                  withKeys3(hide2, ["space"]),
                  withKeys3(hide2, ["enter"])
                ]
              }, [
                renderSlot10(_ctx.$slots, "close", {}, () => [
                  !__props.closeText ? (openBlock14(), createBlock8(unref15(VaIcon), {
                    key: 0,
                    name: __props.closeIcon
                  }, null, 8, ["name"])) : createCommentVNode8("", true),
                  createTextVNode4(" " + toDisplayString5(__props.closeText), 1)
                ])
              ], 44, _hoisted_24)
            ])) : createCommentVNode8("", true)
          ], 4)) : createCommentVNode8("", true)
        ]),
        _: 3
      });
    };
  }
});

// node_modules/vuestic-ui/dist/es/src/components/va-alert/index.js
var VaAlert = withConfigTransport$1(_sfc_main14);

// node_modules/vuestic-ui/dist/es/src/components/va-app-bar/VaAppBar.vue_vue_type_script_setup_true_lang.js
import { defineComponent as defineComponent15, computed as computed54, toRef as toRef5, openBlock as openBlock15, createElementBlock as createElementBlock13, normalizeStyle as normalizeStyle8, renderSlot as renderSlot11 } from "vue";

// node_modules/vuestic-ui/dist/es/src/composables/useFixedBar.js
import { computed as computed53 } from "vue";
var useFixedBarProps = {
  hideOnScroll: { type: Boolean, default: false },
  fixed: { type: Boolean, default: false },
  bottom: { type: Boolean, default: false }
};
function useFixedBar(props, isScrolledDown) {
  const isHiddenComputed = computed53(() => isScrolledDown.value ? !!props.hideOnScroll : false);
  const transformComputed = computed53(() => {
    if (!props.bottom && !isHiddenComputed.value) {
      return;
    }
    if (props.bottom && isHiddenComputed.value) {
      return "translateY(100%)";
    }
    if (props.bottom) {
      return props.fixed ? "translateY(-100%)" : "translateY(0)";
    }
    return "translateY(-100%)";
  });
  const positionComputed = computed53(() => {
    if (props.fixed) {
      return "fixed";
    }
    return isHiddenComputed.value ? "absolute" : void 0;
  });
  const fixedBarStyleComputed = computed53(() => {
    const result = {
      top: props.bottom && (isHiddenComputed.value || props.fixed) ? "100%" : void 0,
      transform: props.hideOnScroll || props.fixed ? transformComputed.value : void 0
    };
    positionComputed.value && Object.assign(result, { position: positionComputed.value });
    return result;
  });
  return { fixedBarStyleComputed };
}

// node_modules/vuestic-ui/dist/es/src/composables/useScroll.js
import { shallowRef as shallowRef8, ref as ref19, onMounted as onMounted14, onBeforeUnmount as onBeforeUnmount13 } from "vue";
function getTargetElement(target) {
  if (!target) {
    throw new Error("No target was provided for `useScroll` hook!");
  }
  return typeof target === "string" ? document.querySelector(target) : target;
}
function setupScroll(fixed, target) {
  const scrollRoot = shallowRef8();
  let targetElement;
  const isScrolledDown = ref19(false);
  const prevScrollPosition = ref19(0);
  const onScroll = (e) => {
    const target2 = e.target;
    const scrollValue = e.target instanceof Window ? target2.scrollY : target2.scrollTop;
    isScrolledDown.value = prevScrollPosition.value < scrollValue;
    prevScrollPosition.value = scrollValue;
  };
  onMounted14(() => {
    targetElement = fixed ? window : getTargetElement(target || scrollRoot.value);
    targetElement == null ? void 0 : targetElement.addEventListener("scroll", onScroll, fixed);
  });
  onBeforeUnmount13(() => {
    targetElement == null ? void 0 : targetElement.removeEventListener("scroll", onScroll);
  });
  return { scrollRoot, isScrolledDown };
}

// node_modules/vuestic-ui/dist/es/src/components/va-app-bar/VaAppBar.vue_vue_type_script_setup_true_lang.js
import "D:/Desktop/forntend/Front_End_Web_Hotel_Nhom_2/my-nuxt-app/node_modules/vuestic-ui/dist/es/VaAppBar.css";
var _sfc_main15 = defineComponent15({
  ...{
    name: "VaAppBar"
  },
  __name: "VaAppBar",
  props: {
    ...useFixedBarProps,
    ...useComponentPresetProp,
    gradient: { type: Boolean, default: false },
    target: { type: [Object, String], default: "" },
    shadowOnScroll: { type: Boolean, default: false },
    shadowColor: { type: String, default: "" },
    color: { type: String, default: "primary" }
  },
  setup(__props) {
    const props = __props;
    const { scrollRoot, isScrolledDown } = setupScroll(props.fixed, props.target);
    const { fixedBarStyleComputed } = useFixedBar(props, isScrolledDown);
    const { getColor, getGradientBackground: getGradientBackground2, getBoxShadowColor: getBoxShadowColor2 } = useColors();
    const colorComputed = computed54(() => getColor(props.color));
    const { textColorComputed } = useTextColor(toRef5(props, "color"));
    const showShadowComputed = computed54(() => isScrolledDown.value ? !!props.shadowOnScroll : false);
    const shadowColorComputed = computed54(() => getColor(props.shadowColor, colorComputed.value));
    const computedShadow = computed54(() => {
      const shadow = getBoxShadowColor2(props.shadowColor ? shadowColorComputed.value : colorComputed.value);
      return showShadowComputed.value ? `var(--va-app-bar-shadow) ${shadow}` : "";
    });
    const computedStyle = computed54(() => ({
      ...fixedBarStyleComputed.value,
      background: props.gradient ? getGradientBackground2(colorComputed.value) : colorComputed.value,
      boxShadow: computedShadow.value,
      color: textColorComputed.value
    }));
    return (_ctx, _cache) => {
      return openBlock15(), createElementBlock13("header", {
        ref_key: "scrollRoot",
        ref: scrollRoot,
        role: "toolbar",
        class: "va-app-bar",
        style: normalizeStyle8(computedStyle.value)
      }, [
        renderSlot11(_ctx.$slots, "default")
      ], 4);
    };
  }
});

// node_modules/vuestic-ui/dist/es/src/components/va-app-bar/index.js
var VaAppBar = withConfigTransport$1(_sfc_main15);

// node_modules/vuestic-ui/dist/es/src/components/va-aspect-ratio/VaAspectRatio.vue_vue_type_script_setup_true_lang.js
import { defineComponent as defineComponent16, computed as computed55, openBlock as openBlock16, createElementBlock as createElementBlock14, normalizeStyle as normalizeStyle9, createCommentVNode as createCommentVNode9, renderSlot as renderSlot12 } from "vue";
import "D:/Desktop/forntend/Front_End_Web_Hotel_Nhom_2/my-nuxt-app/node_modules/vuestic-ui/dist/es/VaAspectRatio.css";
var _sfc_main16 = defineComponent16({
  ...{
    name: "VaAspectRatio"
  },
  __name: "VaAspectRatio",
  props: {
    ...useComponentPresetProp,
    ratio: {
      type: [Number, String],
      default: "auto"
    },
    contentHeight: { type: [Number, String], default: 1 },
    contentWidth: { type: [Number, String], default: 1 },
    maxWidth: {
      type: [Number, String],
      default: 0,
      validator: (v) => Number(v) >= 0
    }
  },
  setup(__props) {
    const props = __props;
    const contentHeightComputed = useNumericProp("contentHeight");
    const contentWidthComputed = useNumericProp("contentWidth");
    const aspectRatio = computed55(() => {
      if (props.ratio === "auto" && props.contentHeight === 1 && props.contentWidth === 1) {
        return 0;
      }
      if (!isNaN(+props.ratio)) {
        return props.ratio;
      }
      return contentWidthComputed.value / contentHeightComputed.value;
    });
    const stylesComputed = computed55(() => {
      if (!aspectRatio.value) {
        return;
      }
      return { paddingBottom: `${1 / aspectRatio.value * 100}%` };
    });
    const maxWidthComputed = computed55(() => props.maxWidth ? `${props.maxWidth}px` : void 0);
    return (_ctx, _cache) => {
      return openBlock16(), createElementBlock14("div", {
        class: "va-aspect-ratio",
        style: normalizeStyle9(`--va-max-width-computed: ${String(maxWidthComputed.value)}`)
      }, [
        stylesComputed.value ? (openBlock16(), createElementBlock14("div", {
          key: 0,
          style: normalizeStyle9(stylesComputed.value)
        }, null, 4)) : createCommentVNode9("", true),
        renderSlot12(_ctx.$slots, "default")
      ], 4);
    };
  }
});

// node_modules/vuestic-ui/dist/es/src/components/va-aspect-ratio/index.js
var VaAspectRatio = withConfigTransport$1(_sfc_main16);

// node_modules/vuestic-ui/dist/es/src/components/va-avatar/VaAvatar.vue_vue_type_script_setup_true_lang.js
import { defineComponent as defineComponent18, computed as computed57, ref as ref20, watch as watch15, openBlock as openBlock17, createElementBlock as createElementBlock15, normalizeClass as normalizeClass8, unref as unref16, normalizeStyle as normalizeStyle10, createBlock as createBlock9, renderSlot as renderSlot13, normalizeProps as normalizeProps7, mergeProps as mergeProps8, createVNode as createVNode7 } from "vue";

// node_modules/vuestic-ui/dist/es/src/components/va-fallback/VaFallback.vue_vue_type_script_lang.js
import { defineComponent as defineComponent17, onMounted as onMounted15, h as h6 } from "vue";
var _sfc_main17 = defineComponent17({
  name: "VaFallback",
  props: {
    fallbackSrc: {
      type: String
    },
    fallbackText: {
      type: String
    },
    fallbackIcon: {
      type: String
    },
    fallbackRender: {
      type: Function
    }
  },
  components: { VaIcon },
  emits: ["fallback"],
  setup(props, { emit }) {
    onMounted15(() => {
      emit("fallback");
    });
    if (props.fallbackIcon) {
      return () => h6(VaIcon, {
        name: props.fallbackIcon
      });
    }
    if (props.fallbackSrc) {
      return () => h6("img", {
        src: props.fallbackSrc
      });
    }
    if (props.fallbackRender) {
      return () => {
        var _a2;
        return h6((_a2 = props.fallbackRender) == null ? void 0 : _a2.call(props));
      };
    }
    return () => h6("span", props.fallbackText);
  }
});

// node_modules/vuestic-ui/dist/es/src/components/va-fallback/index.js
var VaFallback = withConfigTransport$1(_sfc_main17);

// node_modules/vuestic-ui/dist/es/src/utils/component-options/resolve-component-props.js
function normalizeProps6(props) {
  switch (true) {
    case Array.isArray(props):
      return props.reduce((acc, prop) => ({ ...acc, [prop]: null }), {});
    case (typeof props === "object" && props !== null):
      return props;
    default:
      return {};
  }
}
function mergeProps7(to, from, optionsType = "props") {
  const { mixins, extends: extendsOptions } = from;
  extendsOptions && mergeProps7(to, extendsOptions, optionsType);
  mixins && mixins.forEach((m) => mergeProps7(to, m, optionsType));
  const props = normalizeProps6(from[optionsType]);
  for (const key in props) {
    to[key] = props[key];
  }
}
function getComponentOptions(component) {
  if (component.options) {
    return component.options;
  }
  if (component.__vccOpts || component.__b) {
    return { ...component.__vccOpts, ...component.__b };
  }
  return component;
}
function resolveProps(options, optionsType = "props") {
  const mixins = options.mixins ?? [];
  const extendsOptions = options.extends ?? [];
  const result = {};
  mergeProps7(result, extendsOptions, optionsType);
  for (let i = 0; i < mixins.length; i++) {
    mergeProps7(result, mixins[i], optionsType);
  }
  Object.assign(result, normalizeProps6(options[optionsType]));
  return result;
}
var getComponentProps = (component) => {
  return resolveProps(getComponentOptions(component));
};

// node_modules/vuestic-ui/dist/es/src/utils/component-options/extract-component-options.js
function extractComponentProps(component, ignoreProps) {
  const props = getComponentProps(component);
  if (ignoreProps) {
    return Object.keys(props).reduce((acc, propName) => {
      if (ignoreProps.includes(propName)) {
        return acc;
      }
      if (props[propName] === void 0) {
        return acc;
      }
      acc[propName] = typeof props[propName] === "string" ? {} : props[propName];
      return acc;
    }, {});
  }
  return props;
}
function extractComponentEmits(component) {
  return [...new Set(component.emits)];
}

// node_modules/vuestic-ui/dist/es/src/utils/component-options/filter-props.js
import { getCurrentInstance as getCurrentInstance22, computed as computed56 } from "vue";
var filterComponentProps = (childProps) => {
  const { props } = getCurrentInstance22();
  return computed56(() => {
    return Object.keys(childProps).reduce((acc, propName) => {
      acc[propName] = props[propName];
      return acc;
    }, {});
  });
};

// node_modules/vuestic-ui/dist/es/src/components/va-avatar/VaAvatar.vue_vue_type_script_setup_true_lang.js
import "D:/Desktop/forntend/Front_End_Web_Hotel_Nhom_2/my-nuxt-app/node_modules/vuestic-ui/dist/es/VaAvatar.css";
var _hoisted_110 = ["src", "alt"];
var VaFallbackPropsDeclaration = extractComponentProps(VaFallback);
var _sfc_main18 = defineComponent18({
  ...{
    name: "VaAvatar"
  },
  __name: "VaAvatar",
  props: {
    ...useLoadingProps,
    ...useSizeProps,
    ...useComponentPresetProp,
    ...VaFallbackPropsDeclaration,
    color: { type: String, default: "primary" },
    textColor: { type: String },
    square: { type: Boolean, default: false },
    fontSize: { type: String, default: "" },
    src: { type: String, default: null },
    icon: { type: String, default: "" },
    alt: { type: String, default: "" }
  },
  emits: ["error", "fallback"],
  setup(__props, { expose: __expose, emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const { getColor } = useColors();
    const colorComputed = computed57(() => getColor(props.color));
    const backgroundColorComputed = computed57(() => {
      if (props.loading || props.src && !hasLoadError.value) {
        return void 0;
      }
      return colorComputed.value;
    });
    const { sizeComputed, fontSizeComputed } = useSize(props, "VaAvatar");
    const { textColorComputed } = useTextColor(backgroundColorComputed);
    const computedStyle = computed57(() => ({
      fontSize: props.fontSize || fontSizeComputed.value
    }));
    const classesComputed = useBem("va-avatar", () => ({
      ...pick(props, ["square"])
    }));
    const hasLoadError = ref20(false);
    const onLoadError = (event) => {
      hasLoadError.value = true;
      emit("error", event);
    };
    watch15(() => props.src, () => {
      hasLoadError.value = false;
    });
    const avatarOptions = computed57(() => ({
      hasError: hasLoadError.value,
      onError: onLoadError
    }));
    const VaFallbackProps2 = filterComponentProps(VaFallbackPropsDeclaration);
    __expose({
      hasLoadError
    });
    return (_ctx, _cache) => {
      return openBlock17(), createElementBlock15("div", {
        class: normalizeClass8(["va-avatar", unref16(classesComputed)]),
        style: normalizeStyle10([computedStyle.value, `--va-background-color-computed: ${String(backgroundColorComputed.value)};--va-text-color-computed: ${String(unref16(textColorComputed))};--va-size-computed: ${String(unref16(sizeComputed))}`])
      }, [
        _ctx.$props.loading ? (openBlock17(), createBlock9(unref16(VaProgressCircle), {
          key: 0,
          size: unref16(sizeComputed),
          color: colorComputed.value,
          indeterminate: ""
        }, null, 8, ["size", "color"])) : renderSlot13(_ctx.$slots, "default", normalizeProps7(mergeProps8({ key: 1 }, avatarOptions.value)), () => [
          _ctx.$props.src && !hasLoadError.value ? (openBlock17(), createElementBlock15("img", {
            key: 0,
            src: _ctx.$props.src,
            alt: _ctx.$props.alt,
            onError: onLoadError
          }, null, 40, _hoisted_110)) : hasLoadError.value && _ctx.$props.src ? renderSlot13(_ctx.$slots, "fallback", { key: 1 }, () => [
            createVNode7(unref16(VaFallback), mergeProps8(unref16(VaFallbackProps2), {
              onFallback: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("fallback"))
            }), null, 16)
          ]) : _ctx.$props.icon ? (openBlock17(), createBlock9(unref16(VaIcon), {
            key: 2,
            name: _ctx.$props.icon
          }, null, 8, ["name"])) : renderSlot13(_ctx.$slots, "fallback", { key: 3 }, () => [
            createVNode7(unref16(VaFallback), mergeProps8(unref16(VaFallbackProps2), {
              onFallback: _cache[1] || (_cache[1] = ($event) => _ctx.$emit("fallback"))
            }), null, 16)
          ])
        ])
      ], 6);
    };
  }
});

// node_modules/vuestic-ui/dist/es/src/components/va-avatar/index.js
var VaAvatar = withConfigTransport$1(_sfc_main18);

// node_modules/vuestic-ui/dist/es/src/components/va-avatar-group/VaAvatarGroup.vue_vue_type_script_setup_true_lang.js
import { defineComponent as defineComponent19, computed as computed58, openBlock as openBlock18, createElementBlock as createElementBlock16, normalizeClass as normalizeClass9, unref as unref17, Fragment as Fragment5, renderList as renderList2, createBlock as createBlock10, mergeProps as mergeProps9, renderSlot as renderSlot14, normalizeProps as normalizeProps8, createVNode as createVNode8, withCtx as withCtx9, createTextVNode as createTextVNode5, toDisplayString as toDisplayString6, createCommentVNode as createCommentVNode10 } from "vue";
import "D:/Desktop/forntend/Front_End_Web_Hotel_Nhom_2/my-nuxt-app/node_modules/vuestic-ui/dist/es/VaAvatarGroup.css";
var VaAvatarProps = extractComponentProps(VaAvatar);
var _sfc_main19 = defineComponent19({
  ...{
    name: "VaAvatarGroup"
  },
  __name: "VaAvatarGroup",
  props: {
    ...useSizeProps,
    ...useComponentPresetProp,
    ...VaAvatarProps,
    max: {
      type: [Number, String],
      default: 0
    },
    vertical: {
      type: Boolean,
      default: false
    },
    options: {
      type: Array,
      default: () => []
    },
    /** If there are more avatars that can be displayed we show rest number. This prop changes color of rest indicator. */
    restColor: {
      type: String,
      default: "secondary"
    }
  },
  setup(__props) {
    const props = __props;
    const maxComputed = useNumericProp("max");
    const classComputed = useBem("va-avatar-group", () => ({
      ...pick(props, ["vertical"])
    }));
    const maxOptions = computed58(() => maxComputed.value && maxComputed.value <= props.options.length ? props.options.slice(0, maxComputed.value) : props.options);
    const restOptionsCount = computed58(() => {
      const hasOptions = props.options.length > 0;
      const canAddMoreOptions = maxOptions.value.length < props.options.length;
      const remainingOptions = props.options.length - (maxComputed.value || 0);
      return hasOptions && canAddMoreOptions ? remainingOptions : 0;
    });
    const { sizeComputed, fontSizeComputed } = useSize(props, "VaAvatarGroup");
    const filteredAvatarProps = filterComponentProps(VaAvatarProps);
    const avatarProps = computed58(() => ({
      ...filteredAvatarProps.value,
      fontSize: fontSizeComputed.value,
      size: sizeComputed.value
    }));
    return (_ctx, _cache) => {
      return openBlock18(), createElementBlock16("div", {
        class: normalizeClass9(["va-avatar-group", unref17(classComputed)]),
        role: "list"
      }, [
        (openBlock18(true), createElementBlock16(Fragment5, null, renderList2(maxOptions.value, (option, idx) => {
          return openBlock18(), createBlock10(unref17(VaAvatar), mergeProps9({ key: idx }, { ...avatarProps.value, ...option }, { role: "listitem" }), null, 16);
        }), 128)),
        restOptionsCount.value > 0 ? renderSlot14(_ctx.$slots, "rest", normalizeProps8(mergeProps9({ key: 0 }, avatarProps.value)), () => [
          createVNode8(unref17(VaAvatar), mergeProps9(avatarProps.value, {
            color: __props.restColor,
            class: "va-avatar-group__rest",
            role: "listitem"
          }), {
            default: withCtx9(() => [
              createTextVNode5(" +" + toDisplayString6(restOptionsCount.value), 1)
            ]),
            _: 1
          }, 16, ["color"])
        ]) : createCommentVNode10("", true)
      ], 2);
    };
  }
});

// node_modules/vuestic-ui/dist/es/src/components/va-avatar-group/index.js
var VaAvatarGroup = withConfigTransport$1(_sfc_main19);

// node_modules/vuestic-ui/dist/es/src/components/va-backtop/VaBacktop.vue_vue_type_script_setup_true_lang.js
import { defineComponent as defineComponent20, ref as ref21, computed as computed59, onMounted as onMounted16, onBeforeUnmount as onBeforeUnmount14, openBlock as openBlock19, createElementBlock as createElementBlock17, unref as unref18, normalizeStyle as normalizeStyle11, withKeys as withKeys4, withModifiers as withModifiers2, renderSlot as renderSlot15, createVNode as createVNode9, createCommentVNode as createCommentVNode11 } from "vue";
import "D:/Desktop/forntend/Front_End_Web_Hotel_Nhom_2/my-nuxt-app/node_modules/vuestic-ui/dist/es/VaBacktop.css";
var _hoisted_111 = ["aria-label", "onKeydown"];
var _sfc_main20 = defineComponent20({
  ...{
    name: "VaBacktop"
  },
  __name: "VaBacktop",
  props: {
    ...useComponentPresetProp,
    target: {
      type: [Object, String],
      default: void 0
    },
    visibilityHeight: { type: [Number, String], default: 300 },
    speed: { type: [Number, String], default: 50 },
    verticalOffset: { type: String, default: "1rem" },
    horizontalOffset: { type: String, default: "1rem" },
    color: { type: String, default: "" },
    horizontalPosition: {
      type: String,
      default: "right",
      validator: (value) => ["right", "left"].includes(value)
    },
    verticalPosition: {
      type: String,
      default: "bottom",
      validator: (value) => ["bottom", "top"].includes(value)
    },
    ariaLabel: useTranslationProp("$t:backToTop")
  },
  setup(__props) {
    const props = __props;
    const targetScrollValue = ref21(0);
    const computedStyle = computed59(() => ({
      [props.verticalPosition]: props.verticalOffset,
      [props.horizontalPosition]: props.horizontalOffset
    }));
    let targetElement;
    const visibilityHeightComputed = useNumericProp("visibilityHeight");
    const speedComputed = useNumericProp("speed");
    const getTargetElement2 = () => {
      if (!props.target) {
        return window;
      }
      if (typeof props.target === "string") {
        const target = document.querySelector(props.target);
        if (!target) {
          warn(`Target element [${props.target}] is not found, falling back to window.`);
          return window;
        }
        return target;
      }
      return props.target;
    };
    const scrolled = ref21(false);
    const interval = ref21(0);
    const scrollToTop = () => {
      if (scrolled.value) {
        return;
      }
      scrolled.value = true;
      if (targetElement instanceof Window) {
        window.scrollTo({
          top: 0,
          behavior: "smooth"
        });
        return;
      }
      interval.value = window.setInterval(() => {
        if (targetElement instanceof Element) {
          if (targetElement.scrollTop === 0) {
            clearInterval(interval.value);
            scrolled.value = false;
          } else {
            const next = Math.floor(targetElement.scrollTop - speedComputed.value);
            targetElement.scrollTo(0, next);
          }
        }
      }, 15);
    };
    const handleScroll = () => {
      targetScrollValue.value = targetElement instanceof Window ? targetElement.scrollY : targetElement.scrollTop;
    };
    const server = isServer();
    const visible = computed59(() => {
      if (server) {
        return false;
      }
      return targetScrollValue.value > visibilityHeightComputed.value;
    });
    if (!server) {
      onMounted16(() => {
        targetElement = getTargetElement2();
        targetElement.addEventListener("scroll", handleScroll, true);
      });
      onBeforeUnmount14(() => targetElement == null ? void 0 : targetElement.removeEventListener("scroll", handleScroll));
    }
    const { tp } = useTranslation();
    return (_ctx, _cache) => {
      return visible.value ? (openBlock19(), createElementBlock17("div", {
        key: 0,
        class: "va-backtop",
        role: "button",
        "aria-label": unref18(tp)(_ctx.$props.ariaLabel),
        tabindex: "1",
        style: normalizeStyle11(computedStyle.value),
        onClick: scrollToTop,
        onKeydown: withKeys4(withModifiers2(scrollToTop, ["stop"]), ["enter"])
      }, [
        renderSlot15(_ctx.$slots, "default", {}, () => [
          createVNode9(unref18(VaButton), {
            "aria-hidden": "true",
            icon: "va-arrow-up",
            color: __props.color
          }, null, 8, ["color"])
        ])
      ], 44, _hoisted_111)) : createCommentVNode11("", true);
    };
  }
});

// node_modules/vuestic-ui/dist/es/src/components/va-backtop/index.js
var VaBacktop = withConfigTransport$1(_sfc_main20);

// node_modules/vuestic-ui/dist/es/src/components/va-badge/VaBadge.vue_vue_type_script_setup_true_lang.js
import { defineComponent as defineComponent21, useSlots as useSlots2, computed as computed62, unref as unref21, openBlock as openBlock20, createElementBlock as createElementBlock18, normalizeClass as normalizeClass10, createElementVNode as createElementVNode9, normalizeStyle as normalizeStyle12, renderSlot as renderSlot16, createTextVNode as createTextVNode6, toDisplayString as toDisplayString7 } from "vue";

// node_modules/vuestic-ui/dist/es/src/components/va-badge/hooks/useFloatingPositionStyles.js
import { computed as computed61 } from "vue";

// node_modules/vuestic-ui/dist/es/src/composables/usePlacementAliases.js
import { computed as computed60 } from "vue";
var verticalPlacement = ["top", "bottom"];
var horizontalPlacement = ["left", "right"];
var placementPosition = [...verticalPlacement, ...horizontalPlacement];
var placementAlignment = ["start", "end", "center"];
var placementsPositions = placementPosition.reduce((acc, position) => {
  acc.push(position);
  placementAlignment.forEach((alignment) => acc.push(`${position}-${alignment}`));
  return acc;
}, ["auto"]);
var placementAliasesPositions = verticalPlacement.reduce((acc, yPosition) => {
  horizontalPlacement.forEach((xPosition) => {
    acc.push(`${yPosition}-${xPosition}`);
    acc.push(`${xPosition}-${yPosition}`);
  });
  return acc;
}, []);
var placementsPositionsWithAliases = [...placementsPositions, ...placementAliasesPositions];
var aliasToPlacement = {
  "top-left": "top-start",
  "left-top": "top-start",
  "top-right": "top-end",
  "right-top": "top-end",
  "bottom-left": "bottom-start",
  "left-bottom": "bottom-start",
  "bottom-right": "bottom-end",
  "right-bottom": "bottom-end"
};
var usePlacementAliasesProps = {
  placement: {
    type: String,
    default: "auto",
    validator: (position) => placementsPositionsWithAliases.includes(position)
  }
};
var usePlacementAliases = (props) => {
  const placementArray = computed60(() => {
    const placement = aliasToPlacement[props.placement] || props.placement;
    return placement.split("-");
  });
  const position = computed60(() => {
    const position2 = placementArray.value[0];
    return position2 === "auto" ? "bottom" : position2;
  });
  const align = computed60(() => {
    return placementArray.value[1] || "center";
  });
  return { position, align };
};

// node_modules/vuestic-ui/dist/es/src/composables/useParsableMeasure.js
import { unref as unref19 } from "vue";
var useParsableMeasure = () => {
  const isParsableMeasure2 = (value) => {
    if (typeof value === "string") {
      return !isNaN(+value) || value.endsWith("px") || value.endsWith("rem");
    }
    return false;
  };
  const isParsablePositiveMeasure2 = (value) => {
    if (typeof value === "number") {
      return value >= 0;
    }
    return isParsableMeasure2(value) && parseInt(value) >= 0;
  };
  const parseSizeValue3 = (value, pageFontSize = 16) => {
    const valueUnref = unref19(value);
    if (typeof valueUnref === "string") {
      const parsedValue = parseInt(valueUnref);
      if (isNaN(parsedValue)) {
        return 0;
      }
      return valueUnref.endsWith("rem") ? parsedValue * unref19(pageFontSize) : parsedValue;
    }
    return valueUnref;
  };
  return { isParsableMeasure: isParsableMeasure2, isParsablePositiveMeasure: isParsablePositiveMeasure2, parseSizeValue: parseSizeValue3 };
};

// node_modules/vuestic-ui/dist/es/src/components/va-badge/hooks/useFloatingPositionStyles.js
var { isParsableMeasure, parseSizeValue } = useParsableMeasure();
var useFloatingPositionProps = {
  overlap: { type: Boolean, default: false },
  placement: {
    type: String,
    default: "top-end",
    validator: (position) => placementsPositionsWithAliases.includes(position)
  },
  offset: {
    type: [Number, String, Array],
    default: 0,
    validator: (value) => {
      if (Array.isArray(value)) {
        return value.every(isParsableMeasure);
      }
      if (typeof value === "string") {
        return isParsableMeasure(value);
      }
      return !isNaN(value);
    }
  }
};
var useFloatingPosition = (props, floating) => {
  if (!floating.value) {
    return {};
  }
  const { position, align } = usePlacementAliases(props);
  const alignmentShiftComputed = computed61(() => {
    const alignOptions = {
      start: props.overlap ? "-50%" : "-100%",
      center: "-50%",
      end: props.overlap ? "-50%" : "0%"
    };
    return alignOptions[align.value];
  });
  const offsetMarginComputed = computed61(() => {
    if (!props.offset) {
      return {};
    }
    const mainAxis = ["left", "right"].includes(position.value) ? "top" : "left";
    const crossAxis = mainAxis === "top" ? "left" : "top";
    if (Array.isArray(props.offset)) {
      const [x, y] = props.offset.map(parseSizeValue);
      return {
        [`margin-${mainAxis}`]: `${x}px`,
        [`margin-${crossAxis}`]: `${y}px`
      };
    }
    const offset2 = parseSizeValue(props.offset);
    return {
      [`margin-${crossAxis}`]: `${offset2}px`
    };
  });
  const alignmentComputed = computed61(() => {
    const mainAxis = ["left", "right"].includes(position.value) ? "top" : "left";
    const crossAxis = mainAxis === "top" ? "left" : "top";
    let shiftValue = "0%";
    if (crossAxis === "top" && position.value === "bottom") {
      shiftValue = "100%";
    }
    if (crossAxis === "left" && position.value === "right") {
      shiftValue = "100%";
    }
    const alignmentOptions = {
      start: { [mainAxis]: "0%", [crossAxis]: shiftValue },
      center: { [mainAxis]: "50%", [crossAxis]: shiftValue },
      end: { [mainAxis]: "100%", [crossAxis]: shiftValue }
    };
    return alignmentOptions[align.value];
  });
  const transformComputed = computed61(() => {
    const coords = {
      top: {
        x: alignmentShiftComputed.value,
        y: props.overlap ? "-50%" : "-100%"
      },
      bottom: {
        x: alignmentShiftComputed.value,
        y: props.overlap ? "-50%" : "0%"
      },
      left: {
        x: props.overlap ? "-50%" : "-100%",
        y: alignmentShiftComputed.value
      },
      right: {
        x: props.overlap ? "-50%" : "0%",
        y: alignmentShiftComputed.value
      }
    };
    const { x, y } = coords[position.value];
    return { transform: `translate(${x}, ${y})` };
  });
  return computed61(() => ({
    ...alignmentComputed.value,
    ...transformComputed.value,
    ...offsetMarginComputed.value
  }));
};

// node_modules/vuestic-ui/dist/es/src/composables/useDeprecated.js
import { getCurrentInstance as getCurrentInstance23, unref as unref20 } from "vue";
var OPTIONS_LIST = {
  props: "prop",
  attrs: "prop",
  slots: "slot"
};
var useDeprecated = (deprecatedList, deprecationSource = ["props", "attrs"]) => {
  if (!isDev) {
    return void 0;
  }
  const instance = getCurrentInstance23();
  if (!instance) {
    throw new Error("`useDeprecated` hook must be used only inside of setup function!");
  }
  const instanceName = instance.type.name;
  const deprecatedItems = unref20(deprecatedList);
  deprecationSource.every((source) => {
    var _a2;
    const option = OPTIONS_LIST[source];
    const throwWarning = (key) => console.warn(`The '${key}' ${option} (${instanceName} component) is deprecated! Please, check the documentation.`);
    if (source === "props") {
      const propsOptions = ((_a2 = instance.propsOptions) == null ? void 0 : _a2[0]) || {};
      const propsValues = instance.props || {};
      deprecatedItems.forEach((propName) => {
        propsOptions[propName] && propsValues[propName] !== propsOptions[propName].default && throwWarning(propName);
      });
      return true;
    }
    Object.keys({ ...instance[source] }).forEach((key) => {
      if (deprecatedItems.includes(key)) {
        throwWarning(key);
      }
    });
    return true;
  });
};

// node_modules/vuestic-ui/dist/es/src/components/va-badge/VaBadge.vue_vue_type_script_setup_true_lang.js
import "D:/Desktop/forntend/Front_End_Web_Hotel_Nhom_2/my-nuxt-app/node_modules/vuestic-ui/dist/es/VaBadge.css";
var _hoisted_112 = ["aria-labelledby"];
var _hoisted_25 = { class: "va-badge__text" };
var _sfc_main21 = defineComponent21({
  ...{
    name: "VaBadge"
  },
  __name: "VaBadge",
  props: {
    ...useComponentPresetProp,
    ...useFloatingPositionProps,
    color: { type: String, default: "danger" },
    textColor: { type: String },
    text: { type: [String, Number], default: "" },
    multiLine: { type: Boolean, default: false },
    visibleEmpty: { type: Boolean, default: false },
    dot: { type: Boolean, default: false },
    // TODO: Remove after 1.8.0
    transparent: { type: Boolean, default: false }
  },
  setup(__props) {
    const props = __props;
    useDeprecated(["transparent"]);
    const slots = useSlots2();
    const isEmpty = computed62(() => !(props.text || props.visibleEmpty || props.dot || slots.text));
    const isFloating = computed62(() => !!(slots.default || props.dot));
    const badgeClass = useBem("va-badge", () => ({
      ...pick(props, ["visibleEmpty", "dot", "multiLine"]),
      empty: isEmpty.value,
      floating: isFloating.value
    }));
    const { getColor } = useColors();
    const colorComputed = computed62(() => getColor(props.color));
    const { textColorComputed } = useTextColor(colorComputed);
    const positionStylesComputed = useFloatingPosition(props, isFloating);
    const stylesComputed = computed62(() => ({
      color: textColorComputed.value,
      borderColor: colorComputed.value,
      backgroundColor: colorComputed.value,
      opacity: props.transparent ? 0.5 : 1,
      ...unref21(positionStylesComputed)
    }));
    const ariaLabelledByComputed = computed62(() => props.text ? String(props.text) : void 0);
    return (_ctx, _cache) => {
      return openBlock20(), createElementBlock18("div", {
        class: normalizeClass10(["va-badge", unref21(badgeClass)]),
        role: "status",
        "aria-labelledby": ariaLabelledByComputed.value
      }, [
        createElementVNode9("span", {
          class: "va-badge__text-wrapper",
          style: normalizeStyle12(stylesComputed.value)
        }, [
          createElementVNode9("span", _hoisted_25, [
            renderSlot16(_ctx.$slots, "text", {}, () => [
              createTextVNode6(toDisplayString7(__props.text), 1)
            ])
          ])
        ], 4),
        renderSlot16(_ctx.$slots, "default")
      ], 10, _hoisted_112);
    };
  }
});

// node_modules/vuestic-ui/dist/es/src/components/va-badge/index.js
var VaBadge = withConfigTransport$1(_sfc_main21);

// node_modules/vuestic-ui/dist/es/src/components/va-breadcrumbs/VaBreadcrumbs.vue_vue_type_script_lang.js
import { defineComponent as defineComponent22, computed as computed64, ref as ref22, h as h7, Fragment as Fragment6 } from "vue";

// node_modules/vuestic-ui/dist/es/src/utils/has-own-property.js
var hasOwnProperty = (object, key) => {
  return Object.prototype.hasOwnProperty.call(object, key);
};

// node_modules/vuestic-ui/dist/es/src/utils/resolveSlot.js
var resolveSlot = (slot) => {
  return slot && typeof slot === "function" ? slot() : slot;
};

// node_modules/vuestic-ui/dist/es/src/composables/useAlign.js
import { computed as computed63 } from "vue";
var useAlignProps = {
  align: {
    type: String,
    default: "left"
  },
  vertical: {
    type: Boolean,
    default: false
  }
};
var horizontalMap = {
  left: "flex-start",
  center: "center",
  right: "flex-end",
  between: "space-between",
  around: "space-around"
};
var verticalMap = {
  left: "flex-start",
  center: "center",
  right: "flex-end",
  stretch: "stretch"
};
var justify = (align, vertical) => {
  return vertical ? "center" : align ? horizontalMap[align] : "flex-start";
};
var items = (align, vertical) => {
  return vertical ? verticalMap[align] : "center";
};
function useAlign(props) {
  const alignComputed = computed63(() => {
    return {
      display: "flex",
      flexDirection: props.vertical ? "column" : "row",
      justifyContent: justify(props.align, props.vertical),
      alignItems: items(props.align, props.vertical)
    };
  });
  return {
    alignComputed
  };
}

// node_modules/vuestic-ui/dist/es/src/components/va-breadcrumbs/VaBreadcrumbs.vue_vue_type_script_lang.js
import "D:/Desktop/forntend/Front_End_Web_Hotel_Nhom_2/my-nuxt-app/node_modules/vuestic-ui/dist/es/VaBreadcrumbs.css";
var _sfc_main22 = defineComponent22({
  name: "VaBreadcrumbs",
  props: {
    ...useAlignProps,
    ...useComponentPresetProp,
    separator: { type: String, default: "/" },
    color: { type: String, default: null },
    disabledColor: { type: String, default: "secondary" },
    activeColor: { type: String, default: null },
    separatorColor: { type: String, default: null },
    ariaLabel: useTranslationProp("$t:breadcrumbs")
  },
  setup(props, { slots }) {
    const { alignComputed } = useAlign(props);
    const { getColor } = useColors();
    const computedThemesSeparatorColor = computed64(() => {
      return props.separatorColor ? getColor(props.separatorColor) : null;
    });
    const computedThemesColor = computed64(() => props.color ? getColor(props.color) : null);
    const computedThemesActiveColor = computed64(() => {
      return props.activeColor ? getColor(props.activeColor) : null;
    });
    const childNodeFilter = (result, node) => {
      const nodes = node && node.type === Fragment6 && node.children ? node.children : [node];
      return [
        ...result,
        ...nodes.filter((node2) => {
          var _a2, _b;
          return !!((_b = (_a2 = node2 == null ? void 0 : node2.type) == null ? void 0 : _a2.name) == null ? void 0 : _b.match(/VaBreadcrumbsItem$/));
        })
      ];
    };
    const createSeparatorComponent = () => {
      const separatorNode = resolveSlot(slots.separator) || [props.separator];
      return h7("span", {
        "aria-hidden": true,
        class: ["va-breadcrumbs__separator"],
        style: [{ color: computedThemesSeparatorColor.value }]
      }, separatorNode);
    };
    const isDisabledChild = (child) => {
      const childPropData = child == null ? void 0 : child.props;
      if (!childPropData || !hasOwnProperty(childPropData, "disabled")) {
        return false;
      }
      if (childPropData.disabled === "") {
        return true;
      }
      return Boolean(childPropData.disabled);
    };
    const isAllChildLinks = ref22(true);
    const getChildren = () => {
      const defaultSlotContent = resolveSlot(slots.default);
      if (!defaultSlotContent) {
        return;
      }
      const childNodes = defaultSlotContent.reduce(childNodeFilter, []) || [];
      const childNodesLength = childNodes.length;
      const isLastIndexChildNodes = (index) => index === childNodesLength - 1;
      const isChildLink = (child) => {
        const childPropData = child == null ? void 0 : child.props;
        if (!childPropData || !hasOwnProperty(childPropData, "to")) {
          return false;
        }
        return !!(childPropData.to && !childPropData.disabled);
      };
      const createChildComponent = (child, index) => h7(
        "span",
        {
          class: ["va-breadcrumbs__item", { "va-breadcrumbs__item--disabled": isDisabledChild(child) }],
          "aria-current": isLastIndexChildNodes(index) && isChildLink(child) ? "location" : false,
          style: {
            color: isDisabledChild(child) ? getColor(props.disabledColor) : isLastIndexChildNodes(index) ? computedThemesActiveColor.value : computedThemesColor.value
          }
        },
        [child]
      );
      const children = [];
      if (childNodesLength) {
        childNodes.forEach((child, index) => {
          if (isAllChildLinks.value && !isChildLink(child)) {
            isAllChildLinks.value = false;
          }
          children.push(createChildComponent(child, index));
          if (!isLastIndexChildNodes(index)) {
            children.push(createSeparatorComponent());
          }
        });
      }
      return children;
    };
    const { tp } = useTranslation();
    return () => h7("div", {
      class: "va-breadcrumbs",
      style: alignComputed.value,
      role: isAllChildLinks.value ? "navigation" : void 0,
      "aria-label": isAllChildLinks.value ? tp(props.ariaLabel) : void 0
    }, getChildren());
  }
});

// node_modules/vuestic-ui/dist/es/src/components/va-breadcrumbs/VaBreadcrumbsItem/VaBreadcrumbsItem.vue_vue_type_script_setup_true_lang.js
import { defineComponent as defineComponent23, computed as computed65, openBlock as openBlock21, createBlock as createBlock11, resolveDynamicComponent as resolveDynamicComponent3, unref as unref22, normalizeClass as normalizeClass11, withCtx as withCtx10, renderSlot as renderSlot17, createTextVNode as createTextVNode7, toDisplayString as toDisplayString8 } from "vue";
import "D:/Desktop/forntend/Front_End_Web_Hotel_Nhom_2/my-nuxt-app/node_modules/vuestic-ui/dist/es/VaBreadcrumbsItem.css";
var _sfc_main23 = defineComponent23({
  ...{
    name: "VaBreadcrumbsItem"
  },
  __name: "VaBreadcrumbsItem",
  props: {
    ...useRouterLinkProps,
    disabled: { type: Boolean, default: false },
    label: { type: String, default: "" }
  },
  setup(__props) {
    const props = __props;
    const { tagComputed, hrefComputed, isLinkTag } = useRouterLink(props);
    const classComputed = computed65(() => ({
      "va-breadcrumb-item--link": isLinkTag.value
    }));
    return (_ctx, _cache) => {
      return openBlock21(), createBlock11(resolveDynamicComponent3(unref22(tagComputed)), {
        class: normalizeClass11(["va-breadcrumb-item", classComputed.value]),
        "active-class": _ctx.$props.activeClass,
        href: unref22(hrefComputed),
        to: _ctx.$props.to,
        target: _ctx.$props.target,
        replace: _ctx.$props.replace,
        append: _ctx.$props.append,
        exact: _ctx.$props.exact,
        "exact-active-class": _ctx.$props.exactActiveClass
      }, {
        default: withCtx10(() => [
          renderSlot17(_ctx.$slots, "default", {}, () => [
            createTextVNode7(toDisplayString8(__props.label), 1)
          ])
        ]),
        _: 3
      }, 8, ["class", "active-class", "href", "to", "target", "replace", "append", "exact", "exact-active-class"]);
    };
  }
});

// node_modules/vuestic-ui/dist/es/src/components/va-breadcrumbs/index.js
var VaBreadcrumbsItem = withConfigTransport$1(_sfc_main23);
var VaBreadcrumbs = withConfigTransport$1(_sfc_main22);

// node_modules/vuestic-ui/dist/es/src/components/va-button-dropdown/VaButtonDropdown.vue_vue_type_script_setup_true_lang.js
import { defineComponent as defineComponent27, computed as computed75, useSlots as useSlots3, openBlock as openBlock24, createBlock as createBlock12, unref as unref27, mergeProps as mergeProps10, isRef as isRef4, withCtx as withCtx12, createVNode as createVNode11, toHandlers, renderSlot as renderSlot20, createTextVNode as createTextVNode8, toDisplayString as toDisplayString9, createCommentVNode as createCommentVNode12, withKeys as withKeys5, withModifiers as withModifiers3 } from "vue";

// node_modules/vuestic-ui/dist/es/src/components/va-button-group/VaButtonGroup.vue_vue_type_script_setup_true_lang.js
import { defineComponent as defineComponent24, computed as computed66, openBlock as openBlock22, createElementBlock as createElementBlock19, normalizeClass as normalizeClass12, unref as unref23, normalizeStyle as normalizeStyle13, createVNode as createVNode10, withCtx as withCtx11, renderSlot as renderSlot18 } from "vue";
import "D:/Desktop/forntend/Front_End_Web_Hotel_Nhom_2/my-nuxt-app/node_modules/vuestic-ui/dist/es/VaButtonGroup.css";
var VaButtonProps = omit(extractComponentProps(VaButton), ["block", "gradient"]);
var _sfc_main24 = defineComponent24({
  ...{
    name: "VaButtonGroup"
  },
  __name: "VaButtonGroup",
  props: {
    ...VaButtonProps,
    ...useComponentPresetProp,
    grow: { type: Boolean, default: false },
    gradient: { type: Boolean, default: false }
  },
  setup(__props) {
    const props = __props;
    const { getColor, getGradientBackground: getGradientBackground2 } = useColors();
    const colorComputed = computed66(() => getColor(props.color));
    const { textColorComputed } = useTextColor(colorComputed);
    const filteredProps = filterComponentProps(VaButtonProps);
    const buttonConfig = computed66(() => ({
      VaButton: {
        ...filteredProps.value,
        ...props.gradient && {
          color: "#00000000",
          textColor: textColorComputed.value
        }
      }
    }));
    const computedClass = useBem("va-button-group", () => ({
      square: !props.round,
      grow: props.grow,
      small: props.size === "small",
      large: props.size === "large"
    }));
    const backgroundColor = computed66(
      () => props.gradient ? getGradientBackground2(colorComputed.value) : "transparent"
    );
    return (_ctx, _cache) => {
      return openBlock22(), createElementBlock19("div", {
        class: normalizeClass12(["va-button-group", unref23(computedClass)]),
        style: normalizeStyle13(`--va-background-color: ${String(backgroundColor.value)}`)
      }, [
        createVNode10(unref23(_sfc_main4), { components: buttonConfig.value }, {
          default: withCtx11(() => [
            renderSlot18(_ctx.$slots, "default")
          ]),
          _: 3
        }, 8, ["components"])
      ], 6);
    };
  }
});

// node_modules/vuestic-ui/dist/es/src/components/va-button-group/index.js
var VaButtonGroup = withConfigTransport$1(_sfc_main24);

// node_modules/vuestic-ui/dist/es/src/components/va-dropdown/VaDropdown.vue_vue_type_script_lang.js
import { defineComponent as defineComponent25, watch as watch18, computed as computed73, ref as ref26, nextTick as nextTick6, h as h8, Teleport as Teleport3, Fragment as Fragment7 } from "vue";

// node_modules/vuestic-ui/dist/es/src/components/va-dropdown/hooks/useDropdownNavigation.js
import { computed as computed67 } from "vue";

// node_modules/vuestic-ui/dist/es/src/composables/useDebounce.js
import { isRef as isRef3, watch as watch16, unref as unref24 } from "vue";

// node_modules/vuestic-ui/dist/es/src/utils/debounce.js
var debounce = (func, wait) => {
  let timeout = null;
  const fn = function(...args) {
    timeout && clearTimeout(timeout);
    timeout = setTimeout(() => {
      timeout = null;
      func.apply(this, args);
    }, wait);
  };
  fn.cancel = () => {
    timeout && clearTimeout(timeout);
    timeout = null;
  };
  return fn;
};

// node_modules/vuestic-ui/dist/es/src/composables/useDebounce.js
var useDebounceFn = (timeout) => {
  let callback = null;
  const createDebounced = () => {
    return debounce(() => {
      callback == null ? void 0 : callback();
      callback = null;
    }, unref24(timeout));
  };
  let debounced = createDebounced();
  if (isRef3(timeout)) {
    watch16(timeout, () => {
      debounced = createDebounced();
    });
  }
  return {
    // todo check if we need to create proxy here
    debounced: (cb) => {
      callback = cb;
      debounced();
    },
    cancel: () => debounced.cancel()
  };
};

// node_modules/vuestic-ui/dist/es/src/components/va-dropdown/hooks/useDropdownNavigation.js
var isTyping = (e) => {
  const target = e.target;
  if (!(target.tagName === "INPUT" || target.tagName === "TEXTAREA")) {
    return false;
  }
  if (target.attributes.getNamedItem("readonly")) {
    return false;
  }
  return true;
};
var isReadonlyArray = (arr) => {
  return Array.isArray(arr);
};
var useNavigation = (isOpen, anchorRef, contentRef, props) => {
  const normalizeTriggerName = (t) => {
    t = t.replace(/-/g, "").toLowerCase();
    if (t === "space") {
      return " ";
    }
    if (t === "rightclick") {
      return "contextmenu";
    }
    return t;
  };
  const normalizedTriggers = computed67(() => {
    if (isReadonlyArray(props.trigger)) {
      return props.trigger.map((t) => normalizeTriggerName(t));
    }
    return [normalizeTriggerName(props.trigger)];
  });
  useEvent("keydown", (e) => {
    if (props.disabled) {
      return;
    }
    if (e.key === "Escape" && isOpen.value) {
      isOpen.value = false;
      e.preventDefault();
    }
    if (isTyping(e)) {
      return;
    }
    if (normalizedTriggers.value.includes(normalizeTriggerName(e.key))) {
      isOpen.value = !isOpen.value;
      e.preventDefault();
    }
  }, anchorRef);
  useEvent("keydown", (e) => {
    if (props.disabled) {
      return;
    }
    if (e.key === "Escape" && isOpen.value) {
      isOpen.value = false;
      e.preventDefault();
    }
  }, contentRef);
  useEvent(["click", "contextmenu", "dblclick"], (e) => {
    if (props.disabled) {
      return;
    }
    if (isTyping(e)) {
      return;
    }
    if (normalizedTriggers.value.includes(normalizeTriggerName(e.type))) {
      e.preventDefault();
      if (isOpen.value && props.closeOnAnchorClick) {
        isOpen.value = false;
        if (props.cursor) {
          setTimeout(() => {
            isOpen.value = true;
          }, 16);
        }
      } else {
        isOpen.value = true;
      }
    }
  }, anchorRef);
  useEvent(["click", "contextmenu", "dblclick"], (e) => {
    if (props.closeOnContentClick) {
      isOpen.value = false;
    }
  }, contentRef);
  const { debounced: debounceHover, cancel: cancelHoverDebounce } = useDebounceFn(useNumericProp("hoverOverTimeout"));
  const { debounced: debounceUnHover, cancel: cancelUnHoverDebounce } = useDebounceFn(useNumericProp("hoverOutTimeout"));
  const onMouseHover = (e) => {
    if (props.disabled) {
      return;
    }
    if (!normalizedTriggers.value.includes("hover")) {
      return;
    }
    if (e.type === "mouseleave") {
      cancelHoverDebounce();
      if (!props.isContentHoverable) {
        isOpen.value = false;
        return;
      }
      debounceUnHover(() => {
        isOpen.value = false;
      });
    } else {
      cancelUnHoverDebounce();
      debounceHover(() => {
        isOpen.value = true;
      });
    }
  };
  useEvent(["mouseleave", "mouseenter"], onMouseHover, anchorRef);
  useEvent(["mouseleave", "mouseenter"], onMouseHover, contentRef);
};

// node_modules/vuestic-ui/dist/es/src/components/va-dropdown/hooks/useAnchorSelector.js
import { ref as ref23, computed as computed68 } from "vue";
var useAnchorSelector = (props) => {
  const anchorRef = ref23();
  const document2 = useDocument();
  const isMounted = useIsMounted();
  const computedAnchorRef = computed68({
    set(v) {
      anchorRef.value = unwrapEl(v);
    },
    get() {
      var _a2, _b, _c;
      isMounted.value;
      if (typeof props.anchor === "string") {
        return ((_a2 = document2.value) == null ? void 0 : _a2.querySelector(props.anchor)) ?? anchorRef.value;
      }
      if (typeof props.anchor === "object") {
        return props.anchor;
      }
      if (props.anchorSelector) {
        return ((_b = document2.value) == null ? void 0 : _b.querySelector(props.anchorSelector)) ?? anchorRef.value;
      } else if (props.innerAnchorSelector && anchorRef.value) {
        return ((_c = anchorRef.value) == null ? void 0 : _c.querySelector(props.innerAnchorSelector)) ?? anchorRef.value;
      }
      return anchorRef.value;
    }
  });
  return {
    anchorRef: computedAnchorRef
  };
};

// node_modules/vuestic-ui/dist/es/src/components/va-dropdown/hooks/useCursorAnchor.js
import { reactive as reactive4, computed as computed69 } from "vue";
var useCursorAnchor = (anchorRef, enabled) => {
  const position = reactive4({ x: 0, y: 0 });
  useEvent(["mousemove", "mousedown", "mouseup"], (e) => {
    var _a2;
    if (!enabled.value) {
      return;
    }
    const { x, y } = ((_a2 = anchorRef.value) == null ? void 0 : _a2.getBoundingClientRect()) ?? { x: 0, y: 0 };
    position.x = e.clientX - x;
    position.y = e.clientY - y;
  }, anchorRef);
  return computed69(() => {
    return {
      getBoundingClientRect() {
        var _a2;
        const { x, y } = ((_a2 = anchorRef.value) == null ? void 0 : _a2.getBoundingClientRect()) ?? { x: 0, y: 0 };
        const resX = position.x + x;
        const resY = position.y + y;
        return {
          width: 0,
          height: 0,
          x: resX,
          y: resY,
          top: resY,
          right: resX,
          bottom: resY,
          left: resX
        };
      },
      contextElement: anchorRef.value
    };
  });
};

// node_modules/vuestic-ui/dist/es/src/components/va-dropdown/hooks/useDropdown.js
import { computed as computed71, ref as ref25 } from "vue";

// node_modules/@floating-ui/vue/dist/floating-ui.vue.mjs
import { unref as unref25, computed as computed70, ref as ref24, shallowRef as shallowRef9, watch as watch17, getCurrentScope, onScopeDispose, shallowReadonly as shallowReadonly2 } from "vue-demi";
function isComponentPublicInstance(target) {
  return target != null && typeof target === "object" && "$el" in target;
}
function unwrapElement(target) {
  if (isComponentPublicInstance(target)) {
    const element = target.$el;
    return isNode(element) && getNodeName(element) === "#comment" ? null : element;
  }
  return target;
}
function toValue(source) {
  return typeof source === "function" ? source() : unref25(source);
}
function getDPR(element) {
  if (typeof window === "undefined") {
    return 1;
  }
  const win = element.ownerDocument.defaultView || window;
  return win.devicePixelRatio || 1;
}
function roundByDPR(element, value) {
  const dpr = getDPR(element);
  return Math.round(value * dpr) / dpr;
}
function useFloating(reference, floating, options) {
  if (options === void 0) {
    options = {};
  }
  const whileElementsMountedOption = options.whileElementsMounted;
  const openOption = computed70(() => {
    var _toValue;
    return (_toValue = toValue(options.open)) != null ? _toValue : true;
  });
  const middlewareOption = computed70(() => toValue(options.middleware));
  const placementOption = computed70(() => {
    var _toValue2;
    return (_toValue2 = toValue(options.placement)) != null ? _toValue2 : "bottom";
  });
  const strategyOption = computed70(() => {
    var _toValue3;
    return (_toValue3 = toValue(options.strategy)) != null ? _toValue3 : "absolute";
  });
  const transformOption = computed70(() => {
    var _toValue4;
    return (_toValue4 = toValue(options.transform)) != null ? _toValue4 : true;
  });
  const referenceElement = computed70(() => unwrapElement(reference.value));
  const floatingElement = computed70(() => unwrapElement(floating.value));
  const x = ref24(0);
  const y = ref24(0);
  const strategy = ref24(strategyOption.value);
  const placement = ref24(placementOption.value);
  const middlewareData = shallowRef9({});
  const isPositioned = ref24(false);
  const floatingStyles = computed70(() => {
    const initialStyles = {
      position: strategy.value,
      left: "0",
      top: "0"
    };
    if (!floatingElement.value) {
      return initialStyles;
    }
    const xVal = roundByDPR(floatingElement.value, x.value);
    const yVal = roundByDPR(floatingElement.value, y.value);
    if (transformOption.value) {
      return {
        ...initialStyles,
        transform: "translate(" + xVal + "px, " + yVal + "px)",
        ...getDPR(floatingElement.value) >= 1.5 && {
          willChange: "transform"
        }
      };
    }
    return {
      position: strategy.value,
      left: xVal + "px",
      top: yVal + "px"
    };
  });
  let whileElementsMountedCleanup;
  function update() {
    if (referenceElement.value == null || floatingElement.value == null) {
      return;
    }
    const open = openOption.value;
    computePosition(referenceElement.value, floatingElement.value, {
      middleware: middlewareOption.value,
      placement: placementOption.value,
      strategy: strategyOption.value
    }).then((position) => {
      x.value = position.x;
      y.value = position.y;
      strategy.value = position.strategy;
      placement.value = position.placement;
      middlewareData.value = position.middlewareData;
      isPositioned.value = open !== false;
    });
  }
  function cleanup() {
    if (typeof whileElementsMountedCleanup === "function") {
      whileElementsMountedCleanup();
      whileElementsMountedCleanup = void 0;
    }
  }
  function attach() {
    cleanup();
    if (whileElementsMountedOption === void 0) {
      update();
      return;
    }
    if (referenceElement.value != null && floatingElement.value != null) {
      whileElementsMountedCleanup = whileElementsMountedOption(referenceElement.value, floatingElement.value, update);
      return;
    }
  }
  function reset() {
    if (!openOption.value) {
      isPositioned.value = false;
    }
  }
  watch17([middlewareOption, placementOption, strategyOption, openOption], update, {
    flush: "sync"
  });
  watch17([referenceElement, floatingElement], attach, {
    flush: "sync"
  });
  watch17(openOption, reset, {
    flush: "sync"
  });
  if (getCurrentScope()) {
    onScopeDispose(cleanup);
  }
  return {
    x: shallowReadonly2(x),
    y: shallowReadonly2(y),
    strategy: shallowReadonly2(strategy),
    placement: shallowReadonly2(placement),
    middlewareData: shallowReadonly2(middlewareData),
    isPositioned: shallowReadonly2(isPositioned),
    floatingStyles,
    update
  };
}

// node_modules/vuestic-ui/dist/es/src/components/va-dropdown/hooks/useDropdown.js
var useDropdown = (anchorComputed, floating, target, options) => {
  const placementComputed = computed71(() => {
    const { position, align } = usePlacementAliases({ placement: options.value.placement });
    return `${position.value}-${align.value}`;
  });
  const offsetComputed = computed71(() => {
    const dropdownOffset = options.value.offset;
    const result = { mainAxis: 0, crossAxis: 0 };
    if (Array.isArray(dropdownOffset)) {
      result.mainAxis = dropdownOffset[0];
      result.crossAxis = dropdownOffset[1];
    }
    if (typeof dropdownOffset === "number") {
      result.mainAxis = dropdownOffset;
    }
    return result;
  });
  const middlewareComputed = computed71(() => {
    const { autoPlacement: autoPlacement2, stickToEdges, keepAnchorWidth, verticalScrollOnOverflow } = options.value;
    const result = [
      offset(offsetComputed.value)
    ];
    if (autoPlacement2) {
      result.push(
        // boundary doesn't work with ssr (trying to access document)
        flip({
          boundary: target.value
        })
      );
    }
    if (stickToEdges) {
      result.push(
        shift()
      );
    }
    if (keepAnchorWidth || verticalScrollOnOverflow) {
      result.push(size({
        apply({ elements, availableHeight }) {
          if (keepAnchorWidth) {
            const reference = elements.reference;
            const availableWidth = reference.getBoundingClientRect().width;
            Object.assign(elements.floating.style, {
              // Don't set width here, because some plugin applies width 100% and it breaks layout
              maxWidth: `${availableWidth}px`,
              minWidth: `${availableWidth}px`
            });
          }
          if (verticalScrollOnOverflow) {
            Object.assign(elements.floating.style, {
              maxHeight: `${availableHeight}px`
            });
          }
        }
      }));
    }
    return result;
  });
  const { floatingStyles, isPositioned } = typeof document === "undefined" ? { floatingStyles: {}, isPositioned: ref25(false) } : useFloating(anchorComputed, floating, {
    placement: placementComputed,
    whileElementsMounted: autoUpdate,
    middleware: middlewareComputed,
    transform: true
  });
  return {
    // Because floating ui by default set top and left to 0 before position calculated, dropdown jumps to the left top corner
    // If user wants to make focus on el as soon as Dropdown is opened, page will be scrolled on the left top corner
    floatingStyles: computed71(() => {
      if (!isPositioned.value) {
        return {
          position: "fixed"
        };
      }
      return floatingStyles.value;
    }),
    isPositioned
  };
};

// node_modules/vuestic-ui/dist/es/src/composables/useFocusOutside.js
import { unref as unref26 } from "vue";
var checkIfElementChild2 = (parent, child) => {
  if (!child) {
    return false;
  }
  if (child instanceof Window) {
    return false;
  }
  if (child.parentElement === parent) {
    return true;
  }
  return parent.contains(child);
};
var safeArray2 = (a) => Array.isArray(a) ? a : [a];
var useFocusOutside = (elements, cb, options = {}) => {
  let previouslyClicked2 = false;
  if (options.onlyKeyboard) {
    useEvent("mousedown", (e) => {
      previouslyClicked2 = true;
      setTimeout(() => {
        previouslyClicked2 = false;
      }, 200);
    }, true);
  }
  useEvent("focus", (event) => {
    if (options.onlyKeyboard && previouslyClicked2) {
      return;
    }
    const focusTarget = event.target;
    if (event.target.shadowRoot) {
      return;
    }
    const isFocusInside = safeArray2(elements).some((element) => {
      const el = unwrapEl(unref26(element));
      return el && checkIfElementChild2(el, focusTarget);
    });
    if (!isFocusInside) {
      cb(focusTarget);
    }
  }, true);
};

// node_modules/vuestic-ui/dist/es/src/composables/useHTMLElementSelector.js
import { computed as computed72 } from "vue";
var useHTMLElementSelector = (key) => {
  return computed72(() => {
    if (typeof (key == null ? void 0 : key.value) === "string") {
      return document == null ? void 0 : document.querySelector(key.value);
    }
    return unwrapEl(key == null ? void 0 : key.value);
  });
};

// node_modules/vuestic-ui/dist/es/src/components/va-dropdown/VaDropdown.vue_vue_type_script_lang.js
import "D:/Desktop/forntend/Front_End_Web_Hotel_Nhom_2/my-nuxt-app/node_modules/vuestic-ui/dist/es/VaDropdown.css";
var _sfc_main25 = defineComponent25({
  name: "VaDropdown",
  props: {
    ...usePlacementAliasesProps,
    ...createStatefulProps(true),
    modelValue: { type: Boolean, default: false },
    anchor: { type: [String, Object], default: void 0 },
    anchorSelector: { type: String, default: "" },
    innerAnchorSelector: { type: String, default: "" },
    trigger: {
      type: [String, Array],
      default: () => ["click", "space", "enter", "arrow-down", "arrow-up"]
    },
    disabled: { type: Boolean },
    readonly: { type: Boolean },
    closeOnClickOutside: { type: Boolean, default: true },
    closeOnFocusOutside: { type: Boolean, default: true },
    closeOnAnchorClick: { type: Boolean, default: true },
    closeOnContentClick: { type: Boolean, default: true },
    hoverOverTimeout: { type: [Number, String], default: 30 },
    hoverOutTimeout: { type: [Number, String], default: 200 },
    isContentHoverable: { type: Boolean, default: true },
    offset: { type: [Array, Number], default: 0 },
    keepAnchorWidth: { type: Boolean, default: false },
    verticalScrollOnOverflow: { type: Boolean, default: true },
    cursor: { type: [Boolean, Object], default: false },
    autoPlacement: { type: Boolean, default: true },
    stickToEdges: { type: Boolean, default: false },
    /** Viewport where dropdown will be rendered. Autoplacement will be calculated relative to `target` */
    target: { type: [String, Object], default: void 0 },
    /** Element where dropdown content will be rendered. */
    teleport: { type: [String, Object], default: void 0 },
    /** Not reactive */
    keyboardNavigation: { type: Boolean, default: true },
    ariaLabel: useTranslationProp("$t:toggleDropdown"),
    role: { type: String, default: "button" },
    contentClass: { type: String, default: "" }
  },
  emits: [...useStatefulEmits, "anchor-click", "anchor-right-click", "content-click", "click-outside", "focus-outside", "close", "open", "anchor-dblclick"],
  setup(props, { emit }) {
    const { valueComputed } = useStateful(props, emit, "modelValue");
    watch18(valueComputed, (isOpened) => {
      if (isOpened) {
        emit("open");
      } else {
        emit("close");
      }
    });
    const isMounted = useIsMounted();
    const { anchorRef } = useAnchorSelector(props);
    const cursorAnchor = useCursorAnchor(anchorRef, computed73(() => Boolean(props.cursor)));
    const floating = useHTMLElement("floating");
    const body = useHTMLElementSelector(ref26("body"));
    const target = useHTMLElementSelector(computed73(() => props.target));
    const teleport = useHTMLElementSelector(computed73(() => props.teleport));
    const anchorClass = useBem("va-dropdown", () => pick(props, ["disabled"]));
    const teleportTarget = computed73(() => {
      if (teleport.value) {
        return teleport.value;
      }
      if (target.value) {
        return target.value;
      }
      if (anchorRef.value) {
        const root = anchorRef.value.getRootNode();
        if (root instanceof ShadowRoot) {
          const el = [...root.children].find((c) => c.tagName !== "STYLE");
          if (el) {
            return el;
          }
        }
      }
      return body.value;
    });
    const showFloating = computed73(() => isMounted.value && valueComputed.value);
    useNavigation(
      valueComputed,
      anchorRef,
      floating,
      props
    );
    const emitAndClose = (eventName, close, e) => {
      emit(eventName, e);
      if (close) {
        valueComputed.value = false;
      }
    };
    useClickOutside([anchorRef, floating], () => {
      if (props.closeOnClickOutside && valueComputed.value) {
        emitAndClose("click-outside", props.closeOnClickOutside);
      }
    });
    useFocusOutside([floating], () => {
      if (props.closeOnFocusOutside && valueComputed.value) {
        emitAndClose("focus-outside", props.closeOnFocusOutside);
      }
    }, { onlyKeyboard: true });
    const anchorComputed = computed73(() => {
      if (typeof props.cursor === "object") {
        return props.cursor;
      }
      return props.cursor ? cursorAnchor.value : anchorRef.value;
    });
    const { floatingStyles } = useDropdown(
      anchorComputed,
      floating,
      target,
      computed73(() => ({
        placement: props.placement,
        offset: props.offset,
        autoPlacement: props.autoPlacement,
        stickToEdges: props.stickToEdges,
        keepAnchorWidth: props.keepAnchorWidth,
        verticalScrollOnOverflow: props.verticalScrollOnOverflow
      }))
    );
    const hide2 = () => {
      valueComputed.value = false;
    };
    const show = () => {
      valueComputed.value = true;
    };
    const {
      zIndex
    } = useZIndex(valueComputed);
    watch18(valueComputed, (isOpened) => {
      if (!props.keyboardNavigation) {
        return;
      }
      if (isOpened) {
        nextTick6(() => {
          const el = unwrapEl(floating.value);
          if (!el) {
            return;
          }
          focusFirstFocusableChild(el);
        });
      } else {
        if (!anchorRef.value) {
          return;
        }
        focusFirstFocusableChild(anchorRef.value);
      }
    });
    return {
      ...useTranslation(),
      ...useTeleported(),
      anchorRef,
      anchorClass,
      floating,
      floatingStyles,
      showFloating,
      teleportTarget,
      isMounted,
      valueComputed,
      hide: hide2,
      show,
      zIndex
    };
  },
  render() {
    const slotBind = {
      isOpened: this.valueComputed,
      hide: this.hide,
      show: this.show,
      toggle: () => this.valueComputed ? this.hide() : this.show(),
      getAnchorWidth: () => {
        var _a2;
        return ((_a2 = this.anchorRef) == null ? void 0 : _a2.offsetWidth) + "px";
      },
      getAnchorHeight: () => {
        var _a2;
        return ((_a2 = this.anchorRef) == null ? void 0 : _a2.offsetHeight) + "px";
      }
    };
    const floatingSlotNode = this.showFloating && renderSlotNode2(this.$slots.default, slotBind, {
      ref: "floating",
      class: ["va-dropdown__content-wrapper", this.$props.contentClass],
      style: [this.floatingStyles, { zIndex: this.zIndex }],
      ...this.teleportedAttrs
    });
    const anchorSlotVNode = renderSlotNode2(this.$slots.anchor, slotBind, {
      ref: "anchorRef",
      role: this.$props.role,
      class: ["va-dropdown", ...this.anchorClass.asArray.value],
      style: { position: "relative" },
      "aria-label": this.tp(this.$props.ariaLabel),
      "aria-disabled": this.$props.disabled,
      "aria-expanded": this.$props.role && this.$props.role !== "none" ? !!this.showFloating : void 0,
      ...this.teleportFromAttrs,
      ...this.$attrs
    });
    if (typeof this.$props.cursor === "object" && floatingSlotNode) {
      return h8(
        Teleport3,
        {
          to: this.teleportTarget,
          disabled: this.$props.disabled
        },
        [floatingSlotNode]
      );
    }
    if (!this.$props.anchorSelector && !anchorSlotVNode) {
      warn("VaDropdown: #anchor slot is missing");
      return;
    }
    if (this.showFloating && !floatingSlotNode) {
      warn("VaDropdown: default slot is missing");
      return;
    }
    return h8(Fragment7, {}, [
      anchorSlotVNode,
      floatingSlotNode && h8(
        Teleport3,
        {
          to: this.teleportTarget,
          disabled: this.$props.disabled
        },
        [floatingSlotNode]
      )
    ]);
  }
});

// node_modules/vuestic-ui/dist/es/src/components/va-dropdown/index.js
var VaDropdown = withConfigTransport$1(_sfc_main25);

// node_modules/vuestic-ui/dist/es/src/components/va-dropdown/components/VaDropdownContent/VaDropdownContent.vue_vue_type_script_setup_true_lang.js
import { defineComponent as defineComponent26, toRef as toRef6, computed as computed74, openBlock as openBlock23, createElementBlock as createElementBlock20, normalizeStyle as normalizeStyle14, renderSlot as renderSlot19 } from "vue";
import "D:/Desktop/forntend/Front_End_Web_Hotel_Nhom_2/my-nuxt-app/node_modules/vuestic-ui/dist/es/VaDropdownContent.css";
var _sfc_main26 = defineComponent26({
  ...{
    name: "VaDropdownContent"
  },
  __name: "VaDropdownContent",
  props: {
    noPadding: { type: Boolean, default: false },
    background: { type: String, default: "background-secondary" },
    textColor: { type: String }
  },
  setup(__props) {
    const props = __props;
    const { getColor } = useColors();
    const { textColorComputed } = useTextColor(toRef6(props, "background"));
    const computedStyle = computed74(() => ({
      background: getColor(props.background, void 0, true),
      color: textColorComputed.value,
      padding: props.noPadding ? 0 : void 0
    }));
    return (_ctx, _cache) => {
      return openBlock23(), createElementBlock20("div", {
        class: "va-dropdown__content",
        style: normalizeStyle14(computedStyle.value),
        role: "listbox"
      }, [
        renderSlot19(_ctx.$slots, "default")
      ], 4);
    };
  }
});

// node_modules/vuestic-ui/dist/es/src/components/va-dropdown/components/VaDropdownContent/index.js
var VaDropdownContent = withConfigTransport$1(_sfc_main26);

// node_modules/vuestic-ui/dist/es/src/composables/useEmitProxy.js
var getEvent = (event) => typeof event === "object" ? event.listen : event;
var getEmit = (event) => typeof event === "object" ? event.emit : event;
var useEmitProxy = (events) => {
  const createEmits3 = () => events.map(getEmit);
  const eventToListenerName = (event) => {
    const eventName = event.charAt(0).toUpperCase() + event.slice(1);
    return `on${eventName}`;
  };
  const createListeners3 = (emit) => {
    return events.reduce((acc, key) => ({
      ...acc,
      [eventToListenerName(getEvent(key))]: (...args) => emit(getEmit(key), ...args)
    }), {});
  };
  const createVOnListeners = (emit) => {
    return events.reduce((acc, key) => ({
      ...acc,
      [getEvent(key)]: (...args) => emit(getEmit(key), ...args)
    }), {});
  };
  return {
    createListeners: createListeners3,
    createVOnListeners,
    createEmits: createEmits3
  };
};

// node_modules/vuestic-ui/dist/es/src/components/va-button-dropdown/VaButtonDropdown.vue_vue_type_script_setup_true_lang.js
import "D:/Desktop/forntend/Front_End_Web_Hotel_Nhom_2/my-nuxt-app/node_modules/vuestic-ui/dist/es/VaButtonDropdown.css";
var { createEmits, createVOnListeners: createListeners } = useEmitProxy(["click"]);
var { createEmits: createMainButtonEmits, createVOnListeners: createMainButtonListeners } = useEmitProxy(
  [{ listen: "click", emit: "main-button-click" }]
);
var VaButtonProps2 = omit(extractComponentProps(VaButton), ["iconRight", "block"]);
var VaDropdownProps = extractComponentProps(VaDropdown);
var _sfc_main27 = defineComponent27({
  ...{
    name: "VaButtonDropdown"
  },
  __name: "VaButtonDropdown",
  props: {
    ...useComponentPresetProp,
    ...VaButtonProps2,
    ...VaDropdownProps,
    ...useStatefulProps,
    ...usePlacementAliasesProps,
    modelValue: { type: Boolean, default: false },
    stateful: { type: Boolean, default: true },
    icon: { type: String, default: "va-arrow-down" },
    openedIcon: { type: String, default: "va-arrow-up" },
    hideIcon: { type: Boolean, default: false },
    leftIcon: { type: Boolean, default: false },
    iconColor: { type: String, default: "" },
    disabled: { type: Boolean, default: false },
    disableButton: { type: Boolean, default: false },
    disableDropdown: { type: Boolean, default: false },
    offset: { type: [Number, Array], default: 2 },
    keepAnchorWidth: { type: Boolean, default: false },
    closeOnContentClick: { type: Boolean, default: true },
    split: { type: Boolean },
    splitTo: { type: String, default: "" },
    splitHref: { type: String, default: "" },
    loading: { type: Boolean, default: false },
    label: { type: String },
    ariaLabel: useTranslationProp("$t:toggleDropdown")
  },
  emits: ["update:modelValue", ...createEmits(), ...createMainButtonEmits()],
  setup(__props, { expose: __expose, emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const { valueComputed } = useStateful(props, emit);
    const computedIcon = computed75(() => valueComputed.value ? props.openedIcon : props.icon);
    const slots = useSlots3();
    const computedButtonIcons = computed75(() => {
      if (props.hideIcon) {
        return {};
      }
      const propName = (props.label || slots.label) && !props.leftIcon ? "icon-right" : "icon";
      return { [propName]: computedIcon.value };
    });
    const buttonPropsFiltered = computed75(() => {
      const ignoredProps = ["to", "href", "loading", "icon"];
      const presetProps = [
        "plain",
        "textOpacity",
        "backgroundOpacity",
        "hoverOpacity",
        "hoverBehavior",
        "hoverOpacity",
        "pressedOpacity",
        "pressedBehavior",
        "pressedOpacity"
      ];
      if (props.preset) {
        return Object.keys(omit(VaButtonProps2, [...ignoredProps, ...presetProps]));
      }
      return Object.keys(omit(VaButtonProps2, ignoredProps));
    });
    const buttonPropsComputed = computed75(
      () => Object.entries(props).filter(([key, _]) => buttonPropsFiltered.value.includes(key)).reduce((acc, [key, value]) => {
        Object.assign(acc, { [key]: value });
        return acc;
      }, {})
    );
    const computedMainButtonProps = computed75(() => ({
      to: props.splitTo,
      href: props.splitHref,
      loading: props.loading
    }));
    const hideDropdown = () => {
      valueComputed.value = false;
    };
    const vaDropdownProps = filterComponentProps(VaDropdownProps);
    const listeners = createListeners(emit);
    const mainButtonListeners = createMainButtonListeners(emit);
    const { t, tp } = useTranslation();
    __expose({
      hideDropdown
    });
    return (_ctx, _cache) => {
      return !_ctx.$props.split ? (openBlock24(), createBlock12(unref27(VaDropdown), mergeProps10({ key: 0 }, unref27(vaDropdownProps), {
        modelValue: unref27(valueComputed),
        "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => isRef4(valueComputed) ? valueComputed.value = $event : null),
        disabled: _ctx.$props.disabled || _ctx.$props.disableDropdown,
        class: ["va-button-dropdown"]
      }), {
        anchor: withCtx12(() => [
          createVNode11(unref27(VaButton), mergeProps10({
            "aria-label": unref27(tp)(_ctx.$props.ariaLabel)
          }, { ...computedButtonIcons.value, ...buttonPropsComputed.value }, toHandlers(unref27(listeners))), {
            default: withCtx12(() => [
              renderSlot20(_ctx.$slots, "label", {}, () => [
                createTextVNode8(toDisplayString9(__props.label), 1)
              ])
            ]),
            _: 3
          }, 16, ["aria-label"])
        ]),
        default: withCtx12(() => [
          renderSlot20(_ctx.$slots, "content", {}, () => [
            createVNode11(unref27(VaDropdownContent), null, {
              default: withCtx12(() => [
                renderSlot20(_ctx.$slots, "default")
              ]),
              _: 3
            })
          ])
        ]),
        _: 3
      }, 16, ["modelValue", "disabled"])) : (openBlock24(), createBlock12(unref27(VaButtonGroup), mergeProps10({ key: 1 }, buttonPropsComputed.value, { class: ["va-button-dropdown", "va-button-dropdown--split"] }), {
        default: withCtx12(() => [
          !_ctx.$props.leftIcon ? (openBlock24(), createBlock12(unref27(VaButton), mergeProps10({
            key: 0,
            disabled: _ctx.$props.disabled || _ctx.$props.disableButton
          }, computedMainButtonProps.value, toHandlers(unref27(mainButtonListeners))), {
            default: withCtx12(() => [
              renderSlot20(_ctx.$slots, "label", {}, () => [
                createTextVNode8(toDisplayString9(__props.label), 1)
              ])
            ]),
            _: 3
          }, 16, ["disabled"])) : createCommentVNode12("", true),
          createVNode11(unref27(VaDropdown), mergeProps10(unref27(vaDropdownProps), {
            modelValue: unref27(valueComputed),
            "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => isRef4(valueComputed) ? valueComputed.value = $event : null),
            disabled: _ctx.$props.disabled || _ctx.$props.disableDropdown
          }), {
            anchor: withCtx12(() => [
              createVNode11(unref27(VaButton), mergeProps10({
                "aria-label": _ctx.$props.ariaLabel || unref27(t)("toggleDropdown"),
                disabled: _ctx.$props.disabled || _ctx.$props.disableDropdown,
                icon: computedIcon.value,
                "icon-color": _ctx.$props.iconColor
              }, toHandlers(unref27(listeners)), {
                onKeydown: withKeys5(withModifiers3(hideDropdown, ["prevent"]), ["esc"])
              }), null, 16, ["aria-label", "disabled", "icon", "icon-color", "onKeydown"])
            ]),
            default: withCtx12(() => [
              createVNode11(unref27(VaDropdownContent), null, {
                default: withCtx12(() => [
                  renderSlot20(_ctx.$slots, "default")
                ]),
                _: 3
              })
            ]),
            _: 3
          }, 16, ["modelValue", "disabled"]),
          _ctx.$props.leftIcon ? (openBlock24(), createBlock12(unref27(VaButton), mergeProps10({
            key: 1,
            disabled: _ctx.$props.disabled || _ctx.$props.disableButton
          }, computedMainButtonProps.value, toHandlers(unref27(mainButtonListeners))), {
            default: withCtx12(() => [
              renderSlot20(_ctx.$slots, "label", {}, () => [
                createTextVNode8(toDisplayString9(__props.label), 1)
              ])
            ]),
            _: 3
          }, 16, ["disabled"])) : createCommentVNode12("", true)
        ]),
        _: 3
      }, 16));
    };
  }
});

// node_modules/vuestic-ui/dist/es/src/components/va-button-dropdown/index.js
var VaButtonDropdown = withConfigTransport$1(_sfc_main27);

// node_modules/vuestic-ui/dist/es/src/components/va-button-toggle/VaButtonToggle.vue_vue_type_script_setup_true_lang.js
import { defineComponent as defineComponent28, computed as computed76, openBlock as openBlock25, createBlock as createBlock13, unref as unref28, mergeProps as mergeProps11, withCtx as withCtx13, createElementBlock as createElementBlock21, Fragment as Fragment8, renderList as renderList3, createTextVNode as createTextVNode9, toDisplayString as toDisplayString10 } from "vue";

// node_modules/vuestic-ui/dist/es/src/utils/value-by-key.js
var getNestedValue = (option, propsArray) => {
  if (propsArray.length === 0) {
    return option;
  }
  const nestedItem = option[propsArray[0]];
  if (!isObject(nestedItem)) {
    if (propsArray.length === 1) {
      return nestedItem;
    }
    return void 0;
  }
  return getNestedValue(nestedItem, propsArray.slice(1));
};
var getValueByPath = (option, prop) => {
  if (prop in option) {
    return option[prop];
  }
  prop = prop.replace(/^\./, "");
  return getNestedValue(option, prop.split("."));
};
var getValueByKey = (option, prop) => {
  if (isNilValue(option) || typeof option !== "object" || Array.isArray(option)) {
    return void 0;
  }
  if (!prop) {
    return option;
  }
  if (typeof prop === "string") {
    return getValueByPath(option, prop);
  }
  if (typeof prop === "function") {
    return prop(option);
  }
  return option;
};

// node_modules/vuestic-ui/dist/es/src/composables/useSelectableList.js
var useSelectableListProps = {
  options: { type: Array, default: () => [] },
  textBy: { type: [String, Function], default: "text" },
  valueBy: { type: [String, Function], default: "" },
  trackBy: { type: [String, Function], default: "" },
  disabledBy: { type: [String, Function], default: "disabled" },
  groupBy: { type: [String, Function], default: "group" }
};
function useSelectableList(props) {
  const tryResolveByValue = (value) => {
    const options = props.options;
    for (let i = 0; i < options.length; i++) {
      if (getValue(options[i]) === value) {
        return options[i];
      }
    }
    return value;
  };
  const getOptionProperty = (option, prop) => {
    if (!isObject(option)) {
      return option;
    }
    return getValueByKey(option, prop);
  };
  const getTrackBy = (option) => {
    return props.trackBy ? getOptionProperty(option, props.trackBy) : getValue(option);
  };
  const getDisabled = (option) => {
    if (!isObject(option)) {
      return false;
    }
    return getOptionProperty(option, props.disabledBy);
  };
  const getText = (option) => {
    const optionText = getOptionProperty(option, props.textBy);
    if (["number", "boolean"].includes(typeof optionText)) {
      return String(optionText);
    }
    return optionText;
  };
  const getGroupBy = (option) => {
    if (!isObject(option)) {
      return void 0;
    }
    return getOptionProperty(option, props.groupBy);
  };
  const getValue = (option) => getOptionProperty(option, props.valueBy);
  return {
    tryResolveByValue,
    getValue,
    getText,
    getDisabled,
    getTrackBy,
    getGroupBy
  };
}

// node_modules/vuestic-ui/dist/es/src/components/va-button-toggle/VaButtonToggle.vue_vue_type_script_setup_true_lang.js
import "D:/Desktop/forntend/Front_End_Web_Hotel_Nhom_2/my-nuxt-app/node_modules/vuestic-ui/dist/es/VaButtonToggle.css";
var VaButtonGroupProps = extractComponentProps(VaButtonGroup);
var _sfc_main28 = defineComponent28({
  ...{
    name: "VaButtonToggle"
  },
  __name: "VaButtonToggle",
  props: {
    ...VaButtonGroupProps,
    ...useComponentPresetProp,
    ...useSelectableListProps,
    modelValue: { type: [String, Number, Boolean, Object], default: "" },
    options: {
      type: Array,
      required: true
    },
    activeButtonTextColor: { type: String },
    toggleColor: { type: String, default: "" },
    textBy: { type: [String, Function], default: "label" },
    valueBy: { type: [String, Function], default: "value" }
  },
  emits: ["update:modelValue"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const { getText, getTrackBy } = useSelectableList(props);
    const { getColor, shiftHSLAColor: shiftHSLAColor2 } = useColors();
    const colorComputed = computed76(() => getColor(props.color));
    const isToggled = (value) => getTrackBy(value) === props.modelValue;
    const activeButtonColor = computed76(() => {
      if (props.toggleColor) {
        return getColor(props.toggleColor);
      }
      return shiftHSLAColor2(colorComputed.value, { l: props.plain ? -16 : -6 });
    });
    const activeButtonBackgroundOpacityComputed = computed76(() => {
      if (!props.preset || props.preset === "default") {
        return {};
      }
      return { backgroundOpacity: props.pressedOpacity };
    });
    const activeButtonPropsComputed = computed76(() => ({
      color: activeButtonColor.value,
      textColor: props.activeButtonTextColor,
      ...activeButtonBackgroundOpacityComputed.value
    }));
    const getButtonProps = (option = {}) => {
      const iconsProps = { icon: option.icon, iconRight: option.iconRight };
      if (!isToggled(option)) {
        return iconsProps;
      }
      return {
        ...isToggled(option) && activeButtonPropsComputed.value,
        ...iconsProps
      };
    };
    const buttonGroupPropsComputed = filterComponentProps(VaButtonGroupProps);
    const changeValue = (value) => emit("update:modelValue", getTrackBy(value));
    return (_ctx, _cache) => {
      return openBlock25(), createBlock13(unref28(VaButtonGroup), mergeProps11({ class: "va-button-toggle" }, unref28(buttonGroupPropsComputed)), {
        default: withCtx13(() => [
          (openBlock25(true), createElementBlock21(Fragment8, null, renderList3(__props.options, (option) => {
            return openBlock25(), createBlock13(unref28(VaButton), mergeProps11({
              key: unref28(getTrackBy)(option),
              "aria-pressed": isToggled(option)
            }, getButtonProps(option), {
              onClick: ($event) => changeValue(option)
            }), {
              default: withCtx13(() => [
                createTextVNode9(toDisplayString10(unref28(getText)(option)), 1)
              ]),
              _: 2
            }, 1040, ["aria-pressed", "onClick"]);
          }), 128))
        ]),
        _: 1
      }, 16);
    };
  }
});

// node_modules/vuestic-ui/dist/es/src/components/va-button-toggle/index.js
var VaButtonToggle = withConfigTransport$1(_sfc_main28);

// node_modules/vuestic-ui/dist/es/src/components/va-card/VaCard.vue_vue_type_script_setup_true_lang.js
import { defineComponent as defineComponent29, computed as computed77, openBlock as openBlock26, createBlock as createBlock14, resolveDynamicComponent as resolveDynamicComponent4, unref as unref29, normalizeClass as normalizeClass13, normalizeStyle as normalizeStyle15, withCtx as withCtx14, renderSlot as renderSlot21 } from "vue";
import "D:/Desktop/forntend/Front_End_Web_Hotel_Nhom_2/my-nuxt-app/node_modules/vuestic-ui/dist/es/VaCard.css";
var _sfc_main29 = defineComponent29({
  ...{
    name: "VaCard"
  },
  __name: "VaCard",
  props: {
    ...useRouterLinkProps,
    ...useComponentPresetProp,
    tag: { type: String, default: "div" },
    square: { type: Boolean, default: false },
    outlined: { type: Boolean, default: false },
    bordered: { type: Boolean, default: true },
    disabled: { type: Boolean, default: false },
    href: { type: String, default: "" },
    target: { type: String, default: "" },
    stripe: { type: Boolean, default: false },
    stripeColor: { type: String, default: "" },
    gradient: { type: Boolean, default: false },
    textColor: { type: String },
    color: { type: String, default: "background-secondary" }
  },
  setup(__props) {
    const props = __props;
    const { getColor } = useColors();
    const { isLinkTag, tagComputed, hrefComputed } = useRouterLink(props);
    const { textColorComputed } = useTextColor(computed77(() => getColor(props.color)));
    const stripeColorComputed = computed77(() => getColor(props.stripeColor));
    const classComputed = useBem("va-card", () => ({
      ...pick(props, ["square", "outlined", "disabled", "stripe"]),
      noBorder: !props.bordered,
      link: isLinkTag.value
    }));
    const cardStyles = computed77(() => {
      const background = props.gradient && props.color ? getGradientBackground(getColor(props.color)) : getColor(props.color);
      return {
        background,
        color: textColorComputed.value
      };
    });
    return (_ctx, _cache) => {
      return openBlock26(), createBlock14(resolveDynamicComponent4(unref29(tagComputed)), {
        class: normalizeClass13(["va-card", unref29(classComputed)]),
        style: normalizeStyle15([cardStyles.value, `--va-stripe-color-computed: ${String(stripeColorComputed.value)}`]),
        href: unref29(hrefComputed),
        target: __props.target,
        to: _ctx.to,
        replace: _ctx.replace,
        exact: _ctx.exact,
        "active-class": _ctx.activeClass,
        "exact-active-class": _ctx.exactActiveClass
      }, {
        default: withCtx14(() => [
          renderSlot21(_ctx.$slots, "default")
        ]),
        _: 3
      }, 8, ["class", "style", "href", "target", "to", "replace", "exact", "active-class", "exact-active-class"]);
    };
  }
});

// node_modules/vuestic-ui/dist/es/src/components/va-card/components/va-card-content/VaCardContent.vue_vue_type_script_setup_true_lang.js
import { defineComponent as defineComponent30, openBlock as openBlock27, createElementBlock as createElementBlock22, renderSlot as renderSlot22 } from "vue";
import "D:/Desktop/forntend/Front_End_Web_Hotel_Nhom_2/my-nuxt-app/node_modules/vuestic-ui/dist/es/VaCardContent.css";
var _hoisted_113 = { class: "va-card__content" };
var _sfc_main30 = defineComponent30({
  ...{
    name: "VaCardContent"
  },
  __name: "VaCardContent",
  setup(__props) {
    return (_ctx, _cache) => {
      return openBlock27(), createElementBlock22("div", _hoisted_113, [
        renderSlot22(_ctx.$slots, "default")
      ]);
    };
  }
});

// node_modules/vuestic-ui/dist/es/src/components/va-card/components/va-card-title/VaCardTitle.vue_vue_type_script_setup_true_lang.js
import { defineComponent as defineComponent31, computed as computed78, openBlock as openBlock28, createElementBlock as createElementBlock23, normalizeStyle as normalizeStyle16, renderSlot as renderSlot23 } from "vue";
import "D:/Desktop/forntend/Front_End_Web_Hotel_Nhom_2/my-nuxt-app/node_modules/vuestic-ui/dist/es/VaCardTitle.css";
var _sfc_main31 = defineComponent31({
  ...{
    name: "VaCardTitle"
  },
  __name: "VaCardTitle",
  props: {
    ...useComponentPresetProp,
    textColor: { type: String }
  },
  setup(__props) {
    const props = __props;
    const { getColor } = useColors();
    const titleStyles = computed78(() => ({
      color: props.textColor ? getColor(props.textColor) : ""
    }));
    return (_ctx, _cache) => {
      return openBlock28(), createElementBlock23("div", {
        class: "va-card-title va-card__title",
        style: normalizeStyle16(titleStyles.value)
      }, [
        renderSlot23(_ctx.$slots, "default", {}, void 0, true)
      ], 4);
    };
  }
});

// node_modules/vuestic-ui/dist/es/plugin-vue_export-helper.js
var _export_sfc = (sfc, props) => {
  const target = sfc.__vccOpts || sfc;
  for (const [key, val] of props) {
    target[key] = val;
  }
  return target;
};

// node_modules/vuestic-ui/dist/es/src/components/va-card/components/va-card-title/VaCardTitle.js
import "D:/Desktop/forntend/Front_End_Web_Hotel_Nhom_2/my-nuxt-app/node_modules/vuestic-ui/dist/es/VaCardTitle.css";
var VaCardTitleBase = _export_sfc(_sfc_main31, [["__scopeId", "data-v-5cd66b25"]]);

// node_modules/vuestic-ui/dist/es/src/components/va-card/components/va-card-actions/VaCardActions.vue_vue_type_script_setup_true_lang.js
import { defineComponent as defineComponent32, openBlock as openBlock29, createElementBlock as createElementBlock24, normalizeClass as normalizeClass14, unref as unref30, normalizeStyle as normalizeStyle17, renderSlot as renderSlot24 } from "vue";
import "D:/Desktop/forntend/Front_End_Web_Hotel_Nhom_2/my-nuxt-app/node_modules/vuestic-ui/dist/es/VaCardActions.css";
var _sfc_main32 = defineComponent32({
  ...{
    name: "VaCardActions"
  },
  __name: "VaCardActions",
  props: {
    ...useAlignProps,
    ...useComponentPresetProp
  },
  setup(__props) {
    const props = __props;
    const { alignComputed } = useAlign(props);
    const classComputed = useBem("va-card__actions", () => ({
      ...pick(props, ["vertical"])
    }));
    return (_ctx, _cache) => {
      return openBlock29(), createElementBlock24("div", {
        class: normalizeClass14(["va-card__actions", unref30(classComputed)]),
        style: normalizeStyle17(unref30(alignComputed))
      }, [
        renderSlot24(_ctx.$slots, "default")
      ], 6);
    };
  }
});

// node_modules/vuestic-ui/dist/es/src/components/va-card/components/va-card-block/VaCardBlock.vue_vue_type_script_setup_true_lang.js
import { defineComponent as defineComponent33, computed as computed79, openBlock as openBlock30, createElementBlock as createElementBlock25, normalizeClass as normalizeClass15, renderSlot as renderSlot25 } from "vue";
import "D:/Desktop/forntend/Front_End_Web_Hotel_Nhom_2/my-nuxt-app/node_modules/vuestic-ui/dist/es/VaCardBlock.css";
var _sfc_main33 = defineComponent33({
  ...{
    name: "VaCardBlock"
  },
  __name: "VaCardBlock",
  props: {
    horizontal: {
      type: Boolean,
      default: false
    }
  },
  setup(__props) {
    const props = __props;
    const classComputed = computed79(() => ({
      "va-card-block--horizontal": props.horizontal
    }));
    return (_ctx, _cache) => {
      return openBlock30(), createElementBlock25("div", {
        class: normalizeClass15(["va-card-block", classComputed.value])
      }, [
        renderSlot25(_ctx.$slots, "default")
      ], 2);
    };
  }
});

// node_modules/vuestic-ui/dist/es/src/components/va-card/index.js
var VaCardContent = withConfigTransport$1(_sfc_main30);
var VaCardTitle = withConfigTransport$1(VaCardTitleBase);
var VaCardActions = withConfigTransport$1(_sfc_main32);
var VaCardBlock = withConfigTransport$1(_sfc_main33);
var VaCard = withConfigTransport$1(_sfc_main29);

// node_modules/vuestic-ui/dist/es/src/components/va-carousel/VaCarousel.vue_vue_type_script_setup_true_lang.js
import { defineComponent as defineComponent36, computed as computed86, shallowRef as shallowRef10, openBlock as openBlock33, createElementBlock as createElementBlock28, normalizeClass as normalizeClass16, normalizeStyle as normalizeStyle18, unref as unref34, Fragment as Fragment9, withKeys as withKeys6, withModifiers as withModifiers4, renderSlot as renderSlot28, createVNode as createVNode13, withCtx as withCtx16, createCommentVNode as createCommentVNode14, renderList as renderList4, mergeProps as mergeProps13, normalizeProps as normalizeProps10, guardReactiveProps as guardReactiveProps6, createTextVNode as createTextVNode10, toDisplayString as toDisplayString11, createElementVNode as createElementVNode11 } from "vue";

// node_modules/vuestic-ui/dist/es/src/components/va-carousel/hooks/useCarousel.js
import { computed as computed80 } from "vue";
var useCarousel = (props, currentSlide) => {
  const goTo = (index) => {
    currentSlide.value = index;
  };
  const prev = () => {
    if (props.infinite) {
      if (currentSlide.value <= 0) {
        currentSlide.value = props.items.length - 1;
        return;
      }
    }
    currentSlide.value -= 1;
  };
  const next = () => {
    if (props.infinite) {
      if (currentSlide.value >= props.items.length - 1) {
        currentSlide.value = 0;
        return;
      }
    }
    currentSlide.value += 1;
  };
  const doShowDirectionButtons = computed80(() => props.items.length > 1);
  const doShowPrevButton = computed80(() => currentSlide.value > 0 || props.infinite);
  const doShowNextButton = computed80(() => currentSlide.value < props.items.length - 1 || props.infinite);
  return {
    doShowPrevButton,
    doShowNextButton,
    doShowDirectionButtons,
    goTo,
    prev,
    next
  };
};

// node_modules/vuestic-ui/dist/es/src/components/va-carousel/hooks/useCarouselAnimation.js
import { onMounted as onMounted17, onBeforeUnmount as onBeforeUnmount15, ref as ref27, computed as computed81, watch as watch19 } from "vue";
var useCarouselAnimation = (props, currentSlide) => {
  let animationInterval = -1;
  const start = () => {
    if (!props.autoscroll) {
      return;
    }
    clearInterval(animationInterval);
    animationInterval = setInterval(() => {
      currentSlide.value += 1;
      if (currentSlide.value >= props.items.length) {
        currentSlide.value = 0;
      }
    }, props.autoscrollInterval);
  };
  let pauseTimeout;
  const pause = () => {
    if (!props.autoscroll) {
      return;
    }
    clearInterval(animationInterval);
    pauseTimeout = setTimeout(() => {
      start();
      clearTimeout(pauseTimeout);
    }, props.autoscrollPauseDuration);
  };
  const stop = () => {
    clearInterval(animationInterval);
    clearTimeout(pauseTimeout);
  };
  onMounted17(() => start());
  onBeforeUnmount15(() => stop());
  const withPause = (fn) => {
    return (...args) => {
      pause();
      fn(...args);
    };
  };
  const slidesContainerStyle = ref27({
    transition: void 0
  });
  const sliderToBeShown = ref27(0);
  const computedSlidesStyle = computed81(() => {
    if (props.effect === "fade") {
      return {
        ...slidesContainerStyle.value,
        transition: "none"
      };
    }
    if (props.vertical) {
      return {
        ...slidesContainerStyle.value,
        transform: `translateY(${sliderToBeShown.value * -100}%)`
      };
    }
    return {
      ...slidesContainerStyle.value,
      transform: `translateX(${sliderToBeShown.value * -100}%)`
    };
  });
  const animator = {
    isAnimating: false,
    speed: 0.3,
    order: [],
    move(from, to) {
      const last = props.items.length - 1;
      const firstAfterLast = props.items.length;
      if (to === 0 && from === last) {
        this.order.push({ to: firstAfterLast });
        this.order.push({ to: 0, animate: false });
      } else if (to === last && from === 0) {
        this.order.push({ to: firstAfterLast, animate: false });
        this.order.push({ to });
      } else {
        this.order.push({ to });
      }
      if (!this.isAnimating) {
        this.runAnimation();
      }
    },
    runAnimation() {
      this.isAnimating = true;
      const animation = this.order.shift();
      if (!animation) {
        this.isAnimating = false;
        return;
      }
      sliderToBeShown.value = animation == null ? void 0 : animation.to;
      if (animation.animate || animation.animate === void 0) {
        slidesContainerStyle.value.transition = `all ${this.speed}s linear`;
        setTimeout(() => {
          this.runAnimation();
        }, this.speed * 1e3);
      } else {
        slidesContainerStyle.value.transition = "none";
        setTimeout(() => {
          this.runAnimation();
        }, 16);
      }
    }
  };
  watch19(currentSlide, (newValue, oldValue) => {
    animator.move(oldValue, newValue);
  });
  const slides = computed81(() => {
    if (props.effect === "fade") {
      return [props.items[currentSlide.value]];
    }
    if (props.infinite || props.autoscroll) {
      return [...props.items, props.items[0]];
    }
    return props.items;
  });
  return {
    start,
    pause,
    stop,
    withPause,
    computedSlidesStyle,
    slides
  };
};

// node_modules/vuestic-ui/dist/es/src/components/va-carousel/hooks/useCarouselColors.js
import { computed as computed82 } from "vue";
var useCarouselColor = () => {
  const { setHSLAColor: setHSLAColor2, getColor } = useColors();
  return {
    computedColor: computed82(() => setHSLAColor2(getColor("background-element"), { a: 0.7 })),
    computedHoverColor: computed82(() => setHSLAColor2(getColor("primary"), { a: 0.7 })),
    computedActiveColor: computed82(() => getColor("primary"))
  };
};

// node_modules/vuestic-ui/dist/es/src/components/va-image/VaImage.vue_vue_type_script_setup_true_lang.js
import { defineComponent as defineComponent34, ref as ref29, computed as computed85, onBeforeMount, onBeforeUnmount as onBeforeUnmount17, watch as watch21, useSlots as useSlots4, openBlock as openBlock31, createBlock as createBlock15, unref as unref32, mergeProps as mergeProps12, withCtx as withCtx15, withDirectives as withDirectives2, createElementVNode as createElementVNode10, renderSlot as renderSlot26, createCommentVNode as createCommentVNode13, createElementBlock as createElementBlock26, vShow as vShow2, createVNode as createVNode12, nextTick as nextTick7 } from "vue";

// node_modules/vuestic-ui/dist/es/src/components/va-image/hooks/useNativeImgAttributes.js
import { computed as computed83 } from "vue";
var useNativeImgAttributesProps = {
  src: { type: String, required: true },
  alt: { type: String, default: "" },
  title: { type: String, default: "" },
  sizes: { type: String, default: "" },
  srcset: { type: String, default: "" },
  draggable: { type: Boolean, default: true },
  loading: {
    type: String
  },
  crossorigin: {
    type: String
  },
  decoding: {
    type: String
  },
  fetchpriority: {
    type: String,
    default: "auto"
  },
  referrerpolicy: {
    type: String
  }
};
var useNativeImgAttributes = (props) => {
  return computed83(
    () => pick(props, ["src", "alt", "title", "sizes", "srcset", "loading", "referrerpolicy", "fetchpriority", "decoding", "crossorigin", "draggable"])
  );
};

// node_modules/vuestic-ui/dist/es/src/composables/useIntersectionObserver.js
import { ref as ref28, computed as computed84, watch as watch20, onBeforeUnmount as onBeforeUnmount16, unref as unref31 } from "vue";
var useIntersectionObserver = (cb, options = ref28({}), target = ref28([]), enabled = true) => {
  const observer = ref28();
  const disconnectObserver = () => {
    var _a2;
    (_a2 = observer.value) == null ? void 0 : _a2.disconnect();
  };
  const observeTarget = (target2) => {
    var _a2;
    const disclosedTarget = unwrapEl(unref31(target2));
    disclosedTarget && ((_a2 = observer.value) == null ? void 0 : _a2.observe(disclosedTarget));
  };
  const observeAll = (targets) => {
    targets.forEach(observeTarget);
  };
  const initObserver = () => {
    observer.value = new IntersectionObserver(cb, options.value);
  };
  const isIntersectionDisabled = computed84(() => !enabled || !(typeof window !== "undefined" && "IntersectionObserver" in window));
  watch20([target, options], ([newTarget]) => {
    if (isIntersectionDisabled.value) {
      return;
    }
    disconnectObserver();
    if (!newTarget) {
      return;
    }
    initObserver();
    Array.isArray(newTarget) ? observeAll(newTarget) : observeTarget(newTarget);
  }, { immediate: true });
  onBeforeUnmount16(disconnectObserver);
  return { isIntersectionDisabled };
};

// node_modules/vuestic-ui/dist/es/src/components/va-image/VaImage.vue_vue_type_script_setup_true_lang.js
import "D:/Desktop/forntend/Front_End_Web_Hotel_Nhom_2/my-nuxt-app/node_modules/vuestic-ui/dist/es/VaImage.css";
var _hoisted_114 = ["aria-busy"];
var _hoisted_26 = {
  key: 0,
  class: "va-image__overlay"
};
var _hoisted_33 = {
  key: 1,
  class: "va-image__error"
};
var _hoisted_43 = {
  key: 2,
  class: "va-image__loader"
};
var _hoisted_53 = {
  key: 3,
  class: "va-image__placeholder"
};
var _hoisted_63 = ["src"];
var VaFallbackProps = extractComponentProps(VaFallback);
var _sfc_main34 = defineComponent34({
  ...{
    name: "VaImage"
  },
  __name: "VaImage",
  props: {
    ...useComponentPresetProp,
    ...useNativeImgAttributesProps,
    ...VaFallbackProps,
    ratio: {
      type: [Number, String],
      default: "auto",
      validator: (v) => {
        if (typeof v === "number") {
          return v > 0;
        }
        return v === "auto";
      }
    },
    fit: {
      type: String,
      default: "cover"
    },
    maxWidth: {
      type: [Number, String],
      default: 0,
      validator: (v) => Number(v) >= 0
    },
    lazy: { type: Boolean, default: false },
    placeholderSrc: { type: String, default: "" }
  },
  emits: ["loaded", "error", "fallback"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const root = ref29();
    const image = ref29();
    const renderedImage = ref29();
    const currentImage = computed85(() => renderedImage.value || props.src);
    const imgWidth = ref29(1);
    const imgHeight = ref29(1);
    const isLoading = ref29(false);
    const isError = ref29(false);
    const handleLoad = () => {
      var _a2;
      isLoading.value = true;
      if (!isReadyForLoad.value) {
        return;
      }
      isLoading.value = false;
      renderedImage.value = (_a2 = image.value) == null ? void 0 : _a2.currentSrc;
      getImgSizes();
      emit("loaded", currentImage.value);
    };
    const handleError = (err) => {
      isError.value = true;
      isLoading.value = false;
      emit("error", err || currentImage.value);
    };
    const isIntersecting = ref29(false);
    const handleIntersection = (entries, observer) => {
      entries.forEach((entry) => {
        if (!entry.isIntersecting) {
          return;
        }
        isIntersecting.value = true;
        init();
        observer.disconnect();
      });
    };
    const { isIntersectionDisabled } = useIntersectionObserver(handleIntersection, void 0, root, props.lazy);
    const isReadyForLoad = computed85(() => isIntersectionDisabled.value || isIntersecting.value);
    const isMounted = useIsMounted();
    const isReadyForRender = computed85(() => !props.lazy || props.lazy && isMounted.value && isReadyForLoad.value);
    const init = () => {
      if (!props.src || isLoading.value && isIntersectionDisabled.value || !isReadyForLoad.value) {
        return;
      }
      isLoading.value = true;
      isError.value = false;
      nextTick7(() => {
        var _a2;
        if (!((_a2 = image.value) == null ? void 0 : _a2.complete)) {
          return;
        }
        if (!image.value.naturalWidth) {
          handleError();
          return;
        }
        handleLoad();
      });
    };
    let timer;
    const getImgSizes = () => {
      clearTimeout(timer);
      if (isLoading.value) {
        timer = window.setTimeout(getImgSizes, 100);
      }
      const { naturalHeight, naturalWidth } = image.value || {};
      if (naturalHeight && naturalWidth) {
        imgWidth.value = naturalHeight;
        imgHeight.value = naturalWidth;
      }
    };
    onBeforeMount(init);
    onBeforeUnmount17(() => clearTimeout(timer));
    watch21(() => props.src, init);
    const slots = useSlots4();
    const isPlaceholderPassed = computed85(() => {
      var _a2;
      return ((_a2 = slots == null ? void 0 : slots.placeholder) == null ? void 0 : _a2.call(slots)) || props.placeholderSrc;
    });
    const isLoaderShown = computed85(() => {
      var _a2;
      return isLoading.value && !((_a2 = slots == null ? void 0 : slots.loader) == null ? void 0 : _a2.call(slots));
    });
    const isErrorShown = computed85(() => {
      var _a2;
      return isError.value && (!((_a2 = slots == null ? void 0 : slots.error) == null ? void 0 : _a2.call(slots)) && !isAnyFallbackPassed.value);
    });
    const isPlaceholderShown = computed85(() => (isLoaderShown.value || isErrorShown.value) && isPlaceholderPassed.value);
    const isSuccessfullyLoaded = computed85(() => !(isLoading.value || isError.value));
    const imgAttributesComputed = useNativeImgAttributes(props);
    const aspectRationAttributesComputed = computed85(() => ({
      ...pick(props, ["ratio", "maxWidth"]),
      contentWidth: imgWidth.value,
      contentHeight: imgHeight.value
    }));
    const fallbackProps = filterComponentProps(VaFallbackProps);
    const checkObjectNonEmptyValues = (obj) => !!Object.values(obj || {}).filter((prop) => prop).length;
    const hasFallbackGlobalConfig = computed85(() => {
      var _a2, _b, _c, _d;
      return checkObjectNonEmptyValues((_d = (_c = (_b = (_a2 = useGlobalConfig()) == null ? void 0 : _a2.globalConfig) == null ? void 0 : _b.value) == null ? void 0 : _c.components) == null ? void 0 : _d.VaFallback);
    });
    const isAnyFallbackPassed = computed85(() => checkObjectNonEmptyValues(fallbackProps.value) || hasFallbackGlobalConfig.value);
    const fitComputed = computed85(() => props.fit);
    return (_ctx, _cache) => {
      return openBlock31(), createBlock15(unref32(VaAspectRatio), mergeProps12({
        ref_key: "root",
        ref: root,
        class: "va-image"
      }, aspectRationAttributesComputed.value, {
        style: `--va-fit-computed: ${String(fitComputed.value)}`
      }), {
        default: withCtx15(() => [
          withDirectives2(createElementVNode10("picture", {
            class: "va-image__content",
            "aria-busy": isLoading.value
          }, [
            _ctx.$slots.sources ? renderSlot26(_ctx.$slots, "sources", { key: 0 }) : createCommentVNode13("", true),
            isReadyForRender.value ? (openBlock31(), createElementBlock26("img", mergeProps12({
              key: 1,
              ref_key: "image",
              ref: image
            }, unref32(imgAttributesComputed), {
              onError: handleError,
              onLoad: handleLoad
            }), null, 16)) : createCommentVNode13("", true)
          ], 8, _hoisted_114), [
            [vShow2, isSuccessfullyLoaded.value]
          ]),
          _ctx.$slots.default && isSuccessfullyLoaded.value ? (openBlock31(), createElementBlock26("div", _hoisted_26, [
            renderSlot26(_ctx.$slots, "default")
          ])) : createCommentVNode13("", true),
          isError.value && (_ctx.$slots.error || isAnyFallbackPassed.value) ? (openBlock31(), createElementBlock26("div", _hoisted_33, [
            renderSlot26(_ctx.$slots, "error", {}, () => [
              createVNode12(unref32(VaFallback), mergeProps12(unref32(fallbackProps), {
                onFallback: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("fallback"))
              }), null, 16)
            ])
          ])) : createCommentVNode13("", true),
          isLoading.value && _ctx.$slots.loader ? (openBlock31(), createElementBlock26("div", _hoisted_43, [
            renderSlot26(_ctx.$slots, "loader")
          ])) : createCommentVNode13("", true),
          isPlaceholderShown.value ? (openBlock31(), createElementBlock26("div", _hoisted_53, [
            renderSlot26(_ctx.$slots, "placeholder", {}, () => [
              _ctx.$props.placeholderSrc ? (openBlock31(), createElementBlock26("img", {
                key: 0,
                src: _ctx.$props.placeholderSrc,
                alt: ""
              }, null, 8, _hoisted_63)) : createCommentVNode13("", true)
            ])
          ])) : createCommentVNode13("", true)
        ]),
        _: 3
      }, 16, ["style"]);
    };
  }
});

// node_modules/vuestic-ui/dist/es/src/components/va-image/index.js
var VaImage = withConfigTransport$1(_sfc_main34);

// node_modules/vuestic-ui/dist/es/src/components/va-hover/VaHover.vue_vue_type_script_setup_true_lang.js
import { defineComponent as defineComponent35, openBlock as openBlock32, createElementBlock as createElementBlock27, renderSlot as renderSlot27, normalizeProps as normalizeProps9, guardReactiveProps as guardReactiveProps5, unref as unref33 } from "vue";
var _sfc_main35 = defineComponent35({
  ...{
    name: "VaHover"
  },
  __name: "VaHover",
  props: {
    ...createStatefulProps(true),
    ...useComponentPresetProp,
    disabled: { type: Boolean, default: false },
    modelValue: { type: Boolean, default: false }
  },
  emits: [...useStatefulEmits],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const { valueComputed } = useStateful(props, emit);
    const onMouseEnter = () => {
      if (!props.disabled) {
        valueComputed.value = true;
      }
    };
    const onMouseLeave = () => {
      if (!props.disabled) {
        valueComputed.value = false;
      }
    };
    return (_ctx, _cache) => {
      return openBlock32(), createElementBlock27("div", {
        class: "va-hover",
        onMouseenter: onMouseEnter,
        onMouseleave: onMouseLeave
      }, [
        renderSlot27(_ctx.$slots, "default", normalizeProps9(guardReactiveProps5({ hover: unref33(valueComputed) })))
      ], 32);
    };
  }
});

// node_modules/vuestic-ui/dist/es/src/components/va-hover/index.js
var VaHover = withConfigTransport$1(_sfc_main35);

// node_modules/vuestic-ui/dist/es/src/composables/useSwipe.js
import { ref as ref30, reactive as reactive5, watchEffect as watchEffect6, watch as watch22 } from "vue";
var mouseEvents = ["mousedown", "mousemove"];
var touchEvents = ["touchstart", "touchmove"];
var commonAllowedDirections = {
  vertical: ["", "all", "vertical"],
  horizontal: ["", "all", "horizontal"]
};
var verticalSpecificAllowedDirections = [...commonAllowedDirections.vertical, "up", "down"];
var horizontalSpecificAllowedDirections = [...commonAllowedDirections.horizontal, "left", "right"];
var useSwipeProps = {
  swipable: { type: Boolean, default: false },
  swipeDistance: { type: Number, default: 75 },
  swipeDirection: { type: String, default: "all" }
};
var useSwipe = (props, container, cb) => {
  const swipeStarted = ref30(false);
  const swipePath = reactive5({
    start: { x: 0, y: 0 },
    end: { x: 0, y: 0 }
  });
  const swipeDuration = reactive5({
    start: 0,
    end: 0
  });
  const setState = (e, type) => {
    let event;
    if (mouseEvents.includes(e.type)) {
      event = e;
    }
    if (touchEvents.includes(e.type)) {
      const touchEvent = e;
      event = touchEvent.changedTouches[touchEvent.changedTouches.length - 1];
    }
    if (!event) {
      return;
    }
    swipePath[type].x = event.pageX;
    swipePath[type].y = event.pageY;
    swipeDuration[type] = (/* @__PURE__ */ new Date()).getTime();
  };
  const onSwipeStart = (e) => {
    if (!props.swipable || swipeStarted.value) {
      return;
    }
    swipeStarted.value = true;
    setState(e, "start");
  };
  const onSwipeMove = (e) => {
    if (!swipeStarted.value) {
      return;
    }
    setState(e, "end");
  };
  const resetSwipe = () => {
    ["start", "end"].forEach((type) => {
      swipePath[type].x = 0;
      swipePath[type].y = 0;
      swipeDuration[type] = 0;
    });
    swipeStarted.value = false;
  };
  const isSwipeAllowed = reactive5({
    vertical: false,
    horizontal: false
  });
  watchEffect6(() => {
    isSwipeAllowed.horizontal = horizontalSpecificAllowedDirections.includes(props.swipeDirection);
    isSwipeAllowed.vertical = verticalSpecificAllowedDirections.includes(props.swipeDirection);
  });
  const calcDistance = (axis) => {
    return isSwipeAllowed[axis === "x" ? "horizontal" : "vertical"] && swipePath.start[axis] && swipePath.end[axis] ? Math.trunc(swipePath.start[axis] - swipePath.end[axis]) : 0;
  };
  const getAcceptableValue = (direction, result) => {
    return result === props.swipeDirection || commonAllowedDirections[direction].includes(props.swipeDirection) ? result : "";
  };
  const swipeState = reactive5({ direction: "", duration: 0 });
  watch22(swipePath, () => {
    const xDistance = calcDistance("x");
    const yDistance = calcDistance("y");
    if ((xDistance || yDistance) && [xDistance, yDistance].some((el) => Math.abs(el) >= props.swipeDistance)) {
      if (Math.abs(xDistance) >= Math.abs(yDistance) && isSwipeAllowed.horizontal) {
        const result = xDistance > 0 ? "left" : "right";
        swipeState.direction = getAcceptableValue("horizontal", result);
      } else if (Math.abs(xDistance) < Math.abs(yDistance) && isSwipeAllowed.vertical) {
        const result = yDistance > 0 ? "down" : "up";
        swipeState.direction = getAcceptableValue("vertical", result);
      }
      swipeState.duration = swipeDuration.end - swipeDuration.start;
      resetSwipe();
    }
  }, { deep: true });
  watch22(swipeState, () => cb(swipeState), { deep: true });
  if (props.swipable) {
    useEvent(["touchstart", "mousedown"], onSwipeStart, container);
    useEvent(["touchmove", "mousemove"], onSwipeMove, container);
    useEvent(["touchcancel", "mouseup", "touchend", "mouseleave"], resetSwipe, container);
  }
  return { swipeState };
};

// node_modules/vuestic-ui/dist/es/src/components/va-carousel/VaCarousel.vue_vue_type_script_setup_true_lang.js
import "D:/Desktop/forntend/Front_End_Web_Hotel_Nhom_2/my-nuxt-app/node_modules/vuestic-ui/dist/es/VaCarousel.css";
var _hoisted_115 = ["aria-label"];
var _hoisted_27 = {
  key: 1,
  class: "va-carousel__indicators"
};
var _hoisted_34 = { class: "va-carousel__content" };
var _hoisted_44 = ["aria-hidden", "aria-current", "aria-label"];
var VaImageProps = extractComponentProps(VaImage, ["src", "alt"]);
var _sfc_main36 = defineComponent36({
  ...{
    name: "VaCarousel"
  },
  __name: "VaCarousel",
  props: {
    ...useSwipeProps,
    ...useStatefulProps,
    ...useComponentPresetProp,
    ...VaImageProps,
    stateful: { type: Boolean, default: true },
    modelValue: { type: Number, default: 0 },
    items: { type: Array, required: true },
    // Animations
    autoscroll: { type: Boolean, default: false },
    autoscrollInterval: { type: [Number, String], default: 5e3 },
    autoscrollPauseDuration: { type: [Number, String], default: 2e3 },
    infinite: { type: Boolean, default: true },
    fadeKeyframe: { type: String, default: "va-carousel-fade-appear 1s" },
    // Visual
    arrows: { type: Boolean, default: true },
    indicators: { type: Boolean, default: true },
    indicatorTrigger: {
      type: String,
      default: "click",
      validator: (value) => ["click", "hover", "none"].includes(value)
    },
    vertical: { type: Boolean, default: false },
    height: { type: String, default: "300px" },
    effect: {
      type: String,
      default: "transition",
      validator: (value) => ["fade", "transition"].includes(value)
    },
    color: { type: String, default: "primary" },
    ratio: { type: [Number, String] },
    ariaLabel: useTranslationProp("$t:carousel"),
    ariaPreviousLabel: useTranslationProp("$t:goPreviousSlide"),
    ariaNextLabel: useTranslationProp("$t:goNextSlide"),
    ariaGoToSlideLabel: useTranslationProp("$t:goSlide"),
    ariaSlideOfLabel: useTranslationProp("$t:slideOf")
  },
  emits: [...useStatefulEmits],
  setup(__props, { expose: __expose, emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const { valueComputed: currentSlide } = useStateful(props, emit, "modelValue");
    const autoscrollIntervalComputed = useNumericProp("autoscrollInterval");
    const autoscrollPauseDurationComputed = useNumericProp("autoscrollPauseDuration");
    const ratioComputed = useNumericProp("ratio");
    const {
      goTo,
      next,
      prev,
      doShowNextButton,
      doShowPrevButton,
      doShowDirectionButtons
    } = useCarousel(props, currentSlide);
    const { withPause, computedSlidesStyle, slides } = useCarouselAnimation({
      items: props.items,
      autoscrollInterval: autoscrollIntervalComputed.value,
      autoscrollPauseDuration: autoscrollPauseDurationComputed.value,
      autoscroll: props.autoscroll,
      infinite: props.infinite,
      effect: props.effect,
      vertical: props.vertical,
      fadeKeyframe: props.fadeKeyframe
    }, currentSlide);
    const isObjectSlides = computed86(() => {
      return props.items.length && props.items.every((el) => !!el && typeof el === "object" && !!(el == null ? void 0 : el.src));
    });
    const isCurrentSlide = (index) => index === currentSlide.value;
    const slideStyleComputed = computed86(() => ({
      animation: props.effect === "fade" ? "fadeKeyframe" : void 0
    }));
    const slidesContainer = shallowRef10();
    const onSwipe = (state) => {
      switch (state.direction) {
        case "right":
        case "up":
          doShowPrevButton.value && prev();
          break;
        case "left":
        case "down":
          doShowNextButton.value && next();
      }
    };
    useSwipe(props, slidesContainer, onSwipe);
    const getIndicatorEvents = (index) => {
      if (props.indicatorTrigger === "hover") {
        return { onmouseover: () => goTo(index) };
      }
      if (props.indicatorTrigger === "click") {
        return { onclick: () => goTo(index) };
      }
      return {};
    };
    const { tp, t } = useTranslation();
    const {
      computedActiveColor,
      computedColor,
      computedHoverColor
    } = useCarouselColor();
    const vaImageProps = filterComponentProps(VaImageProps);
    const goToWithPause = withPause(goTo);
    const prevWithPause = withPause(prev);
    const nextWithPause = withPause(next);
    __expose({
      currentSlide,
      goTo,
      next,
      prev,
      goToWithPause,
      prevWithPause,
      nextWithPause
    });
    return (_ctx, _cache) => {
      return openBlock33(), createElementBlock28("div", {
        class: normalizeClass16(["va-carousel", {
          "va-carousel--vertical": _ctx.$props.vertical,
          [`va-carousel--${_ctx.$props.effect}`]: true
        }]),
        style: normalizeStyle18({ height: unref34(ratioComputed) ? "auto" : __props.height }),
        role: "region",
        "aria-label": unref34(tp)(_ctx.$props.ariaLabel)
      }, [
        _ctx.$props.arrows && unref34(doShowDirectionButtons) ? (openBlock33(), createElementBlock28(Fragment9, { key: 0 }, [
          unref34(doShowPrevButton) ? (openBlock33(), createElementBlock28("div", {
            key: 0,
            class: "va-carousel__arrow va-carousel__arrow--left",
            onClick: _cache[0] || (_cache[0] = //@ts-ignore
            (...args) => unref34(prevWithPause) && unref34(prevWithPause)(...args)),
            onKeydown: _cache[1] || (_cache[1] = withKeys6(withModifiers4(
              //@ts-ignore
              (...args) => unref34(prevWithPause) && unref34(prevWithPause)(...args),
              ["stop"]
            ), ["enter"]))
          }, [
            renderSlot28(_ctx.$slots, "prev-arrow", {}, () => [
              createVNode13(unref34(VaHover), { stateful: "" }, {
                default: withCtx16(({ hover }) => [
                  createVNode13(unref34(VaButton), {
                    color: hover ? unref34(computedHoverColor) : unref34(computedColor),
                    icon: __props.vertical ? "va-arrow-up" : "va-arrow-left",
                    "aria-label": unref34(tp)(_ctx.$props.ariaPreviousLabel)
                  }, null, 8, ["color", "icon", "aria-label"])
                ]),
                _: 1
              })
            ])
          ], 32)) : createCommentVNode14("", true),
          unref34(doShowNextButton) ? (openBlock33(), createElementBlock28("div", {
            key: 1,
            class: "va-carousel__arrow va-carousel__arrow--right",
            onClick: _cache[2] || (_cache[2] = //@ts-ignore
            (...args) => unref34(nextWithPause) && unref34(nextWithPause)(...args)),
            onKeydown: _cache[3] || (_cache[3] = withKeys6(withModifiers4(
              //@ts-ignore
              (...args) => unref34(nextWithPause) && unref34(nextWithPause)(...args),
              ["stop"]
            ), ["enter"]))
          }, [
            renderSlot28(_ctx.$slots, "next-arrow", {}, () => [
              createVNode13(unref34(VaHover), { stateful: "" }, {
                default: withCtx16(({ hover }) => [
                  createVNode13(unref34(VaButton), {
                    color: hover ? unref34(computedHoverColor) : unref34(computedColor),
                    icon: __props.vertical ? "va-arrow-down" : "va-arrow-right",
                    "aria-label": unref34(tp)(_ctx.$props.ariaNextLabel)
                  }, null, 8, ["color", "icon", "aria-label"])
                ]),
                _: 1
              })
            ])
          ], 32)) : createCommentVNode14("", true)
        ], 64)) : createCommentVNode14("", true),
        _ctx.$props.indicators ? (openBlock33(), createElementBlock28("div", _hoisted_27, [
          (openBlock33(true), createElementBlock28(Fragment9, null, renderList4(_ctx.$props.items, (item, index) => {
            return openBlock33(), createElementBlock28("div", mergeProps13({
              class: ["va-carousel__indicator", { "va-carousel__indicator--active": isCurrentSlide(index) }],
              key: index
            }, getIndicatorEvents(index)), [
              renderSlot28(_ctx.$slots, "indicator", normalizeProps10(guardReactiveProps6({ item, index, goTo: unref34(goToWithPause), isActive: isCurrentSlide(index) })), () => [
                createVNode13(unref34(VaHover), { stateful: "" }, {
                  default: withCtx16(({ hover }) => [
                    createVNode13(unref34(VaButton), {
                      "aria-label": unref34(tp)(_ctx.$props.ariaGoToSlideLabel, { index: index + 1 }),
                      round: "",
                      color: isCurrentSlide(index) ? unref34(computedActiveColor) : hover ? unref34(computedHoverColor) : unref34(computedColor)
                    }, {
                      default: withCtx16(() => [
                        createTextVNode10(toDisplayString11(index + 1), 1)
                      ]),
                      _: 2
                    }, 1032, ["aria-label", "color"])
                  ]),
                  _: 2
                }, 1024)
              ])
            ], 16);
          }), 128))
        ])) : createCommentVNode14("", true),
        createElementVNode11("div", _hoisted_34, [
          createElementVNode11("div", {
            ref_key: "slidesContainer",
            ref: slidesContainer,
            class: "va-carousel__slides",
            style: normalizeStyle18(unref34(computedSlidesStyle)),
            role: "list"
          }, [
            (openBlock33(true), createElementBlock28(Fragment9, null, renderList4(unref34(slides), (item, index) => {
              return openBlock33(), createElementBlock28("div", {
                key: item,
                role: "listitem",
                class: "va-carousel__slide",
                style: normalizeStyle18(slideStyleComputed.value),
                "aria-hidden": !isCurrentSlide(index),
                "aria-current": isCurrentSlide(index),
                "aria-label": unref34(tp)(_ctx.$props.ariaSlideOfLabel, { index: index + 1, length: unref34(slides).length })
              }, [
                renderSlot28(_ctx.$slots, "default", normalizeProps10(guardReactiveProps6({ item, index, goTo: unref34(goToWithPause), isActive: isCurrentSlide(index) })), () => [
                  createVNode13(unref34(VaImage), mergeProps13(unref34(vaImageProps), {
                    src: isObjectSlides.value ? item.src : item,
                    alt: isObjectSlides.value ? item.alt : "",
                    draggable: false
                  }), null, 16, ["src", "alt"])
                ])
              ], 12, _hoisted_44);
            }), 128))
          ], 4)
        ])
      ], 14, _hoisted_115);
    };
  }
});

// node_modules/vuestic-ui/dist/es/src/components/va-carousel/index.js
var VaCarousel = withConfigTransport$1(_sfc_main36);

// node_modules/vuestic-ui/dist/es/src/components/va-checkbox/VaCheckbox.vue_vue_type_script_setup_true_lang.js
import { defineComponent as defineComponent37, shallowRef as shallowRef11, computed as computed88, openBlock as openBlock34, createBlock as createBlock16, unref as unref35, normalizeClass as normalizeClass17, normalizeStyle as normalizeStyle19, withCtx as withCtx17, createElementVNode as createElementVNode12, withModifiers as withModifiers5, mergeProps as mergeProps14, toHandlers as toHandlers2, createCommentVNode as createCommentVNode15, createElementBlock as createElementBlock29, renderSlot as renderSlot29, createTextVNode as createTextVNode11, toDisplayString as toDisplayString12 } from "vue";

// node_modules/vuestic-ui/dist/es/src/composables/useSelectable.js
import { computed as computed87 } from "vue";
var useSelectableProps = {
  ...useStatefulProps,
  ...useLoadingProps,
  ...useValidationProps,
  arrayValue: { type: [String, Boolean, Object, Number], default: null },
  label: { type: String, default: "" },
  leftLabel: { type: Boolean, default: false },
  trueValue: { type: null, default: true },
  falseValue: { type: null, default: false },
  indeterminate: { type: Boolean, default: false },
  indeterminateValue: { type: null, default: null },
  disabled: { type: Boolean, default: false },
  readonly: { type: Boolean, default: false }
};
var useSelectableEmits = [...useValidationEmits, "update:modelValue", "focus", "blur"];
var checkDuplicates = (props) => {
  const values = [props.falseValue, props.trueValue];
  if (props.indeterminate) {
    values.push(props.indeterminateValue);
  }
  const hasDuplicates = new Set(values).size !== values.length;
  if (hasDuplicates) {
    throw new Error("falseValue, trueValue, indeterminateValue props should have strictly different values, which is not the case.");
  }
};
var useSelectable = (props, emit, { input, label, container }) => {
  checkDuplicates(props);
  const reset = () => withoutValidation(() => {
    emit("update:modelValue", false);
    resetValidation();
  });
  const focus = () => {
    var _a2;
    (_a2 = unwrapEl(input.value)) == null ? void 0 : _a2.focus();
  };
  const { valueComputed } = useStateful(props, emit);
  const {
    computedError,
    computedErrorMessages,
    validate,
    validationAriaAttributes,
    listeners: validationListeners,
    withoutValidation,
    resetValidation,
    isDirty,
    isTouched,
    isError,
    isLoading,
    isValid
  } = useValidation(props, emit, { reset, focus, value: valueComputed });
  const { isFocused } = useFocus();
  const onBlur = (event) => {
    emit("blur", event);
    isFocused.value = false;
    validationListeners.onBlur();
  };
  const onFocus = (event) => {
    isFocused.value = true;
    emit("focus", event);
  };
  const isIndeterminate = computed87(() => props.indeterminate && valueComputed.value === props.indeterminateValue);
  const modelIsArray = computed87(() => props.arrayValue !== void 0 && props.arrayValue !== null);
  const isChecked = computed87(() => {
    var _a2;
    if (modelIsArray.value) {
      return (_a2 = props.modelValue) == null ? void 0 : _a2.includes(props.arrayValue);
    }
    return valueComputed.value === props.trueValue;
  });
  const toggleSelection = () => {
    if (props.readonly || props.disabled || props.loading) {
      return;
    }
    if (modelIsArray.value) {
      if (!props.modelValue) {
        emit("update:modelValue", [props.arrayValue]);
      } else if (!Array.isArray(props.modelValue)) {
        emit("update:modelValue", props.modelValue === props.arrayValue ? [] : [props.modelValue, props.arrayValue]);
      } else if (props.modelValue.includes(props.arrayValue)) {
        emit("update:modelValue", props.modelValue.filter((option) => option !== props.arrayValue));
      } else {
        emit("update:modelValue", props.modelValue.concat(props.arrayValue));
      }
      return;
    }
    if (props.indeterminate) {
      if (isIndeterminate.value) {
        valueComputed.value = props.trueValue;
      } else if (isChecked.value) {
        valueComputed.value = props.falseValue;
      } else {
        valueComputed.value = props.indeterminateValue;
      }
      return;
    }
    if (isChecked.value) {
      valueComputed.value = props.falseValue;
    } else {
      valueComputed.value = props.trueValue;
    }
  };
  return {
    isDirty,
    isTouched,
    isError,
    isLoading,
    isValid,
    isChecked,
    isIndeterminate,
    onBlur,
    onFocus,
    toggleSelection,
    reset,
    focus,
    computedError,
    computedErrorMessages,
    validationAriaAttributes
  };
};

// node_modules/vuestic-ui/dist/es/src/composables/useKeyboardOnlyFocus.js
import { ref as ref31 } from "vue";
var _a;
function useKeyboardOnlyFocus() {
  const hasKeyboardFocus = ref31(false);
  let previouslyClicked2 = false;
  const keyboardFocusListeners = {
    mousedown: () => {
      previouslyClicked2 = true;
    },
    focus: () => {
      if (!previouslyClicked2) {
        hasKeyboardFocus.value = true;
      }
      previouslyClicked2 = false;
    },
    blur: () => {
      hasKeyboardFocus.value = false;
      previouslyClicked2 = false;
    }
  };
  return {
    hasKeyboardFocus,
    keyboardFocusListeners
  };
}
var previouslyClicked = false;
(_a = getWindow()) == null ? void 0 : _a.addEventListener("mousedown", () => {
  previouslyClicked = true;
  setTimeout(() => {
    previouslyClicked = false;
  }, 300);
});
function useKeyboardOnlyFocusGlobal() {
  const hasKeyboardFocus = ref31(false);
  const keyboardFocusListeners = {
    focus: () => {
      if (!previouslyClicked) {
        hasKeyboardFocus.value = true;
      }
    },
    blur: () => {
      hasKeyboardFocus.value = false;
    }
  };
  return {
    hasKeyboardFocus,
    keyboardFocusListeners
  };
}

// node_modules/vuestic-ui/dist/es/src/components/va-checkbox/VaCheckbox.vue_vue_type_script_setup_true_lang.js
import "D:/Desktop/forntend/Front_End_Web_Hotel_Nhom_2/my-nuxt-app/node_modules/vuestic-ui/dist/es/VaCheckbox.css";
var _hoisted_116 = ["id", "indeterminate", "value", "checked"];
var _hoisted_28 = ["for"];
var VaCheckboxValueType = [Boolean, Array, String, Object];
var _sfc_main37 = defineComponent37({
  ...{
    name: "VaCheckbox"
  },
  __name: "VaCheckbox",
  props: {
    ...useSelectableProps,
    ...useComponentPresetProp,
    modelValue: { type: VaCheckboxValueType, default: false },
    color: { type: String, default: "primary" },
    checkedIcon: { type: String, default: "va-check" },
    indeterminate: { type: Boolean, default: false },
    indeterminateValue: { type: VaCheckboxValueType, default: null },
    indeterminateIcon: { type: String, default: "remove" },
    id: { type: String, default: "" },
    name: { type: String, default: "" },
    ariaLabel: { type: String, default: void 0 },
    vertical: { type: Boolean, default: false }
  },
  emits: useSelectableEmits,
  setup(__props, { expose: __expose, emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const elements = {
      container: shallowRef11(),
      input: shallowRef11(),
      label: shallowRef11()
    };
    const {
      isChecked,
      computedError,
      isIndeterminate,
      computedErrorMessages,
      validationAriaAttributes,
      toggleSelection,
      onBlur,
      onFocus,
      isDirty,
      isTouched,
      isError,
      isLoading,
      isValid
    } = useSelectable(props, emit, elements);
    const { getColor } = useColors();
    const { hasKeyboardFocus, keyboardFocusListeners } = useKeyboardOnlyFocus();
    const { textColorComputed } = useTextColor(computed88(() => getColor(props.color)));
    const isActive = computed88(() => isChecked.value || isIndeterminate.value);
    const computedClass = computed88(() => ({
      "va-checkbox--selected": isChecked.value,
      "va-checkbox--readonly": props.readonly,
      "va-checkbox--disabled": props.disabled,
      "va-checkbox--indeterminate": props.indeterminate,
      "va-checkbox--error": computedError.value,
      "va-checkbox--left-label": props.leftLabel,
      "va-checkbox--on-keyboard-focus": hasKeyboardFocus.value
    }));
    const getPaddingStyle = () => {
      switch (true) {
        case !props.label:
          return "";
        case props.vertical:
          return "var(--va-checkbox-vertical-padding)";
        case Boolean(props.arrayValue):
          return "var(--va-checkbox-horizontal-padding)";
        case props.leftLabel:
          return "var(--va-checkbox-right-padding)";
        default:
          return "var(--va-checkbox-left-padding)";
      }
    };
    const labelStyle = computed88(() => {
      return {
        color: computedError.value ? getColor("danger") : props.success ? getColor("success") : "",
        padding: getPaddingStyle()
      };
    });
    const inputStyle = computed88(() => {
      const style = {
        background: isActive.value ? getColor(props.color) : "",
        borderColor: isActive.value ? getColor(props.color) : ""
      };
      if (computedError.value) {
        style.borderColor = getColor("danger");
      }
      if (props.success) {
        style.borderColor = getColor("success");
      }
      return style;
    });
    const computedIconName = computed88(
      () => props.indeterminate && isIndeterminate.value ? props.indeterminateIcon : props.checkedIcon
    );
    const uniqueId = useComponentUuid();
    const computedId = computed88(() => props.id || String(uniqueId));
    const computedName = computed88(() => props.name || String(uniqueId));
    const inputAttributesComputed = computed88(() => ({
      name: computedName.value,
      disabled: props.disabled,
      readonly: props.readonly,
      tabindex: props.disabled ? -1 : 0,
      "aria-label": props.ariaLabel,
      "aria-disabled": props.disabled,
      "aria-readOnly": props.readonly,
      "aria-checked": isActive.value,
      ...validationAriaAttributes.value
    }));
    const displayVal = computed88(() => props.vertical ? "--va-checkbox-display-flex" : "var(--va-checkbox-display)");
    __expose({
      toggleSelection,
      isDirty,
      isTouched,
      isError,
      isLoading,
      isValid
    });
    return (_ctx, _cache) => {
      return openBlock34(), createBlock16(unref35(_sfc_main3), {
        class: normalizeClass17(["va-checkbox", computedClass.value]),
        disabled: _ctx.disabled,
        success: _ctx.success,
        messages: _ctx.messages,
        error: unref35(computedError),
        "error-messages": unref35(computedErrorMessages),
        "error-count": _ctx.errorCount,
        style: normalizeStyle19(`--va-display-val: ${String(displayVal.value)}`)
      }, {
        default: withCtx17(() => [
          createElementVNode12("div", {
            ref: "container",
            class: "va-checkbox__input-container",
            onClick: _cache[6] || (_cache[6] = //@ts-ignore
            (...args) => unref35(toggleSelection) && unref35(toggleSelection)(...args)),
            onBlur: _cache[7] || (_cache[7] = //@ts-ignore
            (...args) => unref35(onBlur) && unref35(onBlur)(...args))
          }, [
            createElementVNode12("div", {
              class: "va-checkbox__square",
              style: normalizeStyle19(inputStyle.value),
              onSelectstart: _cache[4] || (_cache[4] = withModifiers5(() => {
              }, ["prevent"]))
            }, [
              createElementVNode12("input", mergeProps14({
                ref: "input",
                type: "checkbox",
                class: "va-checkbox__input",
                id: computedId.value,
                indeterminate: __props.indeterminate,
                value: _ctx.label,
                checked: isActive.value
              }, inputAttributesComputed.value, toHandlers2(unref35(keyboardFocusListeners), true), {
                onFocus: _cache[0] || (_cache[0] = //@ts-ignore
                (...args) => unref35(onFocus) && unref35(onFocus)(...args)),
                onBlur: _cache[1] || (_cache[1] = //@ts-ignore
                (...args) => unref35(onBlur) && unref35(onBlur)(...args)),
                onClick: _cache[2] || (_cache[2] = withModifiers5(() => {
                }, ["stop", "prevent"])),
                onKeypress: _cache[3] || (_cache[3] = withModifiers5(
                  //@ts-ignore
                  (...args) => unref35(toggleSelection) && unref35(toggleSelection)(...args),
                  ["prevent"]
                ))
              }), null, 16, _hoisted_116),
              isActive.value ? (openBlock34(), createBlock16(unref35(VaIcon), {
                key: 0,
                class: "va-checkbox__icon",
                name: computedIconName.value,
                color: unref35(textColorComputed)
              }, null, 8, ["name", "color"])) : createCommentVNode15("", true)
            ], 36),
            _ctx.label || _ctx.$slots.label ? (openBlock34(), createElementBlock29("label", {
              key: 0,
              ref: "label",
              class: "va-checkbox__label",
              for: computedId.value,
              style: normalizeStyle19(labelStyle.value),
              onBlur: _cache[5] || (_cache[5] = //@ts-ignore
              (...args) => unref35(onBlur) && unref35(onBlur)(...args))
            }, [
              renderSlot29(_ctx.$slots, "label", {}, () => [
                createTextVNode11(toDisplayString12(_ctx.label), 1)
              ])
            ], 44, _hoisted_28)) : createCommentVNode15("", true)
          ], 544)
        ]),
        _: 3
      }, 8, ["class", "disabled", "success", "messages", "error", "error-messages", "error-count", "style"]);
    };
  }
});

// node_modules/vuestic-ui/dist/es/src/components/va-checkbox/index.js
var VaCheckbox = withConfigTransport$1(_sfc_main37);

// node_modules/vuestic-ui/dist/es/src/components/va-chip/VaChip.vue_vue_type_script_setup_true_lang.js
import { defineComponent as defineComponent38, computed as computed89, unref as unref36, openBlock as openBlock35, createBlock as createBlock17, resolveDynamicComponent as resolveDynamicComponent5, normalizeClass as normalizeClass18, normalizeStyle as normalizeStyle20, withCtx as withCtx18, createElementVNode as createElementVNode13, mergeProps as mergeProps15, toHandlers as toHandlers3, createCommentVNode as createCommentVNode16, renderSlot as renderSlot30, withModifiers as withModifiers6, withKeys as withKeys7 } from "vue";
import "D:/Desktop/forntend/Front_End_Web_Hotel_Nhom_2/my-nuxt-app/node_modules/vuestic-ui/dist/es/VaChip.css";
var _hoisted_117 = { class: "va-chip__content" };
var _sfc_main38 = defineComponent38({
  ...{
    name: "VaChip"
  },
  __name: "VaChip",
  props: {
    ...useRouterLinkProps,
    ...useColorProps,
    ...useStatefulProps,
    ...useComponentPresetProp,
    modelValue: { type: Boolean, default: true },
    closeable: { type: Boolean, default: false },
    outline: { type: Boolean, default: false },
    disabled: { type: Boolean, default: false },
    readonly: { type: Boolean, default: false },
    square: { type: Boolean, default: false },
    shadow: { type: Boolean, default: false },
    flat: { type: Boolean, default: false },
    icon: { type: String, default: "" },
    tag: { type: String, default: "span" },
    size: {
      type: String,
      default: "medium",
      validator: (value) => ["small", "medium", "large"].includes(value)
    },
    ariaCloseLabel: useTranslationProp("$t:close")
  },
  emits: [...useStatefulEmits, "focus"],
  setup(__props, { expose: __expose, emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const { getColor } = useColors();
    const colorComputed = computed89(() => getColor(props.color));
    const borderColor = computed89(() => props.outline ? colorComputed.value : "");
    const isTransparentBackground = computed89(() => Boolean(props.outline || props.flat));
    const { textColorComputed } = useTextColor(colorComputed, isTransparentBackground);
    const { hasKeyboardFocus, keyboardFocusListeners } = useKeyboardOnlyFocus();
    const shadowStyle = computed89(() => {
      if (!props.shadow || props.flat || props.outline || props.disabled || hasKeyboardFocus.value) {
        return;
      }
      return `0 0.125rem 0.19rem 0 ${getBoxShadowColor(colorComputed.value)}`;
    });
    const { valueComputed } = useStateful(props, emit);
    const { tagComputed, hrefComputed } = useRouterLink(props);
    const { isHovered, onMouseEnter, onMouseLeave } = useHover();
    const close = () => {
      if (!props.disabled) {
        valueComputed.value = false;
      }
    };
    const iconSize = computed89(() => props.size);
    const tabIndexComputed = computed89(() => props.disabled ? -1 : 0);
    const computedClass = useBem("va-chip", () => ({
      ...pick(props, ["disabled", "readonly", "square"]),
      small: props.size === "small",
      large: props.size === "large"
    }));
    const computedStyle = computed89(() => {
      const result = {
        color: textColorComputed.value,
        borderColor: borderColor.value,
        background: "",
        boxShadow: shadowStyle.value
      };
      if (props.outline || props.flat) {
        if (hasKeyboardFocus.value) {
          result.background = getFocusColor(colorComputed.value);
        } else if (!props.readonly && isHovered.value) {
          result.background = getHoverColor(colorComputed.value);
        }
      } else {
        result.background = colorComputed.value;
      }
      return result;
    });
    const { tp } = useTranslation();
    __expose({
      close
    });
    return (_ctx, _cache) => {
      return unref36(valueComputed) ? (openBlock35(), createBlock17(resolveDynamicComponent5(unref36(tagComputed)), {
        key: 0,
        class: normalizeClass18(["va-chip", unref36(computedClass)]),
        href: unref36(hrefComputed),
        target: _ctx.target,
        to: _ctx.to,
        replace: _ctx.replace,
        exact: _ctx.exact,
        "active-class": _ctx.activeClass,
        "exact-active-class": _ctx.exactActiveClass,
        style: normalizeStyle20(computedStyle.value)
      }, {
        default: withCtx18(() => [
          createElementVNode13("span", mergeProps15({
            class: "va-chip__inner",
            onFocus: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("focus")),
            onMouseenter: _cache[1] || (_cache[1] = //@ts-ignore
            (...args) => unref36(onMouseEnter) && unref36(onMouseEnter)(...args)),
            onMouseleave: _cache[2] || (_cache[2] = //@ts-ignore
            (...args) => unref36(onMouseLeave) && unref36(onMouseLeave)(...args))
          }, toHandlers3(unref36(keyboardFocusListeners), true)), [
            __props.icon ? (openBlock35(), createBlock17(unref36(VaIcon), {
              key: 0,
              class: "va-chip__icon",
              name: __props.icon,
              size: iconSize.value
            }, null, 8, ["name", "size"])) : createCommentVNode16("", true),
            createElementVNode13("span", _hoisted_117, [
              renderSlot30(_ctx.$slots, "default")
            ]),
            __props.closeable ? (openBlock35(), createBlock17(unref36(VaIcon), {
              key: 1,
              role: "button",
              name: "va-close",
              class: "va-chip__close-icon",
              "aria-label": unref36(tp)(_ctx.$props.ariaCloseLabel),
              tabindex: tabIndexComputed.value,
              size: iconSize.value,
              onClick: withModifiers6(close, ["stop"]),
              onKeydown: [
                withKeys7(withModifiers6(close, ["stop"]), ["enter"]),
                withKeys7(withModifiers6(close, ["stop"]), ["space"])
              ]
            }, null, 8, ["aria-label", "tabindex", "size", "onKeydown"])) : createCommentVNode16("", true)
          ], 16)
        ]),
        _: 3
      }, 8, ["href", "target", "to", "replace", "exact", "active-class", "exact-active-class", "class", "style"])) : createCommentVNode16("", true);
    };
  }
});

// node_modules/vuestic-ui/dist/es/src/components/va-chip/index.js
var VaChip = withConfigTransport$1(_sfc_main38);

// node_modules/vuestic-ui/dist/es/src/components/va-collapse/VaCollapse.vue_vue_type_script_setup_true_lang.js
import { defineComponent as defineComponent39, shallowRef as shallowRef12, computed as computed90, ref as ref32, watch as watch23, openBlock as openBlock36, createElementBlock as createElementBlock30, normalizeClass as normalizeClass19, unref as unref37, createElementVNode as createElementVNode14, withKeys as withKeys8, renderSlot as renderSlot31, normalizeProps as normalizeProps11, guardReactiveProps as guardReactiveProps7, mergeProps as mergeProps16, createBlock as createBlock18, createCommentVNode as createCommentVNode17, toDisplayString as toDisplayString13, createVNode as createVNode14, normalizeStyle as normalizeStyle21 } from "vue";
import "D:/Desktop/forntend/Front_End_Web_Hotel_Nhom_2/my-nuxt-app/node_modules/vuestic-ui/dist/es/VaCollapse.css";
var _hoisted_118 = { class: "va-collapse__header__text" };
var _hoisted_29 = ["id", "aria-labelledby"];
var _hoisted_35 = { class: "va-collapse__content" };
var _sfc_main39 = defineComponent39({
  ...{
    name: "VaCollapse"
  },
  __name: "VaCollapse",
  props: {
    ...useComponentPresetProp,
    ...useStatefulProps,
    modelValue: { type: Boolean, default: false },
    disabled: { type: Boolean, default: false },
    header: { type: String, default: "" },
    icon: { type: String, default: "" },
    color: { type: String, default: void 0 },
    bodyColor: { type: String, default: void 0 },
    textColor: { type: String, default: "" },
    bodyTextColor: { type: String, default: "" },
    iconColor: { type: String, default: "secondary" },
    colorAll: { type: Boolean, default: false },
    stateful: { type: Boolean, default: true }
  },
  emits: ["update:modelValue", ...useSelectableEmits],
  setup(__props, { expose: __expose, emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const body = shallowRef12();
    const { valueComputed } = useStateful(props, emit, "modelValue");
    const { getColor, getTextColor, setHSLAColor: setHSLAColor2 } = useColors();
    const { accordionProps, accordionItemValue } = useAccordionItem();
    const computedModelValue = computed90({
      get() {
        if (valueComputed.userProvided) {
          return valueComputed.value;
        }
        if (!isNilValue(accordionItemValue)) {
          return accordionItemValue.value;
        }
        return valueComputed.value;
      },
      set(v) {
        if (!isNilValue(accordionItemValue)) {
          accordionItemValue.value = v;
        }
        valueComputed.value = v;
      }
    });
    if (valueComputed.userProvided && !isNilValue(accordionItemValue)) {
      accordionItemValue.value = valueComputed.value;
    }
    const bodyHeight = ref32();
    useResizeObserver([body], ([body2]) => {
      bodyHeight.value = body2.contentRect.height ?? 0;
    });
    const height = computed90(() => computedModelValue.value ? bodyHeight.value : 0);
    const getTransition = () => {
      const duration = height.value / 1e3 * 0.2;
      return `${duration > 0.2 ? duration : 0.2}s`;
    };
    const contentBackground = computed90(() => {
      if (props.bodyColor) {
        return getColor(props.bodyColor);
      }
      return props.color && props.colorAll ? setHSLAColor2(getColor(props.color), { a: 0.07 }) : void 0;
    });
    const headerBackground = computed90(() => {
      return props.color ? getColor(props.color) : void 0;
    });
    const uniqueId = useComponentUuid();
    const headerIdComputed = computed90(() => `header-${uniqueId}`);
    const panelIdComputed = computed90(() => `panel-${uniqueId}`);
    const tabIndexComputed = computed90(() => props.disabled ? -1 : 0);
    const headerAttributes = computed90(() => ({
      id: headerIdComputed.value,
      tabindex: tabIndexComputed.value,
      "aria-controls": panelIdComputed.value,
      "aria-expanded": computedModelValue.value,
      "aria-disabled": props.disabled,
      role: "button"
    }));
    const isHeightChanging = ref32(false);
    watch23(height, (newValue, oldValue) => {
      if (oldValue === void 0) {
        return;
      }
      if (isHeightChanging.value === true) {
        return;
      }
      isHeightChanging.value = true;
    });
    const onTransitionEnd = (e) => {
      if (e.propertyName === "height" && e.target === e.currentTarget) {
        isHeightChanging.value = false;
      }
    };
    const computedClasses = useBem("va-collapse", () => ({
      ...pick(props, ["disabled"]),
      expanded: computedModelValue.value,
      active: computedModelValue.value,
      popout: !!(accordionProps.value.popout && computedModelValue.value),
      inset: !!(accordionProps.value.inset && computedModelValue.value),
      "height-changing": isHeightChanging.value,
      "colored-body": Boolean(contentBackground.value),
      "colored-header": Boolean(headerBackground.value)
    }));
    const toggle = () => {
      if (props.disabled) {
        return;
      }
      computedModelValue.value = !computedModelValue.value;
    };
    const { textColorComputed } = useTextColor(headerBackground);
    const headerStyle = computed90(() => ({
      color: textColorComputed.value,
      backgroundColor: headerBackground.value
    }));
    const doRenderBody = computed90(() => {
      if (computedModelValue.value) {
        return true;
      }
      if (isHeightChanging.value) {
        return true;
      }
      return false;
    });
    const contentStyle = computed90(() => {
      return {
        height: `${height.value}px`,
        transitionDuration: getTransition(),
        background: computedModelValue.value ? contentBackground.value : "",
        color: props.bodyTextColor ? getColor(props.bodyTextColor) : contentBackground.value ? getColor(getTextColor(contentBackground.value)) : "currentColor"
      };
    });
    __expose({
      toggle
    });
    return (_ctx, _cache) => {
      return openBlock36(), createElementBlock30("div", {
        class: normalizeClass19(["va-collapse", unref37(computedClasses)])
      }, [
        createElementVNode14("div", {
          class: "va-collapse__header-wrapper",
          onClick: toggle,
          onKeydown: [
            withKeys8(toggle, ["enter"]),
            withKeys8(toggle, ["space"])
          ]
        }, [
          renderSlot31(_ctx.$slots, "header", normalizeProps11(guardReactiveProps7({
            value: computedModelValue.value,
            bind: headerAttributes.value,
            attributes: headerAttributes.value,
            attrs: headerAttributes.value,
            iconAttrs: {
              class: [
                "va-collapse__expand-icon",
                computedModelValue.value ? "a-collapse__expand-icon--expanded" : "a-collapse__expand-icon--collapsed"
              ]
            },
            text: __props.header
          })), () => [
            createElementVNode14("div", mergeProps16(headerAttributes.value, {
              class: "va-collapse__header",
              style: headerStyle.value
            }), [
              __props.icon ? (openBlock36(), createBlock18(unref37(VaIcon), {
                key: 0,
                class: "va-collapse__header__icon",
                name: __props.icon
              }, null, 8, ["name"])) : createCommentVNode17("", true),
              renderSlot31(_ctx.$slots, "header-content", normalizeProps11(guardReactiveProps7({ header: __props.header })), () => [
                createElementVNode14("div", _hoisted_118, toDisplayString13(__props.header), 1)
              ]),
              renderSlot31(_ctx.$slots, "expand-icon", {}, () => [
                createVNode14(unref37(VaIcon), {
                  class: normalizeClass19(["va-collapse__expand-icon", computedModelValue.value ? "va-collapse__expand-icon--expanded" : "va-collapse__expand-icon--collapsed"]),
                  name: "va-arrow-down"
                }, null, 8, ["class"])
              ])
            ], 16)
          ])
        ], 32),
        createElementVNode14("div", {
          class: normalizeClass19(["va-collapse__body-wrapper", {
            "va-collapse__body-wrapper--bordered": !_ctx.$slots.body && !_ctx.$slots.header
          }]),
          style: normalizeStyle21(contentStyle.value),
          onTransitionend: onTransitionEnd
        }, [
          doRenderBody.value ? (openBlock36(), createElementBlock30("div", {
            key: 0,
            class: "va-collapse__body",
            ref_key: "body",
            ref: body,
            role: "region",
            id: panelIdComputed.value,
            "aria-labelledby": headerIdComputed.value
          }, [
            renderSlot31(_ctx.$slots, "body", {}, () => [
              createElementVNode14("div", _hoisted_35, [
                renderSlot31(_ctx.$slots, "default", {}, () => [
                  renderSlot31(_ctx.$slots, "content")
                ])
              ])
            ])
          ], 8, _hoisted_29)) : createCommentVNode17("", true)
        ], 38)
      ], 2);
    };
  }
});

// node_modules/vuestic-ui/dist/es/src/components/va-collapse/index.js
var VaCollapse = withConfigTransport$1(_sfc_main39);

// node_modules/vuestic-ui/dist/es/src/components/va-color-indicator/VaColorIndicator.vue_vue_type_script_setup_true_lang.js
import { defineComponent as defineComponent40, computed as computed91, openBlock as openBlock37, createElementBlock as createElementBlock31, mergeProps as mergeProps17, withKeys as withKeys9, toHandlers as toHandlers4, unref as unref38, createElementVNode as createElementVNode15, normalizeStyle as normalizeStyle22 } from "vue";
import "D:/Desktop/forntend/Front_End_Web_Hotel_Nhom_2/my-nuxt-app/node_modules/vuestic-ui/dist/es/VaColorIndicator.css";
var _sfc_main40 = defineComponent40({
  ...{
    name: "VaColorIndicator"
  },
  __name: "VaColorIndicator",
  props: {
    ...useStatefulProps,
    ...useComponentPresetProp,
    modelValue: { type: Boolean, default: null },
    color: { type: String, default: "" },
    square: { type: Boolean, default: false },
    size: { type: String, default: "1rem" }
  },
  emits: [...useStatefulEmits],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const { valueComputed } = useStateful(props, emit);
    const { getColor } = useColors();
    const { hasKeyboardFocus, keyboardFocusListeners } = useKeyboardOnlyFocus();
    const colorComputed = computed91(() => getColor(props.color));
    const borderRadiusComputed = computed91(() => props.square ? "0px" : "50%");
    const computedStyle = computed91(() => ({
      backgroundColor: colorComputed.value,
      height: props.size,
      width: props.size
    }));
    const computedClass = computed91(() => ({
      "va-color-indicator--selected": valueComputed.value,
      "va-color-indicator--on-keyboard-focus": hasKeyboardFocus.value
    }));
    const toggleModelValue = () => {
      valueComputed.value = !valueComputed.value;
    };
    return (_ctx, _cache) => {
      return openBlock37(), createElementBlock31("div", mergeProps17({
        class: ["va-color-indicator", computedClass.value],
        style: [computedStyle.value, `--va-border-radius-computed: ${String(borderRadiusComputed.value)}`],
        onClick: toggleModelValue,
        onKeydown: [
          withKeys9(toggleModelValue, ["enter"]),
          withKeys9(toggleModelValue, ["space"])
        ]
      }, toHandlers4(unref38(keyboardFocusListeners), true)), [
        createElementVNode15("div", {
          class: "va-color-indicator__core",
          style: normalizeStyle22(computedStyle.value)
        }, null, 4)
      ], 16);
    };
  }
});

// node_modules/vuestic-ui/dist/es/src/components/va-color-indicator/index.js
var VaColorIndicator = withConfigTransport$1(_sfc_main40);

// node_modules/vuestic-ui/dist/es/src/components/va-color-input/VaColorInput.vue_vue_type_script_setup_true_lang.js
import { defineComponent as defineComponent45, shallowRef as shallowRef14, computed as computed98, openBlock as openBlock41, createElementBlock as createElementBlock35, createVNode as createVNode16, unref as unref41, mergeProps as mergeProps20, isRef as isRef6, withCtx as withCtx21, withKeys as withKeys11, withDirectives as withDirectives5, createElementVNode as createElementVNode17, vModelText } from "vue";

// node_modules/vuestic-ui/dist/es/src/components/va-input/VaInput.vue_vue_type_script_setup_true_lang.js
import { defineComponent as defineComponent44, shallowRef as shallowRef13, useSlots as useSlots5, computed as computed97, toRefs as toRefs2, watch as watch24, useAttrs as useAttrs2, openBlock as openBlock40, createBlock as createBlock20, unref as unref40, mergeProps as mergeProps19, createSlots as createSlots2, withCtx as withCtx20, withModifiers as withModifiers7, withKeys as withKeys10, createCommentVNode as createCommentVNode20, renderSlot as renderSlot34, normalizeProps as normalizeProps14, guardReactiveProps as guardReactiveProps10, withDirectives as withDirectives4, createElementBlock as createElementBlock34, isRef as isRef5, vModelDynamic as vModelDynamic2, renderList as renderList5 } from "vue";

// node_modules/vuestic-ui/dist/es/src/components/va-input-wrapper/VaInputWrapper.vue_vue_type_script_lang.js
import { defineComponent as defineComponent43, ref as ref33, computed as computed95 } from "vue";

// node_modules/vuestic-ui/dist/es/src/components/va-input-wrapper/components/VaInputLabel.vue_vue_type_script_setup_true_lang.js
import { defineComponent as defineComponent41, openBlock as openBlock38, createElementBlock as createElementBlock32, normalizeStyle as normalizeStyle23, unref as unref39, renderSlot as renderSlot32, normalizeProps as normalizeProps12, guardReactiveProps as guardReactiveProps8, createTextVNode as createTextVNode12, toDisplayString as toDisplayString14, createCommentVNode as createCommentVNode18 } from "vue";
import "D:/Desktop/forntend/Front_End_Web_Hotel_Nhom_2/my-nuxt-app/node_modules/vuestic-ui/dist/es/VaInputLabel.css";
var _hoisted_119 = {
  key: 0,
  class: "va-input-label__required-mark"
};
var _sfc_main41 = defineComponent41({
  ...{
    name: "VaInputLabel"
  },
  __name: "VaInputLabel",
  props: {
    label: {
      type: String,
      default: ""
    },
    requiredMark: {
      type: Boolean,
      default: false
    },
    color: {
      type: String,
      default: "primary"
    }
  },
  setup(__props) {
    const { getColor } = useColors();
    return (_ctx, _cache) => {
      return openBlock38(), createElementBlock32("label", {
        "aria-hidden": "true",
        class: "va-input-label",
        style: normalizeStyle23({ color: unref39(getColor)(_ctx.$props.color, void 0, true) })
      }, [
        renderSlot32(_ctx.$slots, "default", normalizeProps12(guardReactiveProps8({ label: __props.label, requiredMark: __props.requiredMark, color: unref39(getColor)(_ctx.$props.color) })), () => [
          createTextVNode12(toDisplayString14(__props.label) + " ", 1),
          __props.requiredMark ? (openBlock38(), createElementBlock32("span", _hoisted_119, " * ")) : createCommentVNode18("", true)
        ])
      ], 4);
    };
  }
});

// node_modules/vuestic-ui/dist/es/src/components/va-input-wrapper/hooks/useInputFieldAria.js
import { computed as computed92 } from "vue";
var useInputFieldAriaProps = {
  label: { type: String, default: "" },
  inputAriaLabel: useTranslationProp("$t:inputField"),
  inputAriaLabelledby: { type: String },
  inputAriaDescribedby: { type: String }
};
var useInputFieldAria = (props) => {
  const id = useComponentUuid();
  const labelId = `input-label-${id}`;
  const characterCountId = `input-character-count-${id}`;
  const ariaAttributes = computed92(() => ({
    "aria-label": props.label !== "" ? props.label : props.inputAriaLabel,
    "aria-labelledby": props.inputAriaLabelledby ? props.inputAriaLabelledby : labelId,
    "aria-describedby": props.inputAriaDescribedby ? props.inputAriaDescribedby : characterCountId
  }));
  return {
    labelId,
    characterCountId,
    ariaAttributes
  };
};

// node_modules/vuestic-ui/dist/es/src/utils/with-slot-inheritance/with-slot-inheritance.js
import { defineComponent as defineComponent42, h as h9 } from "vue";
var WithSlotInheritance = (component) => {
  return defineComponent42({
    name: "ProxySlots",
    props: {
      inheritSlots: { type: Array, required: true }
    },
    render() {
      var _a2;
      const parentSlots = ((_a2 = this.$parent) == null ? void 0 : _a2.$slots) || {};
      const slotsToProxy = this.$props.inheritSlots || Object.keys(parentSlots);
      const slots = slotsToProxy.reduce(
        (slots2, name) => {
          if (parentSlots[name]) {
            slots2[name] = parentSlots[name];
          }
          return slots2;
        },
        {}
      );
      return h9(component, this.$attrs, {
        ...slots,
        ...this.$slots
      });
    }
  });
};

// node_modules/vuestic-ui/dist/es/src/composables/useFormField.js
import { computed as computed93 } from "vue";
var useFormFieldProps = {
  disabled: { type: Boolean, default: false },
  readonly: { type: Boolean, default: false }
};
var useFormField = (prefix2, props) => {
  const computedClasses = useBem(prefix2, computed93(() => pick(props, ["disabled", "readonly"])));
  return { computedClasses };
};

// node_modules/vuestic-ui/dist/es/src/composables/useFocusDeep.js
import { computed as computed94 } from "vue";
var useFocusDeep = (el) => {
  const focused = useActiveElement();
  const current = useCurrentElement(el ? useHTMLElement(el) : void 0);
  let previouslyFocusedElement = null;
  const isFocused = computed94({
    get() {
      var _a2;
      if (!focused.value) {
        return false;
      }
      if (focused.value === current.value) {
        return true;
      }
      const isFocused2 = (_a2 = current.value) == null ? void 0 : _a2.contains(focused.value);
      if (isFocused2) {
        previouslyFocusedElement = focused.value;
      }
      return isFocused2;
    },
    set(value) {
      var _a2;
      let target = previouslyFocusedElement ?? current.value;
      if (!((_a2 = current.value) == null ? void 0 : _a2.contains(target))) {
        target = current.value;
      }
      if (value) {
        target == null ? void 0 : target.focus();
      } else {
        target == null ? void 0 : target.blur();
      }
    }
  });
  return Object.assign(isFocused, {
    /** Focus `el` if focus is not set to any other element */
    focusIfNothingIfFocused: () => {
      if (focused.value === document.body) {
        isFocused.value = true;
      }
    },
    focusPreviousElement: () => {
      if (previouslyFocusedElement) {
        previouslyFocusedElement.focus();
      } else {
        document.body.focus();
      }
    }
  });
};

// node_modules/vuestic-ui/dist/es/src/components/va-input-wrapper/VaInputWrapper.vue_vue_type_script_lang.js
import "D:/Desktop/forntend/Front_End_Web_Hotel_Nhom_2/my-nuxt-app/node_modules/vuestic-ui/dist/es/VaInputWrapper.css";
var VaInputLabelProps = extractComponentProps(_sfc_main41);
var _sfc_main42 = defineComponent43({
  name: "VaInputWrapper",
  components: { VaMessageList: WithSlotInheritance(VaMessageList), VaIcon, VaInputLabel: _sfc_main41 },
  props: {
    ...useComponentPresetProp,
    ...useInputFieldAriaProps,
    ...useFormFieldProps,
    ...useValidationProps,
    ...VaInputLabelProps,
    modelValue: { type: null, default: "" },
    counter: { type: Boolean },
    maxLength: { type: [Number, String], default: void 0 },
    label: { type: String, default: "" },
    placeholder: { type: String, default: "" },
    color: { type: String, default: "primary" },
    background: { type: String },
    success: { type: Boolean, default: false },
    loading: { type: Boolean, default: false },
    requiredMark: { type: Boolean, default: false },
    innerLabel: { type: Boolean, default: false }
  },
  emits: [
    "click",
    "click-prepend",
    "click-append",
    "click-prepend-inner",
    "click-append-inner",
    "click-field",
    "update:modelValue"
  ],
  setup(props, { emit, slots }) {
    const { getColor } = useColors();
    const [vModel] = useSyncProp("modelValue", props, emit, "");
    const inputRef = ref33();
    const isFocused = useFocusDeep();
    const counterValue = computed95(
      () => props.counter && typeof vModel.value === "string" ? vModel.value.length : void 0
    );
    const wrapperClass = useBem("va-input-wrapper", () => ({
      ...pick(props, ["success", "error", "disabled", "readonly"]),
      focused: Boolean(isFocused.value),
      labeled: Boolean(props.label || slots.label),
      labeledInner: Boolean(props.label || slots.label) && props.innerLabel
    }));
    const colorComputed = computed95(() => getColor(props.color));
    const backgroundComputed = computed95(() => props.background ? getColor(props.background) : "#ffffff00");
    const messagesComputed = computed95(() => props.error ? props.errorMessages : props.messages);
    const { textColorComputed } = useTextColor(backgroundComputed);
    const maxLengthComputed = useNumericProp("maxLength");
    const messagesColor = computed95(() => {
      if (props.error) {
        return "danger";
      }
      if (props.success) {
        return "success";
      }
      return "";
    });
    const errorLimit = computed95(() => props.error ? Number(props.errorCount) : 99);
    const isCounterVisible = computed95(() => counterValue.value !== void 0);
    const counterComputed = computed95(
      () => maxLengthComputed.value !== void 0 ? `${counterValue.value}/${maxLengthComputed.value}` : counterValue.value
    );
    const {
      labelId,
      characterCountId,
      ariaAttributes
    } = useInputFieldAria(props);
    const vaInputLabelProps = filterComponentProps(VaInputLabelProps);
    const focus = () => {
      isFocused.value = true;
    };
    const blur = () => {
      isFocused.value = false;
    };
    return {
      inputRef,
      focus,
      blur,
      labelId,
      characterCountId,
      ariaAttributes,
      vModel,
      counterValue,
      vaInputLabelProps,
      wrapperClass,
      textColorComputed,
      isCounterVisible,
      counterComputed,
      colorComputed,
      backgroundComputed,
      messagesColor,
      messagesComputed,
      errorLimit
    };
  }
});

// node_modules/vuestic-ui/dist/es/src/components/va-input-wrapper/VaInputWrapper.js
import { resolveComponent, openBlock as openBlock39, createElementBlock as createElementBlock33, normalizeClass as normalizeClass20, normalizeStyle as normalizeStyle24, createElementVNode as createElementVNode16, createVNode as createVNode15, withCtx as withCtx19, createBlock as createBlock19, mergeProps as mergeProps18, renderSlot as renderSlot33, normalizeProps as normalizeProps13, guardReactiveProps as guardReactiveProps9, createCommentVNode as createCommentVNode19, withDirectives as withDirectives3, vModelDynamic, toDisplayString as toDisplayString15 } from "vue";
import "D:/Desktop/forntend/Front_End_Web_Hotel_Nhom_2/my-nuxt-app/node_modules/vuestic-ui/dist/es/VaInputWrapper.css";
var _hoisted_120 = { class: "va-input-wrapper__fieldset va-input-wrapper__size-keeper" };
var _hoisted_210 = { class: "va-input-wrapper__container" };
var _hoisted_36 = { class: "va-input-wrapper__text" };
var _hoisted_45 = ["placeholder", "readonly", "disabled"];
var _hoisted_54 = ["id"];
var _hoisted_64 = { class: "va-input-wrapper__counter" };
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_VaInputLabel = resolveComponent("VaInputLabel");
  const _component_va_icon = resolveComponent("va-icon");
  const _component_va_message_list = resolveComponent("va-message-list");
  return openBlock39(), createElementBlock33("div", {
    class: normalizeClass20(["va-input-wrapper", _ctx.wrapperClass]),
    onClick: _cache[6] || (_cache[6] = ($event) => _ctx.$emit("click", $event)),
    style: normalizeStyle24(`--va-background-computed: ${String(_ctx.backgroundComputed)};--va-color-computed: ${String(_ctx.colorComputed)};--va-text-color-computed: ${String(_ctx.textColorComputed)}`)
  }, [
    createElementVNode16("fieldset", _hoisted_120, [
      createVNode15(_component_va_message_list, {
        color: _ctx.messagesColor,
        "model-value": _ctx.messagesComputed,
        limit: _ctx.errorLimit,
        "inherit-slots": ["message", "messages"]
      }, {
        default: withCtx19(({ ariaAttributes: messagesChildAriaAttributes }) => [
          (_ctx.$props.label || _ctx.$slots.label) && !_ctx.$props.innerLabel ? (openBlock39(), createBlock19(_component_VaInputLabel, mergeProps18({
            key: 0,
            class: "va-input-wrapper__label va-input-wrapper__label--outer"
          }, _ctx.vaInputLabelProps, { id: _ctx.labelId }), {
            default: withCtx19((bind) => [
              renderSlot33(_ctx.$slots, "label", normalizeProps13(guardReactiveProps9(bind)))
            ]),
            _: 3
          }, 16, ["id"])) : createCommentVNode19("", true),
          createElementVNode16("div", _hoisted_210, [
            _ctx.$slots.prepend ? (openBlock39(), createElementBlock33("div", {
              key: 0,
              class: "va-input-wrapper__prepend-inner",
              onClick: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("click-prepend"))
            }, [
              renderSlot33(_ctx.$slots, "prepend")
            ])) : createCommentVNode19("", true),
            createElementVNode16("div", {
              onClick: _cache[4] || (_cache[4] = ($event) => _ctx.$emit("click-field", $event)),
              class: "va-input-wrapper__field"
            }, [
              _ctx.$slots.prependInner ? (openBlock39(), createElementBlock33("div", {
                key: 0,
                class: "va-input-wrapper__prepend-inner",
                ref: "container",
                onClick: _cache[1] || (_cache[1] = ($event) => _ctx.$emit("click-prepend-inner", $event))
              }, [
                renderSlot33(_ctx.$slots, "prependInner")
              ], 512)) : createCommentVNode19("", true),
              createElementVNode16("div", _hoisted_36, [
                (_ctx.$props.label || _ctx.$slots.label) && _ctx.$props.innerLabel ? (openBlock39(), createBlock19(_component_VaInputLabel, mergeProps18({
                  key: 0,
                  class: "va-input-wrapper__label va-input-wrapper__label--inner"
                }, _ctx.vaInputLabelProps, { id: _ctx.labelId }), {
                  default: withCtx19((bind) => [
                    renderSlot33(_ctx.$slots, "label", normalizeProps13(guardReactiveProps9(bind)))
                  ]),
                  _: 3
                }, 16, ["id"])) : createCommentVNode19("", true),
                renderSlot33(_ctx.$slots, "default", normalizeProps13(guardReactiveProps9({ ariaAttributes: { ...messagesChildAriaAttributes, ..._ctx.ariaAttributes }, value: _ctx.vModel })), () => [
                  withDirectives3(createElementVNode16("input", mergeProps18({ ...messagesChildAriaAttributes, ..._ctx.ariaAttributes }, {
                    "onUpdate:modelValue": _cache[2] || (_cache[2] = ($event) => _ctx.vModel = $event),
                    ref: "inputRef",
                    placeholder: _ctx.$props.placeholder,
                    readonly: _ctx.$props.readonly,
                    disabled: _ctx.$props.disabled
                  }), null, 16, _hoisted_45), [
                    [vModelDynamic, _ctx.vModel]
                  ])
                ])
              ]),
              _ctx.success ? (openBlock39(), createBlock19(_component_va_icon, {
                key: 1,
                color: "success",
                name: "va-check-circle",
                class: "va-input-wrapper__icon va-input-wrapper__icon--success"
              })) : createCommentVNode19("", true),
              _ctx.error ? (openBlock39(), createBlock19(_component_va_icon, {
                key: 2,
                color: "danger",
                name: "va-warning",
                class: "va-input-wrapper__icon va-input-wrapper__icon--error"
              })) : createCommentVNode19("", true),
              _ctx.$props.loading ? (openBlock39(), createBlock19(_component_va_icon, {
                key: 3,
                color: _ctx.$props.color,
                name: "va-loading",
                spin: "counter-clockwise",
                class: "va-input-wrapper__icon va-input-wrapper__icon--loading"
              }, null, 8, ["color"])) : createCommentVNode19("", true),
              renderSlot33(_ctx.$slots, "icon"),
              _ctx.$slots.appendInner ? (openBlock39(), createElementBlock33("div", {
                key: 4,
                class: "va-input-wrapper__append-inner",
                onClick: _cache[3] || (_cache[3] = ($event) => _ctx.$emit("click-append-inner", $event))
              }, [
                renderSlot33(_ctx.$slots, "appendInner")
              ])) : createCommentVNode19("", true)
            ]),
            _ctx.$slots.append ? (openBlock39(), createElementBlock33("div", {
              key: 1,
              class: "va-input-wrapper__append-inner",
              onClick: _cache[5] || (_cache[5] = ($event) => _ctx.$emit("click-append"))
            }, [
              renderSlot33(_ctx.$slots, "append")
            ])) : createCommentVNode19("", true)
          ]),
          _ctx.isCounterVisible ? (openBlock39(), createElementBlock33("div", {
            key: 1,
            class: "va-input-wrapper__counter-wrapper",
            id: _ctx.characterCountId
          }, [
            renderSlot33(_ctx.$slots, "counter", normalizeProps13(guardReactiveProps9({ valueLength: _ctx.counterValue, maxLength: _ctx.$props.maxLength })), () => [
              createElementVNode16("div", _hoisted_64, toDisplayString15(_ctx.counterComputed), 1)
            ])
          ], 8, _hoisted_54)) : createCommentVNode19("", true)
        ]),
        _: 3
      }, 8, ["color", "model-value", "limit"])
    ])
  ], 6);
}
var _VaInputWrapper = _export_sfc(_sfc_main42, [["render", _sfc_render]]);

// node_modules/vuestic-ui/dist/es/src/components/va-input-wrapper/index.js
var VaInputWrapper = withConfigTransport$1(_VaInputWrapper);

// node_modules/vuestic-ui/dist/es/src/utils/combine-functions.js
var combineFunctions = (...list) => {
  return (...args) => list.forEach((fn) => fn(...args));
};

// node_modules/vuestic-ui/dist/es/src/composables/useFocusable.js
import { onMounted as onMounted18 } from "vue";
var useFocusableProps = {
  /** Focus element when mounted */
  autofocus: { type: Boolean, default: false }
};
var useFocusable = (el, props) => {
  const focus = () => {
    focusElement(unwrapEl(el.value));
  };
  const blur = () => {
    blurElement(unwrapEl(el.value));
  };
  onMounted18(() => {
    if (props.autofocus) {
      focus();
    }
  });
  return {
    focus,
    blur
  };
};

// node_modules/vuestic-ui/dist/es/src/composables/useClearable.js
import { computed as computed96 } from "vue";
var useClearableProps = {
  clearable: { type: Boolean, default: false },
  clearableIcon: { type: String, default: "va-clear" },
  clearValue: { type: String, default: "" }
};
var useClearableEmits = ["clear"];
var useClearable = (props, inputValue, el, hasError) => {
  const { isFocused, onFocus, onBlur } = useFocus(el);
  const clearedValues = [null, void 0, props.clearValue];
  const canBeCleared = computed96(() => props.clearable && !props.disabled && !props.readonly && !clearedValues.includes(inputValue.value));
  const clearIconColor = computed96(() => {
    if (isFocused == null ? void 0 : isFocused.value) {
      return props.color || "primary";
    }
    if (hasError == null ? void 0 : hasError.value) {
      return "danger";
    }
    if (props.success) {
      return "success";
    }
    return "secondary";
  });
  const clearIconProps = computed96(() => ({
    name: props.clearableIcon,
    color: clearIconColor.value,
    size: "medium",
    tabindex: canBeCleared.value ? 0 : -1
  }));
  return {
    canBeCleared,
    clearIconColor,
    clearIconProps,
    onFocus,
    onBlur
  };
};

// node_modules/vuestic-ui/dist/es/src/composables/useDeprecatedCondition.js
import { getCurrentInstance as getCurrentInstance24 } from "vue";
var useDeprecatedCondition = (validators) => {
  if (!isDev) {
    return void 0;
  }
  const instance = getCurrentInstance24();
  if (!instance) {
    throw new Error("`useDeprecated` hook must be used only inside of setup function!");
  }
  validators.forEach((validator) => {
    const message = validator();
    if (typeof message === "string") {
      warn(`(${instance.type.name} component) ${message}`);
    }
  });
};

// node_modules/vuestic-ui/dist/es/src/components/va-input/VaInput.vue_vue_type_script_setup_true_lang.js
var VaInputWrapperProps = extractComponentProps(VaInputWrapper);
var { createEmits: createInputEmits, createListeners: createInputListeners } = useEmitProxy(
  ["change", "keyup", "keypress", "keydown", "focus", "blur", "input"]
);
var { createEmits: createFieldEmits, createListeners: createFieldListeners } = useEmitProxy([
  "click",
  "click-prepend",
  "click-append",
  "click-prepend-inner",
  "click-append-inner"
]);
var _sfc_main43 = defineComponent44({
  ...{
    name: "VaInput"
  },
  __name: "VaInput",
  props: {
    ...VaInputWrapperProps,
    ...useFormFieldProps,
    ...useFocusableProps,
    ...useValidationProps,
    ...useClearableProps,
    ...useComponentPresetProp,
    ...useStatefulProps,
    // input
    placeholder: { type: String, default: "" },
    tabindex: { type: [String, Number], default: 0 },
    modelValue: { type: [Number, String, null], default: "" },
    type: { type: String, default: "text" },
    inputClass: { type: String, default: "" },
    pattern: { type: String },
    inputmode: { type: String, default: "text" },
    counter: { type: Boolean, default: false },
    autocomplete: { type: String },
    // style
    ariaResetLabel: useTranslationProp("$t:reset"),
    /** Set value to input when model value is updated */
    strictBindInputValue: { type: Boolean, default: false }
  },
  emits: [
    "update:modelValue",
    ...useValidationEmits,
    ...useClearableEmits,
    ...createInputEmits(),
    ...createFieldEmits(),
    ...useStatefulEmits
  ],
  setup(__props, { expose: __expose, emit: __emit }) {
    const props = __props;
    const emit = __emit;
    useDeprecatedCondition([
      () => props.type !== "textarea" || 'Use VaTextarea component instead of VaInput with type="textarea"'
    ]);
    const input = shallowRef13();
    const { valueComputed } = useStateful(props, emit, "modelValue");
    const reset = () => withoutValidation(() => {
      valueComputed.value = props.clearValue;
      emit("clear");
      resetValidation();
    });
    const { focus, blur } = useFocusable(input, props);
    const slots = useSlots5();
    const filterSlots = computed97(() => {
      const iconSlot = ["icon"];
      return Object.keys(slots).filter((slot) => !iconSlot.includes(slot));
    });
    const { tp } = useTranslation();
    const {
      isValid,
      isTouched,
      isDirty,
      computedError,
      computedErrorMessages,
      listeners: { onBlur },
      validationAriaAttributes,
      isLoading,
      withoutValidation,
      resetValidation
    } = useValidation(props, emit, { reset, focus, value: valueComputed });
    const { modelValue } = toRefs2(props);
    const {
      canBeCleared,
      clearIconProps
    } = useClearable(props, modelValue, input, computedError);
    const inputListeners = createInputListeners(emit);
    const inputEvents = {
      ...inputListeners,
      onBlur: combineFunctions(onBlur, inputListeners.onBlur)
    };
    const setInputValue = (newValue) => {
      if (!props.strictBindInputValue) {
        return;
      }
      const target = input.value;
      if (!target) {
        return;
      }
      const selectionStart = target.selectionStart || 0;
      const selectionEnd = target.selectionEnd || 0;
      if (target.value !== newValue) {
        target.value = String(newValue);
      }
      target.setSelectionRange(selectionStart, selectionEnd);
    };
    watch24(valueComputed, (newValue) => {
      setInputValue(String(newValue));
    }, { immediate: true });
    useEvent("input", () => {
      setInputValue(String(valueComputed.value));
    }, input);
    const tabIndexComputed = computed97(() => props.disabled ? -1 : props.tabindex);
    const attrs = useAttrs2();
    const computedChildAttributes = computed97(() => ({
      "aria-label": props.inputAriaLabel || props.label,
      "aria-labelledby": props.inputAriaLabelledby,
      "aria-required": props.requiredMark,
      tabindex: tabIndexComputed.value,
      class: props.inputClass,
      "aria-disabled": props.disabled,
      "aria-readonly": props.readonly,
      ...validationAriaAttributes.value
    }));
    const computedInputAttributes = computed97(() => ({
      ...computedChildAttributes.value,
      ...pick(props, ["type", "disabled", "readonly", "placeholder", "pattern", "inputmode", "name", "autocomplete"]),
      ...pick(attrs, ["minlength", "minlength"])
    }));
    const valueLengthComputed = computed97(
      () => props.counter && typeof valueComputed.value === "string" ? valueComputed.value.length : void 0
    );
    const onFieldClick = (e) => {
      if (!e.target || !("tagName" in e.target)) {
        return;
      }
      if (e.target.tagName === "INPUT" || e.target.tagName === "TEXTAREA") {
        return;
      }
      focus();
    };
    const wrapperProps = filterComponentProps(VaInputWrapperProps);
    const fieldListeners = createFieldListeners(emit);
    __expose({
      isValid,
      isDirty,
      isTouched,
      isLoading,
      computedError,
      computedErrorMessages,
      reset,
      focus,
      blur,
      value: valueComputed,
      withoutValidation,
      resetValidation
    });
    return (_ctx, _cache) => {
      return openBlock40(), createBlock20(unref40(VaInputWrapper), mergeProps19({
        ...unref40(fieldListeners),
        ...unref40(wrapperProps)
      }, {
        class: ["va-input", _ctx.$attrs.class],
        style: _ctx.$attrs.style,
        loading: _ctx.$props.loading || unref40(isLoading),
        error: unref40(computedError),
        "error-messages": unref40(computedErrorMessages),
        "error-count": _ctx.errorCount,
        "counter-value": valueLengthComputed.value,
        onClick: onFieldClick
      }), createSlots2({
        icon: withCtx20((slotScope) => [
          unref40(canBeCleared) ? (openBlock40(), createBlock20(unref40(VaIcon), mergeProps19({
            key: 0,
            role: "button",
            "aria-label": unref40(tp)(_ctx.$props.ariaResetLabel)
          }, unref40(clearIconProps), {
            onClick: withModifiers7(reset, ["stop"]),
            onKeydown: [
              withKeys10(withModifiers7(reset, ["stop"]), ["enter"]),
              withKeys10(withModifiers7(reset, ["stop"]), ["space"])
            ]
          }), null, 16, ["aria-label", "onKeydown"])) : createCommentVNode20("", true),
          renderSlot34(_ctx.$slots, "icon", normalizeProps14(guardReactiveProps10(slotScope)))
        ]),
        default: withCtx20(() => [
          !_ctx.$slots.content ? withDirectives4((openBlock40(), createElementBlock34("input", mergeProps19({
            key: 0,
            ref_key: "input",
            ref: input,
            class: "va-input__content__input"
          }, { ...computedInputAttributes.value, ...inputEvents }, {
            "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => isRef5(valueComputed) ? valueComputed.value = $event : null)
          }), null, 16)), [
            [vModelDynamic2, unref40(valueComputed)]
          ]) : createCommentVNode20("", true)
        ]),
        _: 2
      }, [
        renderList5(filterSlots.value, (name) => {
          return {
            name,
            fn: withCtx20((slotScope) => [
              renderSlot34(_ctx.$slots, name, normalizeProps14(guardReactiveProps10(slotScope)))
            ])
          };
        })
      ]), 1040, ["class", "style", "loading", "error", "error-messages", "error-count", "counter-value"]);
    };
  }
});

// node_modules/vuestic-ui/dist/es/src/components/va-input/index.js
var VaInput = withConfigTransport$1(_sfc_main43);

// node_modules/vuestic-ui/dist/es/src/components/va-color-input/VaColorInput.vue_vue_type_script_setup_true_lang.js
import "D:/Desktop/forntend/Front_End_Web_Hotel_Nhom_2/my-nuxt-app/node_modules/vuestic-ui/dist/es/VaColorInput.css";
var _hoisted_121 = { class: "va-color-input" };
var VaInputProps = extractComponentProps(VaInput);
var _sfc_main44 = defineComponent45({
  ...{
    name: "VaColorInput"
  },
  __name: "VaColorInput",
  props: {
    ...VaInputProps,
    ...useStatefulProps,
    ...useComponentPresetProp,
    modelValue: { type: String, default: null },
    disabled: { type: Boolean, default: false },
    indicator: {
      type: String,
      default: "dot",
      validator: (value) => ["dot", "square"].includes(value)
    },
    ariaOpenColorPickerLabel: useTranslationProp("$t:openColorPicker")
  },
  emits: [...useStatefulEmits],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const colorPicker = shallowRef14();
    const { valueComputed } = useStateful(props, emit);
    const callPickerDialog = () => {
      var _a2;
      return !props.disabled && ((_a2 = colorPicker.value) == null ? void 0 : _a2.click());
    };
    const tabIndexComputed = computed98(() => props.disabled ? -1 : 0);
    const inputValue = computed98({
      get: () => props.modelValue,
      set: throttle((value) => emit("update:modelValue", value), 500)
    });
    const vaInputProps = filterComponentProps(VaInputProps);
    const { tp } = useTranslation();
    return (_ctx, _cache) => {
      return openBlock41(), createElementBlock35("div", _hoisted_121, [
        createVNode16(unref41(VaInput), mergeProps20(unref41(vaInputProps), {
          modelValue: unref41(valueComputed),
          "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => isRef6(valueComputed) ? valueComputed.value = $event : null),
          class: "va-color-input__input",
          tabindex: tabIndexComputed.value
        }), {
          appendInner: withCtx21(() => [
            createVNode16(unref41(VaColorIndicator), {
              class: "va-color-input__dot",
              role: "button",
              "aria-label": unref41(tp)(_ctx.$props.ariaOpenColorPickerLabel),
              "aria-disabled": _ctx.$props.disabled,
              tabindex: tabIndexComputed.value,
              color: unref41(valueComputed),
              indicator: _ctx.$props.indicator,
              size: "16px",
              onClick: callPickerDialog,
              onKeydown: [
                withKeys11(callPickerDialog, ["space"]),
                withKeys11(callPickerDialog, ["enter"])
              ]
            }, null, 8, ["aria-label", "aria-disabled", "tabindex", "color", "indicator"])
          ]),
          _: 1
        }, 16, ["modelValue", "tabindex"]),
        withDirectives5(createElementVNode17("input", {
          ref_key: "colorPicker",
          ref: colorPicker,
          type: "color",
          class: "va-color-input__hidden-input",
          "aria-hidden": "true",
          tabindex: "-1",
          "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => inputValue.value = $event)
        }, null, 512), [
          [vModelText, inputValue.value]
        ])
      ]);
    };
  }
});

// node_modules/vuestic-ui/dist/es/src/components/va-color-input/index.js
var VaColorInput = withConfigTransport$1(_sfc_main44);

// node_modules/vuestic-ui/dist/es/src/components/va-color-palette/VaColorPalette.vue_vue_type_script_setup_true_lang.js
import { defineComponent as defineComponent46, openBlock as openBlock42, createElementBlock as createElementBlock36, unref as unref42, Fragment as Fragment10, renderList as renderList6, createBlock as createBlock21 } from "vue";
import "D:/Desktop/forntend/Front_End_Web_Hotel_Nhom_2/my-nuxt-app/node_modules/vuestic-ui/dist/es/VaColorPalette.css";
var _hoisted_122 = ["aria-label"];
var _sfc_main45 = defineComponent46({
  ...{
    name: "VaColorPalette"
  },
  __name: "VaColorPalette",
  props: {
    ...useStatefulProps,
    ...useComponentPresetProp,
    modelValue: { type: String, default: null },
    palette: { type: Array, default: () => [] },
    indicator: {
      type: String,
      default: "dot",
      validator: (value) => ["dot", "square"].includes(value)
    },
    ariaLabel: useTranslationProp("$t:colorSelection"),
    ariaIndicatorLabel: useTranslationProp("$t:color")
  },
  emits: [...useStatefulEmits],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const { valueComputed } = useStateful(props, emit);
    const isSelected = (color) => valueComputed.value === color;
    const { tp } = useTranslation();
    return (_ctx, _cache) => {
      return openBlock42(), createElementBlock36("ul", {
        class: "va-color-palette",
        role: "listbox",
        "aria-label": unref42(tp)(_ctx.$props.ariaLabel)
      }, [
        (openBlock42(true), createElementBlock36(Fragment10, null, renderList6(__props.palette, (color, index) => {
          return openBlock42(), createBlock21(unref42(VaColorIndicator), {
            key: index,
            role: "option",
            "aria-label": unref42(tp)(_ctx.$props.ariaIndicatorLabel, { color }),
            "aria-selected": isSelected(color),
            tabindex: "0",
            modelValue: isSelected(color),
            color,
            square: __props.indicator === "square",
            "onUpdate:modelValue": ($event) => valueComputed.value = color
          }, null, 8, ["aria-label", "aria-selected", "modelValue", "color", "square", "onUpdate:modelValue"]);
        }), 128))
      ], 8, _hoisted_122);
    };
  }
});

// node_modules/vuestic-ui/dist/es/src/components/va-color-palette/index.js
var VaColorPalette = withConfigTransport$1(_sfc_main45);

// node_modules/vuestic-ui/dist/es/src/components/va-content/VaContent.js
import { openBlock as openBlock43, createElementBlock as createElementBlock37, renderSlot as renderSlot35 } from "vue";
var _sfc_main46 = {
  name: "VaContent"
};
var _hoisted_123 = { class: "va-typography-block" };
function _sfc_render2(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock43(), createElementBlock37("div", _hoisted_123, [
    renderSlot35(_ctx.$slots, "default")
  ]);
}
var _VaContent = _export_sfc(_sfc_main46, [["render", _sfc_render2]]);

// node_modules/vuestic-ui/dist/es/src/components/va-content/index.js
var VaContent = withConfigTransport$1(_VaContent);

// node_modules/vuestic-ui/dist/es/src/components/va-counter/VaCounter.vue_vue_type_script_setup_true_lang.js
import { defineComponent as defineComponent47, shallowRef as shallowRef15, toRefs as toRefs3, ref as ref34, computed as computed99, useAttrs as useAttrs3, useSlots as useSlots6, openBlock as openBlock44, createBlock as createBlock22, unref as unref44, mergeProps as mergeProps21, withKeys as withKeys12, withModifiers as withModifiers8, createSlots as createSlots3, withCtx as withCtx22, createElementBlock as createElementBlock38, createCommentVNode as createCommentVNode21, createElementVNode as createElementVNode18, normalizeStyle as normalizeStyle25, renderSlot as renderSlot36, normalizeProps as normalizeProps15, guardReactiveProps as guardReactiveProps11, createVNode as createVNode17 } from "vue";

// node_modules/vuestic-ui/dist/es/src/utils/css.js
var safeCSSLength = (length) => typeof length === "number" ? `${length}px` : length;

// node_modules/vuestic-ui/dist/es/src/components/va-counter/hooks/useCounterPropsValidation.js
import { watch as watch25 } from "vue";
function useCounterPropsValidation(props) {
  const validateCounterProps = () => {
    const val = Number(props.modelValue);
    const max = Number(props.max);
    const min = Number(props.min);
    const step = Number(props.step);
    if (Number.isNaN(val)) {
      warn("The value is not a number or cannot be reduced to a number.");
      return;
    }
    if (min && max && min > max) {
      warn(`The maximum value (${max}) can not be less than the minimum value (${min}).`);
    }
    if (min && val < min) {
      warn(`The value of the counter (${val}) can not be less than the minimum value (${min}).`);
    }
    if (max && val > max) {
      warn(`The value of the counter (${val}) can not be greater than the maximum value (${max}).`);
    }
    if (min && max && step > max - min) {
      warn(`The value of the step (${step}) can not be greater than the difference (${max - min}) between maximum value (${max}) and minimum value (${min}).`);
    }
  };
  watch25(
    [
      () => props.step,
      () => props.min,
      () => props.max
    ],
    validateCounterProps,
    { immediate: true }
  );
}

// node_modules/vuestic-ui/dist/es/src/utils/to-float.js
var toFloat = (num) => {
  return Number(num.toPrecision(13));
};
var isDividable = (num, step) => {
  const result = toFloat(num % step);
  return result === 0 || result === step;
};

// node_modules/vuestic-ui/dist/es/src/composables/useLongPress.js
import { unref as unref43 } from "vue";
function useLongPress(el, options) {
  let timeoutId = -1;
  let intervalId = -1;
  const handleMouseDown = () => {
    var _a2;
    (_a2 = options.onStart) == null ? void 0 : _a2.call(options);
    clearTimeout(timeoutId);
    timeoutId = setTimeout(() => {
      intervalId = setInterval(() => {
        var _a22;
        return (_a22 = options.onUpdate) == null ? void 0 : _a22.call(options);
      }, options.interval || 100);
    }, unref43(options.delay) || 500);
  };
  const handleMouseUp = () => {
    var _a2;
    clearTimeout(timeoutId);
    clearInterval(intervalId);
    (_a2 = options.onEnd) == null ? void 0 : _a2.call(options);
  };
  const htmlElement = useHTMLElement(el);
  useEvent(["mousedown", "touchstart", "dragstart"], handleMouseDown, htmlElement);
  useEvent([
    "mouseup",
    "mouseleave",
    "touchend",
    "touchcancel",
    "drop",
    "dragend",
    "blur"
  ], handleMouseUp, true);
}

// node_modules/vuestic-ui/dist/es/src/components/va-counter/VaCounter.vue_vue_type_script_setup_true_lang.js
import "D:/Desktop/forntend/Front_End_Web_Hotel_Nhom_2/my-nuxt-app/node_modules/vuestic-ui/dist/es/VaCounter.css";
var _hoisted_124 = ["value", "aria-live"];
var { createEmits: createInputEmits2, createListeners: createInputListeners2 } = useEmitProxy(
  ["change"]
);
var { createEmits: createFieldEmits2, createListeners: createFieldListeners2 } = useEmitProxy([
  { listen: "click-prepend", emit: "click:decrease-button" },
  { listen: "click-append", emit: "click:increase-button" },
  { listen: "click-prepend-inner", emit: "click:decrease-icon" },
  { listen: "click-append-inner", emit: "click:increase-icon" }
]);
var VaInputWrapperProps2 = extractComponentProps(VaInputWrapper);
var _sfc_main47 = defineComponent47({
  ...{
    name: "VaCounter",
    inheritAttrs: false
  },
  __name: "VaCounter",
  props: {
    ...useFormFieldProps,
    ...useStatefulProps,
    ...useComponentPresetProp,
    ...useClearableProps,
    ...VaInputWrapperProps2,
    // input
    modelValue: { type: [String, Number], default: 0 },
    manualInput: { type: Boolean, default: false },
    min: { type: [Number, String] },
    max: { type: [Number, String] },
    step: { type: [Number, String], default: 1 },
    color: { type: String, default: "primary" },
    // icons & buttons
    increaseIcon: { type: String, default: "va-plus" },
    decreaseIcon: { type: String, default: "va-minus" },
    buttons: { type: Boolean, default: false },
    flat: { type: Boolean, default: true },
    rounded: { type: Boolean, default: false },
    margins: { type: [String, Number], default: "4px" },
    longPressDelay: { type: [Number, String], default: 500 },
    ariaLabel: useTranslationProp("$t:counterValue"),
    ariaDecreaseLabel: useTranslationProp("$t:decreaseCounter"),
    ariaIncreaseLabel: useTranslationProp("$t:increaseCounter")
  },
  emits: [
    "update:modelValue",
    ...useValidationEmits,
    ...createInputEmits2(),
    ...createFieldEmits2(),
    ...useFocusEmits
  ],
  setup(__props, { expose: __expose, emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const input = shallowRef15();
    const { min = ref34(void 0), max = ref34(void 0), step } = toRefs3(props);
    const longPressDelayComputed = useNumericProp("longPressDelay");
    const {
      isFocused,
      focus,
      blur
    } = useFocus(input, emit);
    const { valueComputed: statefulValue } = useStateful(props, emit);
    function floatify(num) {
      return parseFloat(Number(num).toFixed(10));
    }
    const valueComputed = computed99({
      get() {
        return statefulValue.value;
      },
      set(v) {
        statefulValue.value = floatify(v);
      }
    });
    const reset = () => withoutValidation(() => {
      emit("update:modelValue", props.clearValue);
      emit("clear");
      resetValidation();
    });
    const {
      computedError,
      computedErrorMessages,
      withoutValidation,
      resetValidation,
      listeners: validationListeners,
      isDirty,
      isTouched
    } = useValidation(props, emit, { reset, focus, value: valueComputed });
    const setCountInput = ({ target }) => {
      valueComputed.value = Number(target == null ? void 0 : target.value);
    };
    const setCountChange = ({ target }) => {
      calculateCounterValue(Number(target == null ? void 0 : target.value));
    };
    const getRoundDownWithStep = (value) => {
      if (typeof min.value === "undefined" || !Number(step.value)) {
        return value;
      }
      return toFloat(Number(min.value) + Number(step.value) * ((Number(value) - Number(min.value)) / Number(step.value)));
    };
    const calculateCounterValue = (counterValue) => {
      if (typeof min.value !== "undefined" && counterValue < Number(min.value)) {
        valueComputed.value = Number(min.value);
        return;
      }
      if (typeof max.value !== "undefined" && counterValue > Number(max.value)) {
        valueComputed.value = getRoundDownWithStep(Number(max.value));
        return;
      }
      valueComputed.value = getRoundDownWithStep(counterValue);
    };
    const isMinReached = computed99(() => {
      if (isNilValue(min.value)) {
        return false;
      }
      return Number(valueComputed.value) <= Number(min.value);
    });
    const isMaxReached = computed99(() => {
      if (isNilValue(max.value)) {
        return false;
      }
      return step.value ? Number(valueComputed.value) > Number(max.value) - Number(step.value) : Number(valueComputed.value) >= Number(max.value);
    });
    const tabIndexComputed = computed99(() => props.disabled ? -1 : 0);
    const isDecreaseActionDisabled = computed99(() => isMinReached.value || props.disabled || props.readonly);
    const isIncreaseActionDisabled = computed99(() => isMaxReached.value || props.disabled || props.readonly);
    const decreaseCount = () => {
      if (isDecreaseActionDisabled.value) {
        return;
      }
      calculateCounterValue(Number(valueComputed.value) - Number(step.value));
    };
    const increaseCount = () => {
      if (isIncreaseActionDisabled.value) {
        return;
      }
      calculateCounterValue(Number(valueComputed.value) + Number(step.value));
    };
    useLongPress(useTemplateRef("decreaseButtonRef"), {
      onUpdate: decreaseCount,
      delay: longPressDelayComputed
    });
    useLongPress(useTemplateRef("increaseButtonRef"), {
      onUpdate: increaseCount,
      delay: longPressDelayComputed
    });
    const { getColor } = useColors();
    const colorComputed = computed99(() => getColor(props.color));
    const decreaseIconProps = computed99(() => ({
      class: { "va-counter__icon--inactive": isDecreaseActionDisabled.value },
      color: colorComputed.value,
      icon: props.decreaseIcon,
      plain: true,
      disabled: isDecreaseActionDisabled.value,
      readonly: props.readonly,
      tabindex: -1,
      "aria-label": tp(props.ariaDecreaseLabel),
      ...!isDecreaseActionDisabled.value && { onClick: decreaseCount }
    }));
    const increaseIconProps = computed99(() => ({
      class: { "va-counter__icon--inactive": isIncreaseActionDisabled.value },
      color: colorComputed.value,
      icon: props.increaseIcon,
      plain: true,
      disabled: isIncreaseActionDisabled.value,
      readonly: props.readonly,
      tabindex: -1,
      "aria-label": tp(props.ariaIncreaseLabel),
      ...!isIncreaseActionDisabled.value && { onClick: increaseCount }
    }));
    const isSquareCorners = computed99(() => (typeof props.margins === "string" ? parseFloat(props.margins) : props.margins) === 0);
    const buttonsColor = () => {
      if (isFocused.value) {
        return props.color;
      }
      return "background-border";
    };
    const buttonProps = computed99(() => ({
      ...pick(props, ["color"]),
      round: props.rounded,
      preset: props.flat ? "secondary" : "",
      borderColor: props.flat ? buttonsColor() : ""
    }));
    const decreaseButtonProps = computed99(() => ({
      ...buttonProps.value,
      icon: props.decreaseIcon,
      disabled: isDecreaseActionDisabled.value,
      "aria-label": tp(props.ariaDecreaseLabel),
      ...!isDecreaseActionDisabled.value && { onClick: decreaseCount }
    }));
    const increaseButtonProps = computed99(() => ({
      ...buttonProps.value,
      icon: props.increaseIcon,
      disabled: isIncreaseActionDisabled.value,
      "aria-label": tp(props.ariaIncreaseLabel),
      ...!isIncreaseActionDisabled.value && { onClick: increaseCount }
    }));
    const { tp } = useTranslation();
    const attrs = useAttrs3();
    const slots = useSlots6();
    const inputAttributesComputed = computed99(() => ({
      tabindex: tabIndexComputed.value,
      "aria-label": tp(props.ariaLabel),
      "aria-valuemin": Number(min.value),
      "aria-valuemax": Number(max.value),
      ...omit(attrs, ["class", "style"]),
      ...pick(props, ["disabled", "min", "max", "step"]),
      readonly: props.readonly || !props.manualInput
    }));
    const classComputed = computed99(() => [
      attrs.class,
      { "va-counter--input-square": isSquareCorners.value },
      { "va-counter--content-slot": slots.content && props.buttons }
    ].filter(Boolean));
    const styleComputed = computed99(() => ({
      ...attrs.style || {}
    }));
    const marginComputed = computed99(() => safeCSSLength(props.margins));
    useCounterPropsValidation(props);
    const fieldListeners = createFieldListeners2(emit);
    const inputListeners = createInputListeners2(emit);
    const inputWrapperPropsComputed = filterComponentProps(VaInputWrapperProps2);
    __expose({
      isDirty,
      isTouched,
      focus,
      blur,
      decreaseCount,
      increaseCount,
      reset
    });
    return (_ctx, _cache) => {
      return openBlock44(), createBlock22(unref44(VaInputWrapper), mergeProps21({ class: "va-counter" }, { ...unref44(fieldListeners), ...unref44(inputWrapperPropsComputed), ...unref44(validationListeners) }, {
        class: classComputed.value,
        style: styleComputed.value,
        focused: unref44(isFocused),
        error: unref44(computedError),
        "error-messages": unref44(computedErrorMessages),
        onKeydown: [
          withKeys12(withModifiers8(increaseCount, ["prevent"]), ["up"]),
          withKeys12(withModifiers8(increaseCount, ["prevent"]), ["right"]),
          withKeys12(withModifiers8(decreaseCount, ["prevent"]), ["down"]),
          withKeys12(withModifiers8(decreaseCount, ["prevent"]), ["left"])
        ]
      }), createSlots3({
        default: withCtx22(() => [
          !_ctx.$slots.content ? (openBlock44(), createElementBlock38("input", mergeProps21({
            key: 0,
            ref_key: "input",
            ref: input,
            class: "va-input__content__input",
            type: "number",
            inputmode: "decimal"
          }, { ...inputAttributesComputed.value, ...unref44(inputListeners) }, {
            value: valueComputed.value,
            "aria-live": _ctx.$props.disabled ? "off" : "polite",
            onInput: setCountInput,
            onChange: setCountChange
          }), null, 16, _hoisted_124)) : createCommentVNode21("", true)
        ]),
        _: 2
      }, [
        _ctx.$props.buttons ? {
          name: "prepend",
          fn: withCtx22((slotScope) => [
            createElementVNode18("div", {
              class: "va-counter__prepend-wrapper",
              style: normalizeStyle25({ marginRight: marginComputed.value }),
              onMousedown: _cache[0] || (_cache[0] = withModifiers8(
                //@ts-ignore
                (...args) => unref44(focus) && unref44(focus)(...args),
                ["prevent"]
              ))
            }, [
              renderSlot36(_ctx.$slots, "decreaseAction", normalizeProps15(guardReactiveProps11({ ...slotScope, decreaseCount })), () => [
                createVNode17(unref44(VaButton), mergeProps21({ class: "va-counter__button-decrease" }, decreaseButtonProps.value, { ref: "decreaseButtonRef" }), null, 16)
              ])
            ], 36)
          ]),
          key: "0"
        } : {
          name: "prependInner",
          fn: withCtx22((slotScope) => [
            createElementVNode18("div", {
              class: "va-counter__prepend-inner",
              onMousedown: _cache[1] || (_cache[1] = withModifiers8(
                //@ts-ignore
                (...args) => unref44(focus) && unref44(focus)(...args),
                ["prevent"]
              ))
            }, [
              renderSlot36(_ctx.$slots, "decreaseAction", normalizeProps15(guardReactiveProps11({ ...slotScope, decreaseCount })), () => [
                createVNode17(unref44(VaButton), mergeProps21(decreaseIconProps.value, { ref: "decreaseButtonRef" }), null, 16)
              ])
            ], 32)
          ]),
          key: "1"
        },
        _ctx.$props.buttons ? {
          name: "append",
          fn: withCtx22((slotScope) => [
            createElementVNode18("div", {
              class: "va-counter__append-wrapper",
              style: normalizeStyle25({ marginLeft: marginComputed.value }),
              onMousedown: _cache[2] || (_cache[2] = withModifiers8(
                //@ts-ignore
                (...args) => unref44(focus) && unref44(focus)(...args),
                ["prevent"]
              ))
            }, [
              renderSlot36(_ctx.$slots, "increaseAction", normalizeProps15(guardReactiveProps11({ ...slotScope, increaseCount })), () => [
                createVNode17(unref44(VaButton), mergeProps21({ class: "va-counter__button-increase" }, increaseButtonProps.value, { ref: "increaseButtonRef" }), null, 16)
              ])
            ], 36)
          ]),
          key: "2"
        } : {
          name: "appendInner",
          fn: withCtx22((slotScope) => [
            createElementVNode18("div", {
              class: "va-counter__append-inner",
              onMousedown: _cache[3] || (_cache[3] = withModifiers8(
                //@ts-ignore
                (...args) => unref44(focus) && unref44(focus)(...args),
                ["prevent"]
              ))
            }, [
              renderSlot36(_ctx.$slots, "increaseAction", normalizeProps15(guardReactiveProps11({ ...slotScope, increaseCount })), () => [
                createVNode17(unref44(VaButton), mergeProps21(increaseIconProps.value, { ref: "increaseButtonRef" }), null, 16)
              ])
            ], 32)
          ]),
          key: "3"
        },
        _ctx.$slots.content ? {
          name: "default",
          fn: withCtx22((slotScope) => [
            createElementVNode18("div", {
              ref_key: "input",
              ref: input,
              tabindex: "0",
              class: "va-counter__content-wrapper"
            }, [
              renderSlot36(_ctx.$slots, "content", normalizeProps15(guardReactiveProps11({ ...slotScope, value: Number(valueComputed.value) })))
            ], 512)
          ]),
          key: "4"
        } : void 0
      ]), 1040, ["class", "style", "focused", "error", "error-messages", "onKeydown"]);
    };
  }
});

// node_modules/vuestic-ui/dist/es/src/components/va-counter/index.js
var VaCounter = withConfigTransport$1(_sfc_main47);

// node_modules/vuestic-ui/dist/es/src/components/va-data-table/VaDataTable.vue_vue_type_script_setup_true_lang.js
import { defineComponent as defineComponent51, computed as computed114, useAttrs as useAttrs4, openBlock as openBlock48, createBlock as createBlock24, unref as unref50, mergeProps as mergeProps25, withCtx as withCtx23, createVNode as createVNode19, normalizeStyle as normalizeStyle27, createElementBlock as createElementBlock42, createCommentVNode as createCommentVNode24, createElementVNode as createElementVNode21, renderSlot as renderSlot40, normalizeProps as normalizeProps18, guardReactiveProps as guardReactiveProps14, normalizeClass as normalizeClass23, createSlots as createSlots4, renderList as renderList9, TransitionGroup, Fragment as Fragment13, withModifiers as withModifiers10, toDisplayString as toDisplayString17, createTextVNode as createTextVNode13 } from "vue";

// node_modules/vuestic-ui/dist/es/src/components/va-data-table/hooks/useColumns.js
import { computed as computed100 } from "vue";

// node_modules/vuestic-ui/dist/es/src/components/va-data-table/hooks/useCommonProps.js
var useCurrentPageProp = { currentPage: { type: Number } };
var createItemsProp = () => ({
  items: { type: Array, default: () => [] }
});
var useSelectableProp = { selectable: { type: Boolean, default: false } };
var useItemsTrackByProp = { itemsTrackBy: { type: [String, Function], default: "" } };

// node_modules/vuestic-ui/dist/es/src/components/va-data-table/hooks/useColumns.js
var sortingOptionsValidator = (options) => {
  const isAllowedOptionsLength = options.length === 2 || options.length === 3;
  const isAvailableOptions = options.every((option) => ["asc", "desc", null].includes(option));
  const isUniqueOptions = options.length === new Set(options).size;
  return isAllowedOptionsLength && isAvailableOptions && isUniqueOptions;
};
var useColumnsProps = {
  ...createItemsProp(),
  columns: { type: Array, default: () => [] },
  sortingOptions: {
    type: Array,
    default: () => ["asc", "desc", null],
    validator: sortingOptionsValidator
  }
};
var buildTableColumn = (source, initialIndex, props) => {
  const input = typeof source === "string" ? { key: source } : source;
  const isValidOptions = input.sortingOptions ? sortingOptionsValidator(input.sortingOptions) : true;
  if (!isValidOptions) {
    warn(`The "sortingOptions" array in the column with "${input.key}" key is invalid. For this column, the "sortingOptions" value is taken as for the table: ${JSON.stringify(props.sortingOptions)}.`);
  }
  return {
    source,
    initialIndex,
    key: input.key,
    name: input.name || input.key,
    label: input.label || startCase(input.key),
    thTitle: input.thTitle || input.headerTitle || input.label || startCase(input.key),
    sortable: input.sortable || false,
    sortingFn: input.sortingFn,
    displayFormatFn: input.displayFormatFn,
    sortingOptions: isValidOptions && input.sortingOptions || props.sortingOptions,
    thAlign: input.thAlign || input.alignHead || "left",
    thVerticalAlign: input.thVerticalAlign || input.verticalAlignHead || "middle",
    tdAlign: input.tdAlign || input.align || "left",
    tdVerticalAlign: input.tdVerticalAlign || input.verticalAlign || "middle",
    width: input.width,
    tdClass: input.tdClass || input.classes,
    thClass: input.thClass || input.headerClasses,
    tdStyle: input.tdStyle || input.style,
    thStyle: input.thStyle || input.headerStyle
  };
};
var buildColumnsFromItems = (props) => {
  return Object.keys(mergeDeepMultiple({}, ...props.items)).map((item, index) => buildTableColumn(item, index, props));
};
var buildNormalizedColumns = (props) => {
  return props.columns.map((item, index) => buildTableColumn(item, index, props));
};
var useColumns = (props) => {
  const columnsComputed = computed100(() => {
    if (props.columns.length === 0) {
      return buildColumnsFromItems(props);
    } else {
      return buildNormalizedColumns(props);
    }
  });
  return {
    columnsComputed
  };
};

// node_modules/vuestic-ui/dist/es/src/components/va-data-table/hooks/usePaginatedRows.js
import { computed as computed101 } from "vue";

// node_modules/vuestic-ui/dist/es/src/composables/useThrottle.js
import { toRef as toRef7, ref as ref35, unref as unref45, watch as watch26 } from "vue";
var useThrottleProps = {
  delay: {
    type: Number,
    default: 0,
    validator: (value) => value >= 0
  }
};
function useThrottleFunction(fn, props) {
  const delay = toRef7(props, "delay") ?? 0;
  const isThrottled = ref35(true);
  let lastCallResult = void 0;
  return function(...args) {
    const invoke = () => fn.apply(this, args);
    if (!unref45(delay)) {
      return invoke();
    }
    if (isThrottled.value) {
      isThrottled.value = false;
      setTimeout(() => isThrottled.value = true, unref45(delay));
      lastCallResult = invoke();
    }
    return lastCallResult;
  };
}
function useThrottleValue(value, props) {
  const delay = toRef7(props, "delay") ?? 0;
  if (!unref45(delay)) {
    return value;
  }
  const isThrottled = ref35(true);
  const previousCallValue = ref35();
  const previousReturnedValue = ref35();
  const currentCallValue = ref35();
  watch26(value, () => {
    previousCallValue.value = value.value;
    const lastCallValue = setTimeout(() => {
      currentCallValue.value = previousCallValue.value;
    }, unref45(delay));
    if (isThrottled.value) {
      isThrottled.value = false;
      currentCallValue.value = value.value;
      previousReturnedValue.value = value.value;
      clearTimeout(lastCallValue);
      setTimeout(() => isThrottled.value = true, unref45(delay));
    } else {
      currentCallValue.value = previousReturnedValue.value;
    }
  }, { immediate: true });
  return currentCallValue;
}

// node_modules/vuestic-ui/dist/es/src/components/va-data-table/hooks/usePaginatedRows.js
var usePaginatedRowsProps = {
  ...useThrottleProps,
  ...useCurrentPageProp,
  perPage: { type: Number }
};
var usePaginatedRows = (sortedRows, props) => {
  const paginatedRows = computed101(() => {
    if (!props.perPage || props.perPage < 0) {
      return sortedRows.value;
    }
    if (!props.currentPage || props.currentPage < 0) {
      return sortedRows.value.slice(0, props.perPage);
    }
    const pageStartIndex = props.perPage * (props.currentPage - 1);
    return sortedRows.value.slice(pageStartIndex, pageStartIndex + props.perPage);
  });
  const paginatedRowsThrottled = useThrottleValue(paginatedRows, props);
  return {
    paginatedRows: paginatedRowsThrottled
  };
};

// node_modules/vuestic-ui/dist/es/src/components/va-data-table/hooks/useSelectableRow.js
import { ref as ref37, computed as computed103, watch as watch27 } from "vue";

// node_modules/vuestic-ui/dist/es/src/components/va-data-table/hooks/useRows.js
import { ref as ref36, computed as computed102 } from "vue";
var getItemKey = (source, itemsTrackBy) => typeof itemsTrackBy === "function" ? itemsTrackBy(source) : getValueByPath(source, itemsTrackBy) || source;
var createRowsProps = () => ({
  ...createItemsProp(),
  ...useItemsTrackByProp
});
var buildTableCell = (rowIndex, rowKey, rowData, column) => {
  var _a2;
  const source = getValueByPath(rowData, column.key);
  return {
    rowIndex,
    rowKey,
    rowData,
    column,
    source,
    value: ((_a2 = source == null ? void 0 : source.toString) == null ? void 0 : _a2.call(source)) || ""
  };
};
var buildTableRow = (source, initialIndex, itemsTrackBy, columns) => {
  const itemKey = getItemKey(source, itemsTrackBy);
  return {
    initialIndex,
    itemKey,
    source,
    cells: columns.map((column) => buildTableCell(initialIndex, itemKey, source, column)),
    rowData: source
  };
};
var useRows = (columns, props) => {
  const expandableRows = ref36({});
  const rowsComputed = computed102(() => props.items.map((rawItem, index) => ({
    ...buildTableRow(rawItem, index, props.itemsTrackBy, columns.value),
    toggleRowDetails: (show) => {
      if (typeof show === "boolean") {
        expandableRows.value[index] = show;
      } else {
        expandableRows.value[index] = !expandableRows.value[index];
      }
    },
    isExpandableRowVisible: !!expandableRows.value[index]
  })));
  return {
    rowsComputed
  };
};

// node_modules/vuestic-ui/dist/es/src/components/va-data-table/hooks/useSelectableRow.js
var useSelectableProps2 = {
  ...useSelectableProp,
  ...useItemsTrackByProp,
  modelValue: { type: Array },
  selectMode: { type: String, default: "multiple" }
};
var useSelectableRow = (paginatedRows, props, emit) => {
  const selectedItemsFallback = ref37([]);
  const selectedItemsSync = computed103({
    get() {
      if (props.modelValue === void 0) {
        return selectedItemsFallback.value;
      } else {
        return props.modelValue;
      }
    },
    set(modelValue) {
      if (props.modelValue === void 0) {
        selectedItemsFallback.value = modelValue;
      }
      emit("update:modelValue", modelValue);
    }
  });
  const prevSelectedRowIndex = ref37(-1);
  watch27(() => props.selectMode, (newSelectMode, oldSelectMode) => {
    if (newSelectMode === "single" && oldSelectMode === "multiple") {
      selectedItemsSync.value = [];
      setPrevSelectedRowIndex(-1);
    }
  });
  watch27(paginatedRows, () => {
    setPrevSelectedRowIndex(-1);
  });
  watch27(selectedItemsSync, (currentSelectedItems, previousSelectedItems = []) => {
    emit("selectionChange", {
      currentSelectedItems,
      previousSelectedItems
    });
  }, { immediate: true });
  const getKey = (source) => getItemKey(source, props.itemsTrackBy);
  const noRowsSelected = computed103(() => !paginatedRows.value.some(({ source }) => selectedItemsSync.value.includes(getKey(source))));
  const allRowsSelected = computed103(() => {
    if (paginatedRows.value.length === 0) {
      return false;
    }
    return paginatedRows.value.every(({ source }) => selectedItemsSync.value.includes(getKey(source)));
  });
  const severalRowsSelected = computed103(() => !noRowsSelected.value && !allRowsSelected.value);
  function isRowSelected(row) {
    return selectedItemsSync.value.includes(getKey(row.source));
  }
  function selectAllRows() {
    selectedItemsSync.value = [.../* @__PURE__ */ new Set([
      ...selectedItemsSync.value,
      ...paginatedRows.value.map((row) => getKey(row.source))
    ])];
  }
  function unselectAllRows() {
    const paginatedRowsKeys = paginatedRows.value.map((row) => getKey(row.source));
    selectedItemsSync.value = selectedItemsSync.value.filter((item) => !paginatedRowsKeys.includes(item));
  }
  function selectRow(row) {
    selectedItemsSync.value = [...selectedItemsSync.value, getKey(row.source)];
  }
  function selectOnlyRow(row) {
    selectedItemsSync.value = [getKey(row.source)];
  }
  function unselectRow(row) {
    const index = selectedItemsSync.value.findIndex((item) => item === getKey(row.source));
    selectedItemsSync.value = [
      ...selectedItemsSync.value.slice(0, index),
      ...selectedItemsSync.value.slice(index + 1)
    ];
  }
  function setPrevSelectedRowIndex(rowInitialIndex) {
    if (rowInitialIndex === -1) {
      prevSelectedRowIndex.value = -1;
    } else {
      const prevSelectedRow = paginatedRows.value.find((row) => row.initialIndex === rowInitialIndex);
      prevSelectedRow ? prevSelectedRowIndex.value = paginatedRows.value.indexOf(prevSelectedRow) : prevSelectedRowIndex.value = -1;
    }
  }
  function getRowsToSelect(targetIndex) {
    let start;
    let end;
    if (isRowSelected(paginatedRows.value[prevSelectedRowIndex.value])) {
      start = Math.min(prevSelectedRowIndex.value, targetIndex);
      end = Math.max(prevSelectedRowIndex.value, targetIndex);
    } else {
      start = Math.min(prevSelectedRowIndex.value + 1, targetIndex);
      end = Math.max(prevSelectedRowIndex.value - 1, targetIndex);
    }
    return paginatedRows.value.slice(start, end + 1);
  }
  function mergeSelection(rowsToSelect) {
    const rowsToSelectedItems = rowsToSelect.map((row) => getKey(row.source));
    if (noRowsSelected.value) {
      selectedItemsSync.value = rowsToSelectedItems;
      return;
    }
    const isInternalSelection = rowsToSelectedItems.every((item) => selectedItemsSync.value.includes(item));
    if (isInternalSelection) {
      selectedItemsSync.value = selectedItemsSync.value.filter((item) => !rowsToSelectedItems.includes(item));
      return;
    }
    selectedItemsSync.value = [.../* @__PURE__ */ new Set([
      ...selectedItemsSync.value,
      ...rowsToSelectedItems
    ])];
  }
  function toggleRowSelection(row) {
    if (!props.selectable) {
      return;
    }
    if (isRowSelected(row)) {
      unselectRow(row);
      props.selectMode === "single" ? setPrevSelectedRowIndex(-1) : setPrevSelectedRowIndex(row.initialIndex);
    } else {
      props.selectMode === "single" ? selectOnlyRow(row) : selectRow(row);
      setPrevSelectedRowIndex(row.initialIndex);
    }
  }
  function ctrlSelectRow(row) {
    if (!props.selectable) {
      return;
    }
    toggleRowSelection(row);
  }
  function shiftSelectRows(row) {
    if (!props.selectable) {
      return;
    }
    if (props.selectMode === "single" || prevSelectedRowIndex.value === -1) {
      return toggleRowSelection(row);
    }
    const targetIndex = paginatedRows.value.indexOf(row);
    mergeSelection(getRowsToSelect(targetIndex));
    setPrevSelectedRowIndex(-1);
  }
  function toggleBulkSelection() {
    if (allRowsSelected.value) {
      unselectAllRows();
    } else {
      selectAllRows();
    }
    setPrevSelectedRowIndex(-1);
  }
  return {
    ctrlSelectRow,
    shiftSelectRows,
    toggleRowSelection,
    toggleBulkSelection,
    isRowSelected,
    noRowsSelected,
    severalRowsSelected,
    allRowsSelected
  };
};

// node_modules/vuestic-ui/dist/es/src/components/va-data-table/hooks/useStylable.js
import { computed as computed104 } from "vue";
var prefix = "--va-data-table";
var isFunction2 = (val) => typeof val === "function";
var useStylableProps = {
  ...useSelectableProp,
  selectedColor: { type: String, default: "primary" },
  allowFooterSorting: { type: Boolean, default: false },
  stickyHeader: { type: Boolean, default: false },
  stickyFooter: { type: Boolean, default: false },
  height: { type: [String, Number] }
};
var getClass = (classes) => isFunction2(classes) ? classes() : classes;
var getStyle = (styles) => isFunction2(styles) ? styles() : styles;
var useStylable = (props) => {
  const { getColor, getFocusColor: getFocusColor2, getHoverColor: getHoverColor2 } = useColors();
  const color = computed104(() => getColor(props.selectedColor));
  const CSSVariables = computed104(() => ({
    hoverColor: getHoverColor2(color.value),
    selectedColor: props.selectable ? getFocusColor2(color.value) : void 0,
    tableHeight: props.height ? safeCSSLength(props.height) : "var(--va-data-table-height)",
    theadBg: props.stickyHeader ? "var(--va-data-table-thead-background, var(--va-data-table-header-background))" : "var(--va-data-table-thead-background)",
    tfootBg: props.stickyFooter ? "var(--va-data-table-tfoot-background, var(--va-data-table-header-background))" : "var(--va-data-table-tfoot-background)"
  }));
  const getHeaderCSSVariables = (column) => ({
    [`${prefix}-width`]: column.width && safeCSSLength(column.width),
    [`${prefix}-align`]: column.thAlign,
    [`${prefix}-vertical-align`]: column.thVerticalAlign,
    [`${prefix}-cursor`]: column.sortable ? "pointer" : "default"
  });
  const getCellCSSVariables = (cell) => ({
    [`${prefix}-align`]: cell.column.tdAlign,
    [`${prefix}-vertical-align`]: cell.column.tdVerticalAlign
  });
  const getFooterCSSVariables = (column) => ({
    [`${prefix}-align`]: column.thAlign,
    [`${prefix}-vertical-align`]: column.thVerticalAlign,
    [`${prefix}-cursor`]: props.allowFooterSorting && column.sortable ? "pointer" : "default"
  });
  return {
    CSSVariables,
    getHeaderCSSVariables,
    getCellCSSVariables,
    getFooterCSSVariables,
    getClass,
    getStyle
  };
};

// node_modules/vuestic-ui/dist/es/src/components/va-data-table/hooks/useBinding.js
var isFunction3 = (val) => typeof val === "function";
var isObject3 = (val) => val !== null && typeof val === "object";
var useBindingProps = {
  rowBind: { type: null },
  cellBind: { type: null }
};
var useBinding = (props) => {
  const getRowBind = (row) => isFunction3(props.rowBind) ? props.rowBind(row.source, row.initialIndex) : isObject3(props.rowBind) ? props.rowBind : {};
  const getCellBind = (cell, row) => isFunction3(props.cellBind) ? props.cellBind(cell.source, row.source, cell.column, row.initialIndex) : isObject3(props.cellBind) ? props.cellBind : {};
  return {
    getRowBind,
    getCellBind
  };
};

// node_modules/vuestic-ui/dist/es/src/components/va-data-table/hooks/useAnimationName.js
import { ref as ref38, computed as computed105, watch as watch28 } from "vue";
var useAnimationNameProps = {
  ...useCurrentPageProp,
  animated: { type: Boolean, default: true }
};
var useAnimationName = (props, rows) => {
  const animationType = ref38("shuffle");
  const animationName = computed105(() => props.animated ? `table-transition-${animationType.value}` : "");
  const oldRowsLength = ref38(rows.value.length);
  const isDifferentRowLength = computed105(() => rows.value.length !== oldRowsLength.value);
  watch28(rows, (newRows, oldRows) => {
    const hasRows = !!(newRows.length && oldRows.length);
    animationType.value = newRows.length > 50 || isDifferentRowLength.value && hasRows ? "fade" : "shuffle";
    oldRowsLength.value = newRows.length;
  });
  watch28(() => props.currentPage, () => {
    if (!isDifferentRowLength.value) {
      animationType.value = "shuffle";
    }
  });
  return animationName;
};

// node_modules/vuestic-ui/dist/es/src/components/va-data-table/hooks/useFilterable.js
import { computed as computed106, watch as watch29 } from "vue";
var useFilterableProps = {
  ...useThrottleProps,
  filter: { type: String, default: "" },
  filterMethod: { type: Function }
};
var useFilterable = (rawRows, props, emit) => {
  const filteredRows = computed106(() => {
    if (!rawRows.value.length) {
      return rawRows.value;
    }
    if (props.filter === "" && !props.filterMethod) {
      return rawRows.value;
    }
    return rawRows.value.filter(
      (row) => row.cells.some((cell) => {
        if (typeof props.filterMethod === "function") {
          return props.filterMethod(cell.source, cell);
        }
        const cellRegex = new RegExp(props.filter, "i");
        return cellRegex.test(cell.value);
      })
    );
  });
  const filteredRowsThrottled = useThrottleValue(filteredRows, props);
  watch29(filteredRowsThrottled, () => {
    emit("filtered", {
      items: filteredRowsThrottled.value.map((row) => row.source),
      itemsIndexes: filteredRowsThrottled.value.map((row) => row.initialIndex)
    });
  });
  if (filteredRows.value.length !== rawRows.value.length) {
    emit("filtered", {
      items: filteredRows.value.map((row) => row.source),
      itemsIndexes: filteredRows.value.map((row) => row.initialIndex)
    });
  }
  return {
    filteredRows: filteredRowsThrottled
  };
};

// node_modules/vuestic-ui/dist/es/src/components/va-data-table/hooks/useSortable.js
import { ref as ref39, computed as computed107, watch as watch30 } from "vue";
var useSortableProps = {
  ...useThrottleProps,
  sortBy: { type: String },
  columnSorted: { type: Object },
  sortingOrder: { type: [String, null] },
  disableClientSideSorting: { type: Boolean, default: false }
};
var useSortable = (columns, filteredRows, props, emit) => {
  const sortByFallback = ref39("");
  const sortBySync = computed107({
    get() {
      if (props.sortBy === void 0) {
        return sortByFallback.value;
      } else {
        return props.sortBy;
      }
    },
    set(value) {
      if (props.sortBy === void 0) {
        sortByFallback.value = value;
      }
      emit("update:sortBy", value);
    }
  });
  const sortingOrderFallback = ref39(null);
  const sortingOrderSync = computed107({
    get() {
      if (props.sortingOrder === void 0) {
        return sortingOrderFallback.value;
      } else {
        return props.sortingOrder;
      }
    },
    set(value) {
      if (props.sortingOrder === void 0) {
        sortingOrderFallback.value = value;
      }
      emit("update:sortingOrder", value);
    }
  });
  const defaultSortingFn = (a, b) => {
    if (typeof a === "string" && typeof b === "string") {
      return a.localeCompare(b);
    }
    if (typeof a === "number" && typeof b === "number") {
      return a - b;
    }
    const aParsed = parseFloat(a);
    const bParsed = parseFloat(b);
    if (!isNaN(aParsed) && !isNaN(bParsed)) {
      return aParsed - bParsed;
    }
    if (!isNaN(aParsed)) {
      return -1;
    }
    if (!isNaN(bParsed)) {
      return 1;
    }
    return 0;
  };
  const sortedRows = computed107(() => {
    if (props.disableClientSideSorting) {
      return filteredRows.value;
    }
    if (filteredRows.value.length <= 1) {
      return filteredRows.value;
    }
    const columnIndex = columns.value.findIndex(
      ({ name, sortable }) => sortBySync.value === name && sortable
    );
    const column = columns.value[columnIndex];
    if (!column) {
      return filteredRows.value;
    }
    const sortingOrderRatio = sortingOrderSync.value === "desc" ? -1 : 1;
    return [...filteredRows.value].sort((a, b) => {
      if (sortingOrderSync.value === null) {
        return a.initialIndex - b.initialIndex;
      } else {
        const firstSource = a.cells[columnIndex].source;
        const secondSource = b.cells[columnIndex].source;
        return sortingOrderRatio * (typeof column.sortingFn === "function" ? column.sortingFn(firstSource, secondSource) : defaultSortingFn(firstSource, secondSource));
      }
    });
  });
  watch30(sortedRows, () => {
    emit("sorted", {
      sortBy: sortBySync.value,
      sortingOrder: sortingOrderSync.value,
      items: sortedRows.value.map((row) => row.source),
      itemsIndexes: sortedRows.value.map((row) => row.initialIndex)
    });
  });
  const getNextSortingOptionsValue = (value, options) => {
    const index = options.findIndex((sortingValue) => sortingValue === value);
    return index !== -1 ? options[(index + 1) % options.length] : options[0];
  };
  function toggleSorting(column) {
    let value;
    if (column.name === sortBySync.value) {
      value = getNextSortingOptionsValue(sortingOrderSync.value, column.sortingOptions);
    } else {
      sortBySync.value = column.name;
      value = column.sortingOptions[0];
    }
    sortingOrderSync.value = value;
    emit("columnSorted", { columnName: column.name, value, column });
  }
  const toggleSortingThrottled = useThrottleFunction(toggleSorting, props);
  const sortingOrderIconName = computed107(() => {
    return sortingOrderSync.value === "asc" ? "va-sort-asc" : sortingOrderSync.value === "desc" ? "va-sort-desc" : "va-unsorted";
  });
  return {
    sortBySync,
    sortingOrderSync,
    toggleSorting: toggleSortingThrottled,
    sortedRows,
    sortingOrderIconName
  };
};

// node_modules/vuestic-ui/dist/es/src/components/va-data-table/hooks/useTableScroll.js
import { getCurrentInstance as getCurrentInstance25, computed as computed109 } from "vue";

// node_modules/vuestic-ui/dist/es/src/composables/useElementRef.js
import { shallowRef as shallowRef16, computed as computed108, unref as unref46 } from "vue";
var unrefElement = (el) => {
  const e = unref46(el);
  return unwrapEl(e);
};
var useElementRef = () => {
  const el = shallowRef16();
  return computed108({
    get() {
      return unrefElement(el);
    },
    set(node) {
      el.value = node;
    }
  });
};

// node_modules/vuestic-ui/dist/es/src/components/va-data-table/hooks/useTableScroll.js
var useTableScrollProps = {
  scrollTopMargin: { type: [Number, String], default: 0 },
  scrollBottomMargin: { type: [Number, String], default: 0 }
};
var useTableScrollEmits = ["scroll:top", "scroll:bottom"];
var useTableScroll = (props, emit) => {
  var _a2;
  const vNodeProps = (_a2 = getCurrentInstance25()) == null ? void 0 : _a2.vnode.props;
  const doRenderTopTrigger = (vNodeProps == null ? void 0 : vNodeProps["onScroll:top"]) !== void 0;
  const doRenderBottomTrigger = (vNodeProps == null ? void 0 : vNodeProps["onScroll:bottom"]) !== void 0;
  const scrollContainer = useElementRef();
  const topTrigger = useElementRef();
  const bottomTrigger = useElementRef();
  const scrollTopMarginComputed = useNumericProp("scrollTopMargin");
  const scrollBottomMarginComputed = useNumericProp("scrollBottomMargin");
  const isObservable = computed109(() => !!scrollContainer.value);
  const intersectionHandler = (entries) => {
    entries.forEach((entry) => {
      if (entry.isIntersecting) {
        entry.target === topTrigger.value ? emit("scroll:top") : emit("scroll:bottom");
      }
    });
  };
  const targets = computed109(() => {
    const list = [];
    if (isObservable.value) {
      topTrigger.value && list.push(topTrigger.value);
      bottomTrigger.value && list.push(bottomTrigger.value);
    }
    return list;
  });
  const options = computed109(() => ({
    root: scrollContainer.value,
    rootMargin: `${scrollTopMarginComputed.value ?? 0}px 0px ${scrollBottomMarginComputed.value ?? 0}px 0px`
  }));
  useIntersectionObserver(intersectionHandler, options, targets);
  return {
    scrollContainer,
    topTrigger,
    bottomTrigger,
    doRenderTopTrigger,
    doRenderBottomTrigger
  };
};

// node_modules/vuestic-ui/dist/es/src/components/va-data-table/components/VaDataTableThRow.vue_vue_type_script_setup_true_lang.js
import { defineComponent as defineComponent48, computed as computed110, openBlock as openBlock45, createElementBlock as createElementBlock39, createBlock as createBlock23, unref as unref47, createCommentVNode as createCommentVNode22, Fragment as Fragment11, renderList as renderList7, mergeProps as mergeProps22, withModifiers as withModifiers9, withKeys as withKeys13, createElementVNode as createElementVNode19, renderSlot as renderSlot37, normalizeProps as normalizeProps16, guardReactiveProps as guardReactiveProps12, toDisplayString as toDisplayString16, normalizeClass as normalizeClass21 } from "vue";
import "D:/Desktop/forntend/Front_End_Web_Hotel_Nhom_2/my-nuxt-app/node_modules/vuestic-ui/dist/es/VaDataTableThRow.css";
var _hoisted_125 = { class: "va-data-table__table-tr" };
var _hoisted_211 = {
  key: 0,
  scope: "col",
  class: "va-data-table__table-th va-data-table__table-cell-select"
};
var _hoisted_37 = ["title", "onClick", "onKeydown"];
var _hoisted_46 = { class: "va-data-table__table-th-wrapper" };
var _hoisted_55 = { key: 0 };
var _sfc_main48 = defineComponent48({
  ...{
    name: "VaDataTableThRow"
  },
  __name: "VaDataTableThRow",
  props: {
    ...useStylableProps,
    selectMode: { type: String, default: "multiple" },
    allRowsSelected: { type: Boolean, default: false },
    severalRowsSelected: { type: Boolean, default: false },
    columns: { type: Array, required: true },
    isFooter: { type: Boolean, default: false },
    sortBySync: { type: String, required: true },
    sortingOrderIconName: { type: String, required: true },
    sortingOrderSync: { type: String, default: null },
    ariaSelectAllRowsLabel: useTranslationProp("$t:selectAllRows"),
    ariaSortColumnByLabel: useTranslationProp("$t:sortColumnBy")
  },
  emits: [
    "toggleBulkSelection",
    "toggleSorting"
  ],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const { t, tp } = useTranslation();
    const {
      getFooterCSSVariables,
      getHeaderCSSVariables,
      getClass: getClass2,
      getStyle: getStyle2
    } = useStylable(props);
    const getAriaAttributes = (column) => {
      const ariaSort = props.sortingOrderSync && props.sortBySync === column.name ? props.sortingOrderSync === "asc" ? "ascending" : "descending" : "none";
      const ariaLabel = column.sortable ? tp(props.ariaSortColumnByLabel, { name: column.label }) : void 0;
      return {
        "aria-sort": ariaSort,
        "aria-label": ariaLabel
      };
    };
    const sortByColumn = (column) => {
      if (props.isFooter && !props.allowFooterSorting || !column.sortable) {
        return;
      }
      emit("toggleSorting", column);
    };
    const toggleBulkSelection = () => emit("toggleBulkSelection");
    const getColumnStyles = (column) => {
      return [
        column.width ? { minWidth: column.width, maxWidth: column.width } : {},
        props.isFooter ? getFooterCSSVariables(column) : getHeaderCSSVariables(column),
        getStyle2(column.thStyle)
      ];
    };
    const slotNameComputed = computed110(() => props.isFooter ? "footer" : "header");
    const multiplySelectAvailable = computed110(() => props.selectMode === "multiple");
    return (_ctx, _cache) => {
      return openBlock45(), createElementBlock39("tr", _hoisted_125, [
        _ctx.$props.selectable ? (openBlock45(), createElementBlock39("th", _hoisted_211, [
          multiplySelectAvailable.value ? (openBlock45(), createBlock23(unref47(VaCheckbox), {
            key: 0,
            class: "va-data-table__table-cell-checkbox",
            "model-value": _ctx.$props.severalRowsSelected ? "idl" : _ctx.$props.allRowsSelected,
            "aria-label": unref47(tp)(_ctx.$props.ariaSelectAllRowsLabel),
            "true-value": true,
            "false-value": false,
            color: _ctx.$props.selectedColor,
            "indeterminate-value": "idl",
            indeterminate: "",
            "onUpdate:modelValue": toggleBulkSelection
          }, null, 8, ["model-value", "aria-label", "color"])) : createCommentVNode22("", true)
        ])) : createCommentVNode22("", true),
        (openBlock45(true), createElementBlock39(Fragment11, null, renderList7(__props.columns, (column) => {
          return openBlock45(), createElementBlock39("th", mergeProps22({
            key: column.name,
            scope: "col",
            class: ["va-data-table__table-th", unref47(getClass2)(column.thClass)],
            title: column.thTitle,
            style: getColumnStyles(column)
          }, getAriaAttributes(column), {
            onClick: withModifiers9(($event) => sortByColumn(column), ["exact"]),
            onKeydown: withKeys13(withModifiers9(($event) => sortByColumn(column), ["stop"]), ["enter"])
          }), [
            createElementVNode19("div", _hoisted_46, [
              `${slotNameComputed.value}(${column.name})` in _ctx.$slots ? (openBlock45(), createElementBlock39("span", _hoisted_55, [
                renderSlot37(_ctx.$slots, `${slotNameComputed.value}(${column.name})`, normalizeProps16(guardReactiveProps12({ label: column.label, key: column.key })))
              ])) : renderSlot37(_ctx.$slots, slotNameComputed.value, normalizeProps16(mergeProps22({ key: 1 }, { label: column.label, key: column.key })), () => [
                createElementVNode19("span", null, toDisplayString16(column.label), 1)
              ]),
              column.sortable ? (openBlock45(), createBlock23(unref47(VaIcon), {
                key: 2,
                class: normalizeClass21(["va-data-table__table-th-sorting-icon", { active: __props.sortBySync === column.name && __props.sortingOrderSync !== null }]),
                size: "small",
                role: column.sortable ? "button" : void 0,
                tabindex: column.sortable ? 0 : -1,
                name: __props.sortingOrderIconName,
                onSelectstart: withModifiers9(() => {
                }, ["prevent"])
              }, null, 8, ["class", "role", "tabindex", "name"])) : createCommentVNode22("", true)
            ])
          ], 16, _hoisted_37);
        }), 128))
      ]);
    };
  }
});

// node_modules/vuestic-ui/dist/es/src/components/va-data-table/components/index.js
var VaDataTableThRow = withConfigTransport$1(_sfc_main48);

// node_modules/vuestic-ui/dist/es/src/components/va-virtual-scroller/VaVirtualScroller.vue_vue_type_script_setup_true_lang.js
import { defineComponent as defineComponent49, ref as ref41, computed as computed112, watch as watch32, openBlock as openBlock46, createElementBlock as createElementBlock40, normalizeClass as normalizeClass22, unref as unref48, normalizeStyle as normalizeStyle26, renderSlot as renderSlot38, normalizeProps as normalizeProps17, guardReactiveProps as guardReactiveProps13, createElementVNode as createElementVNode20, Fragment as Fragment12, renderList as renderList8, mergeProps as mergeProps23 } from "vue";

// node_modules/vuestic-ui/dist/es/src/components/va-virtual-scroller/useVirtualScrollerSizes.js
import { shallowRef as shallowRef17, computed as computed111, ref as ref40, getCurrentInstance as getCurrentInstance26, onMounted as onMounted19, watch as watch31 } from "vue";
var { isParsablePositiveMeasure, parseSizeValue: parseSizeValue2 } = useParsableMeasure();
var validateSizeProp = (v, propName) => {
  const isProperValue = isParsablePositiveMeasure(v);
  !isProperValue && warn(`[va-virtual-scroller] ${propName} should be number or parsable int greater or equal to 0. Provided: ${v}.`);
  return isProperValue;
};
var useVirtualScrollerSizesProps = {
  horizontal: { type: Boolean, default: false },
  itemSize: {
    type: [Number, String],
    default: 0,
    validator: (v) => {
      return validateSizeProp(v, "itemSize");
    }
  },
  wrapperSize: {
    type: [Number, String],
    default: 100,
    validator: (v) => {
      return v === "auto" || validateSizeProp(v, "wrapperSize");
    }
  }
};
var useVirtualScrollerSizes = (props, scrollPosition) => {
  const list = shallowRef17();
  const wrapper = shallowRef17();
  const clientSizeMeasure = computed111(() => props.horizontal ? "clientWidth" : "clientHeight");
  const wrapperSize = computed111(() => {
    var _a2;
    if (props.wrapperSize === "auto") {
      return ((_a2 = wrapper.value) == null ? void 0 : _a2[clientSizeMeasure.value]) || 0;
    }
    return parseSizeValue2(props.wrapperSize, pageFontSize);
  });
  const pageFontSize = ref40(16);
  const handleWindowResize = () => {
    pageFontSize.value = parseFloat(getComputedStyle(document.documentElement).fontSize);
    calcAverageItemsSize();
  };
  useEvent("resize", handleWindowResize, true);
  const itemSizeCalculated = ref40(0);
  const calcAverageItemsSize = () => {
    if (!list.value) {
      return;
    }
    const sizes = [];
    const itemsList = list.value.children;
    const itemsAmount = itemsList.length;
    for (let i = 0; i < itemsAmount; i++) {
      const currentChild = list.value.children.item(i);
      currentChild && sizes.push(currentChild[clientSizeMeasure.value]);
    }
    itemSizeCalculated.value = itemsAmount ? Math.trunc(sizes.reduce((acc, el) => acc + el, 0) / (itemsAmount - 1)) : 0;
  };
  const instance = getCurrentInstance26();
  onMounted19(() => {
    var _a2, _b;
    if (!list.value) {
      list.value = (_b = (_a2 = instance == null ? void 0 : instance.parent) == null ? void 0 : _a2.refs) == null ? void 0 : _b.list;
    }
    calcAverageItemsSize();
  });
  watch31(scrollPosition, calcAverageItemsSize);
  watch31(wrapperSize, calcAverageItemsSize);
  let oldItemSize = 0;
  const itemSize = computed111(() => {
    const sizeParsed = parseSizeValue2(props.itemSize, pageFontSize);
    const result = Math.max(sizeParsed, itemSizeCalculated.value, 1);
    const diff = Math.abs(oldItemSize / result * 100 - 100);
    if (diff > 5 || oldItemSize === 0) {
      oldItemSize = result;
      return result;
    }
    return oldItemSize;
  });
  return { list, wrapper, itemSize, wrapperSize };
};

// node_modules/vuestic-ui/dist/es/src/composables/useTrackBy.js
var useTrackByProps = {
  trackBy: {
    type: [String, Number, Function],
    default: ""
  }
};
var useTrackBy = (props) => {
  const getKey = (item, index, defaultValue) => {
    if (props.trackBy && item && typeof item === "object" && !isFunction(props.trackBy)) {
      const isArrayItem = Array.isArray(item);
      let key;
      if (isArrayItem && !isNaN(+props.trackBy)) {
        key = item[+props.trackBy];
      }
      if (!isArrayItem) {
        key = item[props.trackBy];
      }
      if (key || key === 0) {
        return key;
      }
      warn(`${isArrayItem ? "Index" : "Key"} '${props.trackBy}' wasn't found in provided ${isArrayItem ? "array" : "object"}: `, item);
    }
    if (isFunction(props.trackBy)) {
      return props.trackBy(item);
    }
    return defaultValue;
  };
  return { getKey };
};

// node_modules/vuestic-ui/dist/es/src/components/va-virtual-scroller/VaVirtualScroller.vue_vue_type_script_setup_true_lang.js
import "D:/Desktop/forntend/Front_End_Web_Hotel_Nhom_2/my-nuxt-app/node_modules/vuestic-ui/dist/es/VaVirtualScroller.css";
var _sfc_main49 = defineComponent49({
  ...{
    name: "VaVirtualScroller"
  },
  __name: "VaVirtualScroller",
  props: {
    ...useTrackByProps,
    ...useVirtualScrollerSizesProps,
    items: { type: Array, default: () => [] },
    bench: { type: [Number, String], default: 10, validator: (v) => Number(v) >= 0 },
    disabled: { type: Boolean, default: false },
    table: { type: Boolean, default: false }
  },
  emits: ["scroll:bottom"],
  setup(__props, { expose: __expose, emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const listScrollPosition = ref41(0);
    const benchComputed = useNumericProp("bench");
    const scrollDirection = computed112(() => props.horizontal ? "scrollLeft" : "scrollTop");
    const handleScroll = () => {
      if (!wrapper.value) {
        return;
      }
      listScrollPosition.value = wrapper.value[scrollDirection.value];
    };
    if (!props.disabled) {
      useEvent("scroll", handleScroll, true);
    }
    const { list, wrapper, itemSize, wrapperSize } = useVirtualScrollerSizes(props, listScrollPosition);
    const { getKey } = useTrackBy(props);
    const uniqueKey = (item, index, defaultValue) => getKey(item, index, defaultValue);
    watch32(listScrollPosition, (newValue) => {
      if (newValue + wrapperSize.value === containerSize.value) {
        emit("scroll:bottom");
      }
    });
    const renderStartIndex = computed112(() => {
      return Math.max(0, Math.floor(listScrollPosition.value / itemSize.value) - benchComputed.value);
    });
    const renderItemsAmount = computed112(() => {
      var _a2;
      if (!((_a2 = props.items) == null ? void 0 : _a2.length)) {
        return 0;
      }
      return props.disabled ? props.items.length : Math.min(props.items.length - renderStartIndex.value, Math.ceil(wrapperSize.value / itemSize.value) + benchComputed.value * 2);
    });
    const renderEndIndex = computed112(() => renderStartIndex.value + renderItemsAmount.value);
    const renderBuffer = computed112(() => {
      var _a2;
      if (!((_a2 = props.items) == null ? void 0 : _a2.length)) {
        return [];
      }
      return props.items.slice(renderStartIndex.value, renderEndIndex.value);
    });
    const sizeAttribute = computed112(() => props.horizontal ? "width" : "height");
    const isDisabledVirtualTable = computed112(() => props.table && props.disabled);
    const wrapperStyleComputed = computed112(() => ({
      [sizeAttribute.value]: isDisabledVirtualTable.value || !wrapperSize.value ? void 0 : `${wrapperSize.value}px`
    }));
    const wrapperClassComputed = useBem("va-virtual-scroller", () => ({
      ...pick(props, ["horizontal"])
    }));
    const containerSize = computed112(() => {
      var _a2;
      return (((_a2 = props.items) == null ? void 0 : _a2.length) ?? 0) * itemSize.value;
    });
    const containerStyleComputed = computed112(() => ({
      [sizeAttribute.value]: isDisabledVirtualTable.value ? void 0 : `${containerSize.value}px`
    }));
    const currentListOffset = computed112(() => renderStartIndex.value * itemSize.value);
    const listStyleComputed = computed112(() => ({
      transform: `translate${props.horizontal ? "X" : "Y"}(${currentListOffset.value}px)`
    }));
    const scrollToAttribute = computed112(() => props.horizontal ? "left" : "top");
    const virtualScrollTo = (index) => {
      var _a2;
      if (!index && index !== 0) {
        return;
      }
      (_a2 = wrapper.value) == null ? void 0 : _a2.scrollTo({ [scrollToAttribute.value]: index * itemSize.value });
    };
    __expose({
      scrollToAttribute,
      virtualScrollTo
    });
    return (_ctx, _cache) => {
      return openBlock46(), createElementBlock40("div", {
        ref_key: "wrapper",
        ref: wrapper,
        class: normalizeClass22(["va-virtual-scroller", unref48(wrapperClassComputed)]),
        style: normalizeStyle26(wrapperStyleComputed.value)
      }, [
        renderSlot38(_ctx.$slots, "content", normalizeProps17(guardReactiveProps13({ containerStyleComputed: containerStyleComputed.value, listStyleComputed: listStyleComputed.value, renderBuffer: renderBuffer.value, uniqueKey, currentListOffset: currentListOffset.value })), () => [
          createElementVNode20("div", {
            class: "va-virtual-scroller__container",
            style: normalizeStyle26(containerStyleComputed.value)
          }, [
            createElementVNode20("div", {
              ref_key: "list",
              ref: list,
              role: "list",
              class: "va-virtual-scroller__list",
              style: normalizeStyle26(listStyleComputed.value)
            }, [
              (openBlock46(true), createElementBlock40(Fragment12, null, renderList8(renderBuffer.value, (item, index) => {
                return renderSlot38(_ctx.$slots, "default", normalizeProps17(mergeProps23({
                  key: uniqueKey(item, index)
                }, { item, index: renderStartIndex.value + index })));
              }), 128))
            ], 4)
          ], 4)
        ])
      ], 6);
    };
  }
});

// node_modules/vuestic-ui/dist/es/src/components/va-virtual-scroller/index.js
var VaVirtualScroller = withConfigTransport$1(_sfc_main49);

// node_modules/vuestic-ui/dist/es/src/components/va-inner-loading/VaInnerLoading.vue_vue_type_script_setup_true_lang.js
import { defineComponent as defineComponent50, computed as computed113, openBlock as openBlock47, createElementBlock as createElementBlock41, mergeProps as mergeProps24, renderSlot as renderSlot39, createVNode as createVNode18, unref as unref49, createCommentVNode as createCommentVNode23 } from "vue";
import "D:/Desktop/forntend/Front_End_Web_Hotel_Nhom_2/my-nuxt-app/node_modules/vuestic-ui/dist/es/VaInnerLoading.css";
var _hoisted_126 = {
  key: 0,
  class: "va-inner-loading__overlay",
  "aria-hidden": "true"
};
var _sfc_main50 = defineComponent50({
  ...{
    name: "VaInnerLoading"
  },
  __name: "VaInnerLoading",
  props: {
    ...useLoadingProps,
    ...useComponentPresetProp,
    color: { type: String },
    icon: { type: String, default: "va-loading" },
    size: { type: [Number, String], default: 30 }
  },
  setup(__props) {
    const props = __props;
    const { getColor } = useColors();
    const colorComputed = computed113(() => getColor(props.color));
    const computedClass = computed113(() => ({
      "va-inner-loading--active": props.loading
    }));
    const ariaAttributesComputed = computed113(() => ({
      "aria-busy": props.loading
    }));
    return (_ctx, _cache) => {
      return openBlock47(), createElementBlock41("div", mergeProps24({
        class: ["va-inner-loading", computedClass.value],
        "aria-live": "polite"
      }, ariaAttributesComputed.value), [
        renderSlot39(_ctx.$slots, "default"),
        _ctx.$props.loading ? (openBlock47(), createElementBlock41("div", _hoisted_126, [
          renderSlot39(_ctx.$slots, "loading", {}, () => [
            createVNode18(unref49(VaIcon), {
              class: "va-inner-loading__spinner",
              spin: "counter-clockwise",
              color: colorComputed.value,
              size: _ctx.$props.size,
              name: _ctx.$props.icon
            }, null, 8, ["color", "size", "name"])
          ])
        ])) : createCommentVNode23("", true)
      ], 16);
    };
  }
});

// node_modules/vuestic-ui/dist/es/src/components/va-inner-loading/index.js
var VaInnerLoading = withConfigTransport$1(_sfc_main50);

// node_modules/vuestic-ui/dist/es/src/components/va-data-table/VaDataTable.vue_vue_type_script_setup_true_lang.js
import "D:/Desktop/forntend/Front_End_Web_Hotel_Nhom_2/my-nuxt-app/node_modules/vuestic-ui/dist/es/VaDataTable.css";
var _hoisted_127 = { key: 0 };
var _hoisted_212 = {
  ref: "list",
  class: "va-data-table__table-tbody"
};
var _hoisted_38 = {
  key: "showNoDataHtml",
  class: "va-data-table__table-tr"
};
var _hoisted_47 = {
  class: "va-data-table__table-td no-data",
  colspan: "99999"
};
var _hoisted_56 = ["innerHTML"];
var _hoisted_65 = {
  key: "showNoDataFilteredHtml",
  class: "va-data-table__table-tr"
};
var _hoisted_73 = {
  class: "va-data-table__table-td no-data",
  colspan: "99999"
};
var _hoisted_8 = ["innerHTML"];
var _hoisted_9 = ["onClick", "onDblclick", "onContextmenu"];
var _hoisted_10 = {
  key: 0,
  class: "va-data-table__grid-column-header"
};
var _hoisted_11 = {
  key: 0,
  class: "va-data-table__table-tr"
};
var VaVirtualScrollerProps = extractComponentProps(VaVirtualScroller, ["items", "trackBy", "horizontal", "disabled", "table"]);
var VaDataTableThRowProps = extractComponentProps(VaDataTableThRow);
var _sfc_main51 = defineComponent51({
  ...{
    name: "VaDataTable",
    inheritAttrs: false
  },
  __name: "VaDataTable",
  props: {
    ...useComponentPresetProp,
    ...VaVirtualScrollerProps,
    ...useAnimationNameProps,
    ...useBindingProps,
    ...useTableScrollProps,
    ...useSortableProps,
    ...useStylableProps,
    ...useColumnsProps,
    ...useFilterableProps,
    ...usePaginatedRowsProps,
    ...createRowsProps(),
    ...useSelectableProps2,
    ...useThrottleProps,
    ...pick(VaDataTableThRowProps, ["ariaSelectAllRowsLabel", "ariaSortColumnByLabel"]),
    hoverable: { type: Boolean, default: false },
    clickable: { type: Boolean, default: false },
    loading: { type: Boolean, default: false },
    loadingColor: { type: String, default: "primary" },
    noDataHtml: { type: String, default: "No items" },
    noDataFilteredHtml: { type: String, default: "No items match the provided filtering condition" },
    hideDefaultHeader: { type: Boolean, default: false },
    footerClone: { type: Boolean, default: false },
    striped: { type: Boolean, default: false },
    virtualScroller: { type: Boolean, default: false },
    virtualTrackBy: { type: [String, Number], default: "initialIndex" },
    grid: { type: Boolean, default: false },
    gridColumns: { type: [Number, String], default: 0 },
    wrapperSize: { type: [Number, String], default: "auto" },
    ariaSelectRowLabel: useTranslationProp("$t:selectRowByIndex")
  },
  emits: [
    "update:modelValue",
    // `modelValue` is selectedItems
    "update:sortBy",
    "update:sortingOrder",
    "filtered",
    "sorted",
    "selectionChange",
    "row:click",
    "row:dblclick",
    "row:contextmenu",
    "columnSorted",
    ...useTableScrollEmits
  ],
  setup(__props, { emit: __emit }) {
    const { tp } = useTranslation();
    const props = __props;
    const emit = __emit;
    const { columnsComputed } = useColumns(props);
    const { rowsComputed } = useRows(columnsComputed, props);
    const { filteredRows } = useFilterable(rowsComputed, props, emit);
    const {
      sortBySync,
      sortingOrderSync,
      toggleSorting,
      sortedRows,
      sortingOrderIconName
    } = useSortable(columnsComputed, filteredRows, props, emit);
    const { paginatedRows } = usePaginatedRows(sortedRows, props);
    const {
      ctrlSelectRow,
      shiftSelectRows,
      toggleBulkSelection,
      isRowSelected,
      severalRowsSelected,
      allRowsSelected,
      toggleRowSelection
    } = useSelectableRow(paginatedRows, props, emit);
    const {
      CSSVariables,
      getCellCSSVariables,
      getClass: getClass2,
      getStyle: getStyle2
    } = useStylable(props);
    const { getRowBind, getCellBind } = useBinding(props);
    const animationName = useAnimationName(props, paginatedRows);
    const showNoDataHtml = computed114(() => props.items.length === 0);
    const showNoDataFilteredHtml = computed114(() => paginatedRows.value.length === 0);
    const onRowClickHandler = (name, event, row) => {
      emit(name, {
        event,
        item: row.source,
        itemIndex: row.initialIndex,
        row
      });
      if (props.selectable && props.grid) {
        toggleRowSelection(row);
      }
    };
    const computedTableAttributes = computed114(() => ({
      ...omit(attrs, ["class", "style"]),
      class: pick(props, ["striped", "selectable", "hoverable", "clickable"])
    }));
    const filteredVirtualScrollerProps = filterComponentProps(VaVirtualScrollerProps);
    const virtualScrollerPropsComputed = computed114(() => ({
      ...filteredVirtualScrollerProps.value,
      items: paginatedRows.value,
      trackBy: props.virtualTrackBy,
      disabled: !props.virtualScroller,
      table: true
    }));
    const attrs = useAttrs4();
    const computedAttributes = computed114(() => ({
      class: [
        { "va-data-table--sticky": props.stickyHeader || props.stickyFooter },
        { "va-data-table--scroll": !!props.height },
        { "va-data-table--virtual-scroller": isVirtualScroll.value },
        { "va-data-table--grid": props.grid },
        attrs.class
      ],
      style: [attrs.style],
      ...virtualScrollerPropsComputed.value
    }));
    const filteredThProps = filterComponentProps(VaDataTableThRowProps);
    const thAttributesComputed = computed114(() => ({
      ...filteredThProps.value,
      columns: columnsComputed.value,
      sortingOrderIconName: sortingOrderIconName.value,
      severalRowsSelected: severalRowsSelected.value,
      sortingOrderSync: sortingOrderSync.value,
      allRowsSelected: allRowsSelected.value,
      sortBySync: sortBySync.value
    }));
    const {
      scrollContainer,
      topTrigger,
      bottomTrigger,
      doRenderTopTrigger,
      doRenderBottomTrigger
    } = useTableScroll(props, emit);
    const isVirtualScroll = computed114(() => props.virtualScroller && !props.grid);
    const gridColumnsCount = computed114(() => props.gridColumns || "var(--va-data-table-grid-tbody-columns)");
    const cellData = (cellData2, internalColumnData) => internalColumnData.displayFormatFn ? internalColumnData.displayFormatFn(cellData2.value) : cellData2.value;
    return (_ctx, _cache) => {
      return openBlock48(), createBlock24(unref50(VaVirtualScroller), mergeProps25({ class: "va-data-table" }, computedAttributes.value, {
        ref_key: "scrollContainer",
        ref: scrollContainer,
        style: `--va-css-variables-selected-color: ${String(unref50(CSSVariables).selectedColor)};--va-css-variables-hover-color: ${String(unref50(CSSVariables).hoverColor)};--va-css-variables-table-height: ${String(unref50(CSSVariables).tableHeight)};--va-css-variables-thead-bg: ${String(unref50(CSSVariables).theadBg)};--va-css-variables-tfoot-bg: ${String(unref50(CSSVariables).tfootBg)};--va-grid-columns-count: ${String(gridColumnsCount.value)}`
      }), {
        content: withCtx23(({
          uniqueKey,
          renderBuffer,
          currentListOffset,
          listStyleComputed,
          containerStyleComputed
        }) => [
          createVNode19(unref50(VaInnerLoading), {
            "aria-live": "polite",
            style: normalizeStyle27(containerStyleComputed),
            loading: __props.loading,
            color: __props.loadingColor
          }, {
            default: withCtx23(() => [
              unref50(doRenderTopTrigger) ? (openBlock48(), createElementBlock42("div", {
                key: 0,
                ref_key: "topTrigger",
                ref: topTrigger,
                class: "va-data-table__scroll-trigger"
              }, null, 512)) : createCommentVNode24("", true),
              createElementVNode21("table", mergeProps25({
                class: "va-data-table__table",
                style: listStyleComputed
              }, computedTableAttributes.value), [
                "colgroup" in _ctx.$slots ? (openBlock48(), createElementBlock42("colgroup", _hoisted_127, [
                  renderSlot40(_ctx.$slots, "colgroup", normalizeProps18(guardReactiveProps14(unref50(columnsComputed))))
                ])) : createCommentVNode24("", true),
                createElementVNode21("thead", {
                  class: normalizeClass23(["va-data-table__table-thead", { "va-data-table__table-thead--sticky": _ctx.$props.stickyHeader }]),
                  style: normalizeStyle27({ top: isVirtualScroll.value && _ctx.$props.stickyHeader ? `-${currentListOffset}px` : void 0 })
                }, [
                  renderSlot40(_ctx.$slots, "headerPrepend"),
                  renderSlot40(_ctx.$slots, "header", {}, () => [
                    !__props.hideDefaultHeader ? (openBlock48(), createBlock24(unref50(VaDataTableThRow), mergeProps25({ key: 0 }, thAttributesComputed.value, {
                      onToggleBulkSelection: unref50(toggleBulkSelection),
                      onToggleSorting: unref50(toggleSorting)
                    }), createSlots4({ _: 2 }, [
                      renderList9(_ctx.$slots, (_, slot) => {
                        return {
                          name: slot,
                          fn: withCtx23((scope) => [
                            renderSlot40(_ctx.$slots, slot, normalizeProps18(guardReactiveProps14(scope)))
                          ])
                        };
                      })
                    ]), 1040, ["onToggleBulkSelection", "onToggleSorting"])) : createCommentVNode24("", true)
                  ]),
                  renderSlot40(_ctx.$slots, "headerAppend")
                ], 6),
                createElementVNode21("tbody", _hoisted_212, [
                  renderSlot40(_ctx.$slots, "bodyPrepend"),
                  createVNode19(TransitionGroup, {
                    name: isVirtualScroll.value ? "" : unref50(animationName),
                    css: !_ctx.$props.virtualScroller,
                    appear: !_ctx.$props.virtualScroller
                  }, {
                    default: withCtx23(() => [
                      showNoDataHtml.value ? (openBlock48(), createElementBlock42("tr", _hoisted_38, [
                        createElementVNode21("td", _hoisted_47, [
                          renderSlot40(_ctx.$slots, "no-data", {}, () => [
                            createElementVNode21("div", { innerHTML: __props.noDataHtml }, null, 8, _hoisted_56)
                          ])
                        ])
                      ])) : showNoDataFilteredHtml.value ? (openBlock48(), createElementBlock42("tr", _hoisted_65, [
                        createElementVNode21("td", _hoisted_73, [
                          renderSlot40(_ctx.$slots, "no-filtered-data", {}, () => [
                            renderSlot40(_ctx.$slots, "no-data", {}, () => [
                              createElementVNode21("div", { innerHTML: __props.noDataFilteredHtml }, null, 8, _hoisted_8)
                            ])
                          ])
                        ])
                      ])) : createCommentVNode24("", true),
                      (openBlock48(true), createElementBlock42(Fragment13, null, renderList9(renderBuffer, (row, index) => {
                        return openBlock48(), createElementBlock42(Fragment13, {
                          key: `table-row_${uniqueKey(row, index)}`
                        }, [
                          createElementVNode21("tr", mergeProps25({
                            class: ["va-data-table__table-tr", [{ selected: unref50(isRowSelected)(row), "va-data-table__table-tr--expanded": row.isExpandableRowVisible }]]
                          }, unref50(getRowBind)(row), {
                            onClick: ($event) => onRowClickHandler("row:click", $event, row),
                            onDblclick: ($event) => onRowClickHandler("row:dblclick", $event, row),
                            onContextmenu: ($event) => onRowClickHandler("row:contextmenu", $event, row)
                          }), [
                            _ctx.selectable && !_ctx.$props.grid ? (openBlock48(), createElementBlock42("td", {
                              class: "va-data-table__table-td va-data-table__table-cell-select",
                              key: `selectable_${uniqueKey(row, index)}`,
                              onSelectstart: _cache[0] || (_cache[0] = withModifiers10(() => {
                              }, ["prevent"]))
                            }, [
                              createVNode19(unref50(VaCheckbox), {
                                class: "va-data-table__table-cell-checkbox",
                                "model-value": unref50(isRowSelected)(row),
                                color: _ctx.selectedColor,
                                "aria-label": unref50(tp)(_ctx.$props.ariaSelectRowLabel, { index: row.initialIndex }),
                                onClick: [
                                  withModifiers10(($event) => unref50(shiftSelectRows)(row), ["shift", "exact", "stop"]),
                                  withModifiers10(($event) => unref50(ctrlSelectRow)(row), ["ctrl", "exact", "stop"]),
                                  withModifiers10(($event) => unref50(ctrlSelectRow)(row), ["exact", "stop"])
                                ]
                              }, null, 8, ["model-value", "color", "aria-label", "onClick"])
                            ], 32)) : createCommentVNode24("", true),
                            (openBlock48(true), createElementBlock42(Fragment13, null, renderList9(row.cells, (cell, cellIndex) => {
                              return openBlock48(), createElementBlock42("td", mergeProps25({
                                key: `table-cell_${cell.column.name + cell.rowIndex}`,
                                class: ["va-data-table__table-td", unref50(getClass2)(cell.column.tdClass)],
                                style: [
                                  cell.column.width ? { minWidth: cell.column.width, maxWidth: cell.column.width } : {},
                                  unref50(getCellCSSVariables)(cell),
                                  unref50(getStyle2)(cell.column.tdStyle)
                                ]
                              }, unref50(getCellBind)(cell, row)), [
                                `cell(${cell.column.name})` in _ctx.$slots ? renderSlot40(_ctx.$slots, `cell(${cell.column.name})`, normalizeProps18(mergeProps25({ key: 0 }, { ...cell, row, isExpanded: row.isExpandableRowVisible }))) : renderSlot40(_ctx.$slots, "cell", normalizeProps18(mergeProps25({ key: 1 }, { cell, row })), () => [
                                  _ctx.$props.grid ? (openBlock48(), createElementBlock42("span", _hoisted_10, toDisplayString17(unref50(columnsComputed)[cellIndex].label), 1)) : createCommentVNode24("", true),
                                  createTextVNode13(" " + toDisplayString17(cellData(cell, unref50(columnsComputed)[cellIndex])), 1)
                                ])
                              ], 16);
                            }), 128))
                          ], 16, _hoisted_9),
                          row.isExpandableRowVisible ? (openBlock48(), createElementBlock42("tr", _hoisted_11, [
                            (openBlock48(), createElementBlock42("td", {
                              class: "va-data-table__table-expanded-content",
                              colspan: "99999",
                              key: uniqueKey(row, index)
                            }, [
                              renderSlot40(_ctx.$slots, "expandableRow", normalizeProps18(guardReactiveProps14(row)))
                            ]))
                          ])) : createCommentVNode24("", true)
                        ], 64);
                      }), 128))
                    ]),
                    _: 2
                  }, 1032, ["name", "css", "appear"]),
                  renderSlot40(_ctx.$slots, "bodyAppend")
                ], 512),
                ["footer", "footerPrepend", "footerAppend"].some((field) => _ctx.$slots[field]) || __props.footerClone && !_ctx.$props.grid ? (openBlock48(), createElementBlock42("tfoot", {
                  key: 1,
                  class: normalizeClass23(["va-data-table__table-tfoot", { "va-data-table__table-tfoot--sticky": _ctx.$props.stickyFooter }]),
                  style: normalizeStyle27({ bottom: isVirtualScroll.value && _ctx.$props.stickyFooter ? `${currentListOffset}px` : void 0 })
                }, [
                  renderSlot40(_ctx.$slots, "footerPrepend"),
                  renderSlot40(_ctx.$slots, "footer", {}, () => [
                    !__props.hideDefaultHeader ? (openBlock48(), createBlock24(unref50(VaDataTableThRow), mergeProps25({ key: 0 }, thAttributesComputed.value, {
                      "is-footer": "",
                      onToggleBulkSelection: unref50(toggleBulkSelection),
                      onToggleSorting: unref50(toggleSorting)
                    }), createSlots4({ _: 2 }, [
                      renderList9(_ctx.$slots, (_, slot) => {
                        return {
                          name: slot,
                          fn: withCtx23((scope) => [
                            renderSlot40(_ctx.$slots, slot, normalizeProps18(guardReactiveProps14(scope)))
                          ])
                        };
                      })
                    ]), 1040, ["onToggleBulkSelection", "onToggleSorting"])) : createCommentVNode24("", true)
                  ]),
                  renderSlot40(_ctx.$slots, "footerAppend")
                ], 6)) : createCommentVNode24("", true)
              ], 16),
              unref50(doRenderBottomTrigger) ? (openBlock48(), createElementBlock42("div", {
                key: 1,
                ref_key: "bottomTrigger",
                ref: bottomTrigger,
                class: "va-data-table__scroll-trigger"
              }, null, 512)) : createCommentVNode24("", true)
            ]),
            _: 2
          }, 1032, ["style", "loading", "color"])
        ]),
        _: 3
      }, 16, ["style"]);
    };
  }
});

// node_modules/vuestic-ui/dist/es/src/components/va-data-table/index.js
var VaDataTable = withConfigTransport$1(_sfc_main51);

// node_modules/vuestic-ui/dist/es/src/components/va-date-input/VaDateInput.vue_vue_type_script_setup_true_lang.js
import { defineComponent as defineComponent58, shallowRef as shallowRef19, ref as ref48, toRefs as toRefs7, watch as watch40, computed as computed126, toRef as toRef8, useSlots as useSlots7, useAttrs as useAttrs5, openBlock as openBlock55, createBlock as createBlock27, unref as unref59, mergeProps as mergeProps31, isRef as isRef8, withCtx as withCtx29, renderSlot as renderSlot46, normalizeProps as normalizeProps23, guardReactiveProps as guardReactiveProps19, createVNode as createVNode24, toHandlers as toHandlers5, createSlots as createSlots6, withModifiers as withModifiers13, withKeys as withKeys16, createCommentVNode as createCommentVNode28, renderList as renderList14, nextTick as nextTick9 } from "vue";

// node_modules/vuestic-ui/dist/es/src/components/va-date-input/hooks/range-model-value-guard.js
import { ref as ref42, computed as computed115, watch as watch33 } from "vue";

// node_modules/vuestic-ui/dist/es/src/components/va-date-input/hooks/model-value-parser.js
var isRange = (date) => {
  if (date === null) {
    return false;
  }
  return typeof date === "object" && ("start" in date || "end" in date);
};

// node_modules/vuestic-ui/dist/es/src/components/va-date-input/hooks/range-model-value-guard.js
var useRangeModelValueGuard = (modelValue, disabled) => {
  const bufferValue = ref42(modelValue.value);
  const valueComputed = computed115({
    get: () => bufferValue.value,
    set: (value) => {
      if (disabled.value) {
        modelValue.value = value;
      }
      if (!value) {
        modelValue.value = value;
        return;
      }
      if (isRange(value)) {
        if (value.end !== null) {
          modelValue.value = value;
        }
      } else {
        modelValue.value = value;
      }
      bufferValue.value = value;
    }
  });
  watch33(modelValue, (newValue) => {
    bufferValue.value = newValue;
  });
  const reset = () => {
    if (bufferValue.value && isRange(bufferValue.value)) {
      bufferValue.value = modelValue.value;
    }
  };
  return {
    valueComputed,
    reset
  };
};

// node_modules/vuestic-ui/dist/es/src/utils/is-date.js
var isDate = (value) => Object.prototype.toString.call(value) === "[object Date]";

// node_modules/vuestic-ui/dist/es/src/components/va-date-input/hooks/input-text-parser.js
import { ref as ref43 } from "vue";
var defaultParseDateFunction = (text) => new Date(Date.parse(text));
var isValidDate = (d) => isDate(d) && !isNaN(d.getTime());
var useDateParser = (props) => {
  const isMultipleDates = (text) => {
    const dates = text.split(props.delimiter);
    if (dates.length < 2) {
      return false;
    }
    return dates.every((date) => {
      const parsedDate = (props.parseDate || defaultParseDateFunction)(date);
      return isValidDate(parsedDate);
    });
  };
  const isRange4 = (text) => text.includes(props.rangeDelimiter);
  const isValid = ref43(true);
  const parseDate = (text) => {
    const splitDate = text.split(".");
    const valueToParse = (splitDate == null ? void 0 : splitDate.length) === 3 ? splitDate.reverse().join("-") : text;
    const date = (props.parseDate || defaultParseDateFunction)(valueToParse);
    isValid.value = isValidDate(date);
    return date;
  };
  const parseDateInputValue = (text) => {
    isValid.value = true;
    if (props.parse) {
      return props.parse(text, isValid);
    }
    if (isMultipleDates(text)) {
      return text.split(props.delimiter).map(parseDate);
    }
    if (isRange4(text)) {
      const [start, end] = text.split(props.rangeDelimiter).map(parseDate);
      return { start, end };
    }
    return parseDate(text);
  };
  return {
    parseDateInputValue,
    isValid
  };
};

// node_modules/vuestic-ui/dist/es/src/components/va-date-input/hooks/model-value.js
import { computed as computed116 } from "vue";

// node_modules/vuestic-ui/dist/es/src/components/va-date-input/utils/parse-date.js
var isISO8601 = (date) => {
  const isoDate = Date.parse(date);
  return !isNaN(isoDate) && !date.includes(" ");
};
var isRFC1123GTM = (date) => {
  return date.endsWith("GMT");
};
var isRFC1123 = (date) => {
  const rfcDate = new Date(date);
  return !isNaN(rfcDate.getTime());
};
var formatDateToTheSameStandardFormat = (date, formattedString) => {
  if (isRFC1123GTM(formattedString)) {
    return date.toUTCString();
  }
  if (isISO8601(formattedString)) {
    return date.toISOString();
  }
  if (isRFC1123(formattedString)) {
    return date.toString();
  }
  return null;
};

// node_modules/vuestic-ui/dist/es/src/components/va-date-input/hooks/model-value.js
var isRange2 = (date) => {
  if (date === null) {
    return false;
  }
  return typeof date === "object" && ("start" in date || "end" in date);
};
var isMultiple = (date) => {
  if (date === null) {
    return false;
  }
  return Array.isArray(date);
};
var isSingleDate = (date) => {
  if (date === null) {
    return false;
  }
  return typeof date === "string" || typeof date === "number" || date instanceof Date;
};
var useDateInputModelValue = (modelValue, mode, parseModelValue, formatModelValue, formatModelValueSingleDate) => {
  const syncFormat = (original, target) => {
    if (formatModelValueSingleDate) {
      return formatModelValueSingleDate(target);
    }
    if (typeof original === "string") {
      const standardFormat = formatDateToTheSameStandardFormat(target, original);
      if (standardFormat) {
        return standardFormat;
      }
      return formatModelValue(target);
    }
    if (typeof original === "number") {
      return target.getTime();
    }
    return target;
  };
  const normalizeSingleDate = (value) => {
    if (value instanceof Date) {
      return value;
    }
    return new Date(value);
  };
  const dateValue = computed116(() => {
    if (modelValue.value === null || modelValue.value === void 0) {
      return null;
    }
    if (typeof modelValue.value === "string") {
      return parseModelValue(modelValue.value);
    }
    if (typeof modelValue.value === "number") {
      return new Date(modelValue.value);
    }
    return modelValue.value;
  });
  const normalized = computed116({
    get: () => {
      if (dateValue.value === null || dateValue.value === void 0) {
        return null;
      }
      if (isMultiple(dateValue.value)) {
        return dateValue.value.map(normalizeSingleDate);
      }
      if (isRange2(dateValue.value)) {
        const { start, end } = dateValue.value;
        return {
          start: start ? normalizeSingleDate(start) : null,
          end: end ? normalizeSingleDate(end) : null
        };
      }
      return normalizeSingleDate(dateValue.value);
    },
    set(newValue) {
      var _a2, _b;
      if (newValue === null || newValue === void 0) {
        modelValue.value = newValue;
        return;
      }
      if (isMultiple(newValue) && (isMultiple(modelValue.value) || isNil(modelValue.value))) {
        const originalValue = modelValue.value;
        modelValue.value = newValue.map((v, index) => syncFormat((originalValue == null ? void 0 : originalValue[index]) || (originalValue == null ? void 0 : originalValue[0]), v));
        return;
      }
      if (isRange2(newValue) && (isRange2(modelValue.value) || isNil(modelValue.value))) {
        const { start, end } = newValue;
        modelValue.value = {
          start: start ? syncFormat((_a2 = modelValue.value) == null ? void 0 : _a2.start, start) : null,
          // Sync end date only if start date is specified
          end: end ? syncFormat((_b = modelValue.value) == null ? void 0 : _b.start, end) : null
        };
        return;
      }
      if (isSingleDate(newValue) && (isSingleDate(modelValue.value) || isNil(modelValue.value))) {
        modelValue.value = syncFormat(modelValue.value, newValue);
        return;
      }
      throw new Error("Input date is not the same as date from props");
    }
  });
  const text = computed116({
    get: () => {
      if (normalized.value === null || normalized.value === void 0) {
        return "";
      }
      return formatModelValue(normalized.value);
    },
    set: (value) => {
      modelValue.value = parseModelValue(value);
    }
  });
  return {
    text,
    normalized
  };
};

// node_modules/vuestic-ui/dist/es/src/components/va-date-picker/utils/date-utils.js
var isDatesDayEqual = (date1, date2) => (date1 == null ? void 0 : date1.toDateString()) === (date2 == null ? void 0 : date2.toDateString());
var isDatesYearEqual = (date1, date2) => {
  return (date1 == null ? void 0 : date1.getFullYear()) === (date2 == null ? void 0 : date2.getFullYear());
};
var isDatesMonthEqual = (date1, date2) => {
  return isDatesYearEqual(date1, date2) && (date1 == null ? void 0 : date1.getMonth()) === (date2 == null ? void 0 : date2.getMonth());
};
var createYearDate = (year) => {
  const date = /* @__PURE__ */ new Date();
  date.setFullYear(year);
  return date;
};
var isRange3 = (value) => {
  if (value === null) {
    return false;
  }
  return typeof value === "object" && ("start" in value || "end" in value);
};
var isSingleDate2 = (value) => isDate(value);
var isDates = (value) => Array.isArray(value);

// node_modules/vuestic-ui/dist/es/src/components/va-date-picker/VaDatePicker.vue_vue_type_script_setup_true_lang.js
import { defineComponent as defineComponent57, ref as ref47, computed as computed124, watch as watch38, nextTick as nextTick8, openBlock as openBlock54, createElementBlock as createElementBlock48, normalizeClass as normalizeClass25, normalizeStyle as normalizeStyle29, createVNode as createVNode23, mergeProps as mergeProps30, unref as unref57, isRef as isRef7, createSlots as createSlots5, renderList as renderList13, withCtx as withCtx28, renderSlot as renderSlot45, normalizeProps as normalizeProps22, guardReactiveProps as guardReactiveProps18, createElementVNode as createElementVNode24, createBlock as createBlock26, createCommentVNode as createCommentVNode27 } from "vue";

// node_modules/vuestic-ui/dist/es/src/components/va-date-picker/hooks/view.js
import { ref as ref44, computed as computed117 } from "vue";
var JANUARY_MONTH_INDEX = 0;
var DECEMBER_MONTH_INDEX = 11;
var addMonth = (view) => {
  if (view.month === DECEMBER_MONTH_INDEX) {
    return { ...view, year: view.year + 1, month: JANUARY_MONTH_INDEX };
  } else {
    return { ...view, month: view.month + 1 };
  }
};
var subMonth = (view) => {
  if (view.month === JANUARY_MONTH_INDEX) {
    return { ...view, year: view.year - 1, month: DECEMBER_MONTH_INDEX };
  } else {
    return { ...view, month: view.month - 1 };
  }
};
var getDefaultDate = (modelValue) => {
  if (isDate(modelValue)) {
    return modelValue;
  }
  if (isDate(modelValue == null ? void 0 : modelValue.start)) {
    return modelValue.start;
  }
  if (Array.isArray(modelValue) && isDate(modelValue[0])) {
    return modelValue[0];
  }
  return /* @__PURE__ */ new Date();
};
var useView = (props, emit, defaultOverride) => {
  const defaultDate = getDefaultDate(props.modelValue);
  const defaultView = {
    type: "day",
    year: defaultDate.getFullYear(),
    month: defaultDate.getMonth(),
    ...defaultOverride
  };
  const statefulView = ref44(defaultView);
  const syncView = computed117({
    get() {
      return { ...statefulView.value, ...props.view };
    },
    set(view) {
      statefulView.value = view;
      emit("update:view", view);
    }
  });
  const next = () => {
    if (syncView.value.type === "day") {
      syncView.value = addMonth(syncView.value);
    } else if (syncView.value.type === "month") {
      syncView.value = { ...syncView.value, year: syncView.value.year + 1 };
    }
  };
  const prev = () => {
    if (syncView.value.type === "day") {
      syncView.value = subMonth(syncView.value);
    } else if (syncView.value.type === "month") {
      syncView.value = { ...syncView.value, year: syncView.value.year - 1 };
    }
  };
  return {
    syncView,
    next,
    prev
  };
};

// node_modules/vuestic-ui/dist/es/src/components/va-date-picker/components/VaDayPicker/VaDayPicker.vue_vue_type_script_setup_true_lang.js
import { defineComponent as defineComponent53, toRefs as toRefs4, computed as computed121, watch as watch35, openBlock as openBlock50, createElementBlock as createElementBlock44, mergeProps as mergeProps26, unref as unref53, Fragment as Fragment14, renderList as renderList10, renderSlot as renderSlot42, createTextVNode as createTextVNode14, toDisplayString as toDisplayString18, createCommentVNode as createCommentVNode25, createVNode as createVNode20, withCtx as withCtx24, createElementVNode as createElementVNode22, normalizeProps as normalizeProps19, guardReactiveProps as guardReactiveProps15 } from "vue";

// node_modules/vuestic-ui/dist/es/src/components/va-date-picker/components/VaDatePickerCell.vue_vue_type_script_setup_true_lang.js
import { defineComponent as defineComponent52, computed as computed118, openBlock as openBlock49, createElementBlock as createElementBlock43, normalizeStyle as normalizeStyle28, unref as unref51, normalizeClass as normalizeClass24, withKeys as withKeys14, withModifiers as withModifiers11, renderSlot as renderSlot41 } from "vue";
import "D:/Desktop/forntend/Front_End_Web_Hotel_Nhom_2/my-nuxt-app/node_modules/vuestic-ui/dist/es/VaDatePickerCell.css";
var _hoisted_128 = ["onKeypress"];
var _sfc_main52 = defineComponent52({
  ...{
    name: "VaDatePickerCell"
  },
  __name: "VaDatePickerCell",
  props: {
    otherMonth: { type: Boolean, default: false },
    today: { type: Boolean, default: false },
    inRange: { type: Boolean, default: false },
    disabled: { type: Boolean, default: false },
    selected: { type: Boolean, default: false },
    weekend: { type: Boolean, default: false },
    hidden: { type: Boolean, default: false },
    focused: { type: Boolean, default: false },
    highlightWeekend: { type: Boolean, default: false },
    highlightToday: { type: Boolean, default: false },
    readonly: { type: Boolean, default: false },
    color: { type: String, default: "primary" }
  },
  emits: ["click"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const onClick = () => {
      if (!props.disabled) {
        emit("click");
      }
    };
    const { getColor } = useColors();
    const bg = computed118(() => getColor(props.color));
    const { textColorComputed } = useTextColor(bg);
    return (_ctx, _cache) => {
      return __props.hidden ? (openBlock49(), createElementBlock43("div", {
        key: 0,
        class: "va-date-picker-cell va-date-picker-cell_clear",
        style: normalizeStyle28(`--va-bg: ${String(bg.value)};--va-text-color-computed: ${String(unref51(textColorComputed))}`)
      }, null, 4)) : (openBlock49(), createElementBlock43("div", {
        key: 1,
        class: normalizeClass24(["va-date-picker-cell", {
          "va-date-picker-cell_other-month": __props.otherMonth,
          "va-date-picker-cell_today": __props.highlightToday && __props.today,
          "va-date-picker-cell_in-range": __props.inRange,
          "va-date-picker-cell_disabled": __props.disabled,
          "va-date-picker-cell_highlighted-weekend": __props.highlightWeekend && __props.weekend,
          "va-date-picker-cell_selected": __props.selected,
          "va-date-picker-cell_focused": __props.focused,
          "va-date-picker-cell_readonly": __props.readonly
        }]),
        onClick,
        onKeypress: withKeys14(withModifiers11(onClick, ["prevent", "stop"]), ["space", "enter"]),
        style: normalizeStyle28(`--va-bg: ${String(bg.value)};--va-text-color-computed: ${String(unref51(textColorComputed))}`)
      }, [
        renderSlot41(_ctx.$slots, "default")
      ], 46, _hoisted_128));
    };
  }
});

// node_modules/vuestic-ui/dist/es/src/components/va-date-picker/hooks/grid-keyboard-navigation.js
import { ref as ref45, unref as unref52 } from "vue";
function isUndefined(t) {
  return t === void 0;
}
var useGridKeyboardNavigation = ({
  rowSize,
  start,
  end,
  onSelected,
  onFocusIndex
}) => {
  const focusedCellIndex = ref45(-1);
  let previouslyClicked2 = false;
  const onMousedown = () => {
    previouslyClicked2 = true;
  };
  const onFocus = () => {
    if (previouslyClicked2) {
      return;
    }
    previouslyClicked2 = false;
    const index = onFocusIndex === void 0 ? unref52(start) || 0 : unref52(onFocusIndex);
    focusedCellIndex.value = index;
  };
  const onBlur = () => {
    previouslyClicked2 = false;
    focusedCellIndex.value = -1;
  };
  const onKeydown = (e) => {
    if (["ArrowRight", "ArrowLeft", "ArrowDown", "ArrowUp", "Enter", "Space"].includes(e.key)) {
      e.preventDefault();
      e.stopPropagation();
    }
    if (e.key === "Enter" || e.key === "Space") {
      if (onSelected === void 0) {
        return;
      }
      onSelected(focusedCellIndex.value);
      return;
    }
    if (e.key === "ArrowRight") {
      focusedCellIndex.value += 1;
    }
    if (e.key === "ArrowLeft") {
      focusedCellIndex.value -= 1;
    }
    if (e.key === "ArrowDown") {
      focusedCellIndex.value += rowSize;
    }
    if (e.key === "ArrowUp") {
      focusedCellIndex.value -= rowSize;
    }
    if (!isUndefined(start) && focusedCellIndex.value < unref52(start)) {
      focusedCellIndex.value = unref52(start);
    }
    if (!isUndefined(end) && focusedCellIndex.value > unref52(end) - 1) {
      focusedCellIndex.value = unref52(end) - 1;
    }
  };
  const containerAttributes = {
    onFocus,
    onKeydown,
    onBlur,
    onMousedown,
    tabindex: 0
  };
  return {
    focusedCellIndex,
    containerAttributes
  };
};

// node_modules/vuestic-ui/dist/es/src/components/va-date-picker/hooks/use-picker.js
import { ref as ref46, computed as computed119, watch as watch34 } from "vue";

// node_modules/vuestic-ui/dist/es/src/components/va-date-picker/hooks/model-value-helper.js
var modeInitialValue = (date, mode) => {
  if (mode === "single") {
    return date;
  } else if (mode === "range") {
    return { start: date, end: null };
  } else if (mode === "multiple") {
    return [date];
  } else if (mode === "auto") {
    return date;
  }
  throw new Error("Unknown mode");
};
var throwIncorrectModelValueError = (modelValue, mode) => {
  throw Error(`Incorrect modelValue for mode ${mode}. Got ${JSON.stringify(modelValue)}`);
};
var modeFromModelValue = (modelValue) => {
  if (isSingleDate2(modelValue)) {
    return "single";
  } else if (isRange3(modelValue)) {
    return "range";
  } else if (isDates(modelValue)) {
    return "multiple";
  }
  return throwIncorrectModelValueError(modelValue, "auto");
};
var sortRange = (modelValue) => {
  if (modelValue.start && modelValue.end) {
    if (modelValue.start > modelValue.end) {
      return { start: modelValue.end, end: modelValue.start };
    }
  }
  return modelValue;
};
var useDatePickerModelValue = (props, emit, dateEqual) => {
  const updateModelValue = (date) => {
    if (!props.modelValue) {
      emit("update:modelValue", modeInitialValue(date, props.mode));
      return;
    }
    const mode = props.mode === "auto" ? modeFromModelValue(props.modelValue) : props.mode;
    if (mode === "single") {
      if (!isSingleDate2(props.modelValue)) {
        return throwIncorrectModelValueError(props.modelValue, mode);
      }
      emit("update:modelValue", date);
    } else if (mode === "range") {
      if (!isRange3(props.modelValue)) {
        return throwIncorrectModelValueError(props.modelValue, mode);
      }
      if (props.modelValue.end && dateEqual(props.modelValue.end, date)) {
        return emit("update:modelValue", { start: props.modelValue.start, end: null });
      }
      if (props.modelValue.start && dateEqual(props.modelValue.start, date)) {
        return emit("update:modelValue", { start: null, end: props.modelValue.end });
      }
      if (props.modelValue.end === null) {
        return emit("update:modelValue", sortRange({ start: props.modelValue.start, end: date }));
      }
      if (props.modelValue.start === null) {
        return emit("update:modelValue", sortRange({ end: props.modelValue.end, start: date }));
      }
      emit("update:modelValue", { start: date, end: null });
    } else if (mode === "multiple") {
      if (!isDates(props.modelValue)) {
        return throwIncorrectModelValueError(props.modelValue, mode);
      }
      const isDatesIncludesDate = !!props.modelValue.find((d) => dateEqual(d, date));
      if (isDatesIncludesDate) {
        emit("update:modelValue", props.modelValue.filter((d) => !dateEqual(d, date)));
      } else {
        emit("update:modelValue", [...props.modelValue, date].sort((a, b) => a.getTime() - b.getTime()));
      }
    }
  };
  return {
    updateModelValue
  };
};

// node_modules/vuestic-ui/dist/es/src/components/va-date-picker/hooks/use-picker.js
var getDateEqualFunction = (type) => {
  return {
    month: isDatesMonthEqual,
    day: isDatesDayEqual,
    year: isDatesYearEqual
  }[type];
};
var useDatePicker = (type, dates, props, emit) => {
  const datesEqual = getDateEqualFunction(type);
  const isAllowedDate = props.allowedDays || props.allowedMonths || props.allowedYears;
  const isDateDisabled = (date) => isAllowedDate === void 0 ? false : !isAllowedDate(date);
  const hoveredIndex = ref46(-1);
  const hoveredValue = computed119(() => dates.value[hoveredIndex.value]);
  const { updateModelValue } = useDatePickerModelValue(
    props,
    emit,
    datesEqual
  );
  const onClick = (date) => {
    if (props.readonly || isDateDisabled(date)) {
      return;
    }
    updateModelValue(date);
    emit(`click:${type}`, date);
  };
  const isToday = (date) => {
    const today = /* @__PURE__ */ new Date();
    return datesEqual(today, date);
  };
  const isSelected = (date) => {
    if (!props.modelValue) {
      return false;
    }
    if (isSingleDate2(props.modelValue)) {
      return datesEqual(props.modelValue, date);
    } else if (isDates(props.modelValue)) {
      return !!props.modelValue.find((d) => datesEqual(d, date));
    } else if (isRange3(props.modelValue)) {
      return datesEqual(props.modelValue.start, date) || datesEqual(props.modelValue.end, date);
    }
    return false;
  };
  const isInRange = (date) => {
    if (!props.modelValue) {
      return false;
    }
    if (!isRange3(props.modelValue)) {
      return false;
    }
    if (props.modelValue.start && props.modelValue.end) {
      return props.modelValue.start < date && props.modelValue.end > date;
    }
    const selectedDate = props.modelValue.start || props.modelValue.end;
    if (selectedDate) {
      if (!hoveredValue.value) {
        return false;
      }
      return selectedDate < date ? hoveredValue.value >= date : hoveredValue.value <= date;
    }
    return false;
  };
  watch34(hoveredValue, (date) => {
    emit(`hover:${type}`, date);
  });
  return {
    hoveredIndex,
    hoveredValue,
    onClick,
    isToday,
    isSelected,
    isInRange
  };
};

// node_modules/vuestic-ui/dist/es/src/components/va-date-picker/components/VaDayPicker/va-date-picker-calendar-hook.js
import { computed as computed120 } from "vue";
var getMonthDaysCount = (year, month) => new Date(year, month + 1, 0).getDate();
var getMonthStartWeekday = (year, month) => new Date(year, month, 1).getDay();
var getNumbersArray = (length) => Array.from(Array(length).keys()).map((k) => k + 1);
var useVaDatePickerCalendar = (view, options) => {
  const CALENDAR_ROWS_COUNT = 6;
  const localizeWeekday = (weekdayNumber) => {
    var _a2;
    if (!options || !((_a2 = options.firstWeekday) == null ? void 0 : _a2.value)) {
      return weekdayNumber;
    }
    if (options.firstWeekday.value.toLowerCase() === "monday") {
      return weekdayNumber === 0 ? 6 : weekdayNumber - 1;
    }
    return weekdayNumber;
  };
  const currentMonthStartWeekday = computed120(() => localizeWeekday(getMonthStartWeekday(view.value.year, view.value.month)));
  const getPreviousDates = () => {
    if (currentMonthStartWeekday.value === 0) {
      return [];
    }
    const prevMonthDaysCount = getMonthDaysCount(view.value.year, view.value.month - 1);
    const prevMonthDays = getNumbersArray(prevMonthDaysCount);
    return prevMonthDays.slice(-currentMonthStartWeekday.value).map((d) => new Date(view.value.year, view.value.month - 1, d));
  };
  const getCurrentDates = () => {
    const currentMonthDays = getNumbersArray(getMonthDaysCount(view.value.year, view.value.month));
    return currentMonthDays.map((d) => new Date(view.value.year, view.value.month, d));
  };
  const prevAndCurrentDays = computed120(() => [...getPreviousDates(), ...getCurrentDates()]);
  const currentMonthEndIndex = computed120(() => prevAndCurrentDays.value.length);
  const calendarDates = computed120(() => {
    const days = prevAndCurrentDays.value;
    const daysRemaining = 7 * CALENDAR_ROWS_COUNT - days.length;
    const nextMonthDaysCount = getMonthDaysCount(view.value.year, view.value.month + 1);
    const nextMonthDays = getNumbersArray(nextMonthDaysCount);
    return [
      ...days,
      ...nextMonthDays.slice(0, daysRemaining).map((d) => new Date(view.value.year, view.value.month + 1, d))
    ];
  });
  return { calendarDates, currentMonthStartIndex: currentMonthStartWeekday, currentMonthEndIndex };
};

// node_modules/vuestic-ui/dist/es/src/components/va-date-picker/components/VaDayPicker/VaDayPicker.vue_vue_type_script_setup_true_lang.js
import "D:/Desktop/forntend/Front_End_Web_Hotel_Nhom_2/my-nuxt-app/node_modules/vuestic-ui/dist/es/VaDayPicker.css";
var _hoisted_129 = ["onMouseenter"];
var _hoisted_213 = { class: "va-date-picker-cell__day" };
var _sfc_main53 = defineComponent53({
  ...{
    name: "VaDayPicker"
  },
  __name: "VaDayPicker",
  props: {
    monthNames: { type: Array, required: true },
    weekdayNames: { type: Array, required: true },
    firstWeekday: { type: String, default: "Sunday" },
    hideWeekDays: { type: Boolean, default: false },
    view: { type: Object, default: () => ({ type: "day" }) },
    modelValue: { type: [Date, Array, Object] },
    mode: { type: String, default: "auto" },
    showOtherMonths: { type: Boolean, default: false },
    allowedDays: { type: Function },
    weekends: { type: Function },
    highlightWeekend: { type: Boolean, default: false },
    highlightToday: { type: Boolean, default: false },
    readonly: { type: Boolean, default: false },
    color: { type: String, default: "primary" }
  },
  emits: ["update:modelValue", "hover:day", "click:day"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const { firstWeekday, weekdayNames, view } = toRefs4(props);
    const { calendarDates, currentMonthStartIndex, currentMonthEndIndex } = useVaDatePickerCalendar(view, { firstWeekday });
    const weekdayNamesComputed = computed121(() => {
      return firstWeekday.value.toLowerCase() === "sunday" ? weekdayNames.value : [...weekdayNames.value.slice(1), weekdayNames.value[0]];
    });
    const {
      hoveredIndex,
      onClick,
      isToday,
      isSelected,
      isInRange
    } = useDatePicker("day", calendarDates, props, emit);
    const gridStartIndex = computed121(() => props.showOtherMonths ? 0 : currentMonthStartIndex.value);
    const gridEndIndex = computed121(() => props.showOtherMonths ? calendarDates.value.length : currentMonthEndIndex.value);
    const {
      focusedCellIndex,
      containerAttributes
    } = useGridKeyboardNavigation({
      rowSize: 7,
      start: gridStartIndex,
      end: gridEndIndex,
      onSelected: (selectedValue) => onClick(calendarDates.value[selectedValue])
    });
    watch35(focusedCellIndex, (index) => {
      hoveredIndex.value = index;
    });
    watch35(hoveredIndex, (index) => {
      focusedCellIndex.value = index;
    });
    const isOtherMonth = (date) => props.view.month !== date.getMonth();
    const isDateDisabled = (date) => props.allowedDays === void 0 ? false : !props.allowedDays(date);
    const isDateWeekend = (date) => {
      if (props.weekends === void 0) {
        return date.getDay() === 6 || date.getDay() === 0;
      }
      return props.weekends(date);
    };
    return (_ctx, _cache) => {
      return openBlock50(), createElementBlock44("div", mergeProps26({ class: "va-day-picker" }, unref53(containerAttributes)), [
        !__props.hideWeekDays ? (openBlock50(true), createElementBlock44(Fragment14, { key: 0 }, renderList10(weekdayNamesComputed.value, (weekday) => {
          return openBlock50(), createElementBlock44("div", {
            key: weekday,
            class: "va-day-picker__weekday"
          }, [
            renderSlot42(_ctx.$slots, "weekday", {}, () => [
              createTextVNode14(toDisplayString18(weekday), 1)
            ])
          ]);
        }), 128)) : createCommentVNode25("", true),
        (openBlock50(true), createElementBlock44(Fragment14, null, renderList10(unref53(calendarDates), (date, index) => {
          return openBlock50(), createElementBlock44("div", {
            class: "va-day-picker__calendar__day-wrapper",
            key: index,
            onMouseenter: ($event) => hoveredIndex.value = index,
            onMouseleave: _cache[0] || (_cache[0] = ($event) => hoveredIndex.value = -1)
          }, [
            createVNode20(_sfc_main52, {
              hidden: isOtherMonth(date) && !__props.showOtherMonths,
              today: unref53(isToday)(date),
              selected: unref53(isSelected)(date),
              "in-range": unref53(isInRange)(date),
              "other-month": isOtherMonth(date),
              weekend: isDateWeekend(date),
              disabled: isDateDisabled(date),
              focused: unref53(hoveredIndex) === index,
              "highlight-today": __props.highlightToday,
              "highlight-weekend": __props.highlightWeekend,
              readonly: _ctx.$props.readonly,
              color: __props.color,
              onClick: ($event) => {
                unref53(onClick)(date);
                focusedCellIndex.value = index;
              }
            }, {
              default: withCtx24(() => [
                createElementVNode22("span", _hoisted_213, [
                  renderSlot42(_ctx.$slots, "day", normalizeProps19(guardReactiveProps15({ date })), () => [
                    createTextVNode14(toDisplayString18(date.getDate()), 1)
                  ])
                ])
              ]),
              _: 2
            }, 1032, ["hidden", "today", "selected", "in-range", "other-month", "weekend", "disabled", "focused", "highlight-today", "highlight-weekend", "readonly", "color", "onClick"])
          ], 40, _hoisted_129);
        }), 128))
      ], 16);
    };
  }
});

// node_modules/vuestic-ui/dist/es/src/components/va-date-picker/components/VaDatePickerHeader/VaDatePickerHeader.vue_vue_type_script_setup_true_lang.js
import { defineComponent as defineComponent54, unref as unref54, openBlock as openBlock51, createElementBlock as createElementBlock45, renderSlot as renderSlot43, normalizeProps as normalizeProps20, guardReactiveProps as guardReactiveProps16, createVNode as createVNode21, createElementVNode as createElementVNode23, withCtx as withCtx25, createTextVNode as createTextVNode15, toDisplayString as toDisplayString19, mergeProps as mergeProps27, createCommentVNode as createCommentVNode26 } from "vue";
import "D:/Desktop/forntend/Front_End_Web_Hotel_Nhom_2/my-nuxt-app/node_modules/vuestic-ui/dist/es/VaDatePickerHeader.css";
var _hoisted_130 = {
  key: 0,
  class: "va-date-picker-header va-date-picker__header"
};
var _hoisted_214 = { class: "va-date-picker__header__text" };
var _hoisted_39 = { class: "va-date-picker__header__month" };
var _sfc_main54 = defineComponent54({
  ...{
    name: "VaDatePickerHeader"
  },
  __name: "VaDatePickerHeader",
  props: {
    monthNames: { type: Array, required: true },
    view: { type: Object },
    color: { type: String },
    disabled: { type: Boolean, default: false },
    ariaNextPeriodLabel: useTranslationProp("$t:nextPeriod"),
    ariaPreviousPeriodLabel: useTranslationProp("$t:previousPeriod"),
    ariaSwitchViewLabel: useTranslationProp("$t:switchView")
  },
  emits: ["update:view"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const { syncView, prev, next } = useView(props, emit);
    const switchView = () => {
      if (syncView.value.type === "day") {
        syncView.value = { ...syncView.value, type: "month" };
      } else if (syncView.value.type === "month") {
        syncView.value = { ...syncView.value, type: "year" };
      }
    };
    const changeView = (view) => {
      syncView.value = view;
    };
    const currentColor = useElementTextColor(useElementBackground(useCurrentElement()));
    const { tp } = useTranslation();
    return (_ctx, _cache) => {
      return unref54(syncView).type !== "year" ? (openBlock51(), createElementBlock45("div", _hoisted_130, [
        renderSlot43(_ctx.$slots, "buttonPrev", normalizeProps20(guardReactiveProps16({ onClick: unref54(prev) })), () => [
          createVNode21(unref54(VaButton), {
            "va-child": "prevButton",
            disabled: _ctx.$props.disabled,
            icon: "va-arrow-left",
            preset: "plain",
            size: "small",
            color: __props.color,
            textColor: unref54(currentColor),
            "aria-label": unref54(tp)(_ctx.$props.ariaPreviousPeriodLabel),
            round: "",
            onClick: unref54(prev)
          }, null, 8, ["disabled", "color", "textColor", "aria-label", "onClick"])
        ]),
        createElementVNode23("div", _hoisted_214, [
          renderSlot43(_ctx.$slots, "header", normalizeProps20(guardReactiveProps16({ year: unref54(syncView).year, month: unref54(syncView).month, monthNames: __props.monthNames, view: unref54(syncView), changeView, switchView })), () => [
            createVNode21(unref54(VaButton), {
              "va-child": "middleButton",
              disabled: _ctx.$props.disabled,
              preset: "plain",
              size: "small",
              color: __props.color,
              textColor: unref54(currentColor),
              "aria-label": unref54(tp)(_ctx.$props.ariaSwitchViewLabel),
              onClick: switchView
            }, {
              default: withCtx25(() => [
                renderSlot43(_ctx.$slots, "year", normalizeProps20(guardReactiveProps16({ year: unref54(syncView).year })), () => [
                  createTextVNode15(toDisplayString19(unref54(syncView).year), 1)
                ]),
                unref54(syncView).type === "day" ? renderSlot43(_ctx.$slots, "month", normalizeProps20(mergeProps27({ key: 0 }, { month: unref54(syncView).month })), () => [
                  createElementVNode23("span", _hoisted_39, toDisplayString19(__props.monthNames[unref54(syncView).month]), 1)
                ]) : createCommentVNode26("", true)
              ]),
              _: 3
            }, 8, ["disabled", "color", "textColor", "aria-label"])
          ])
        ]),
        renderSlot43(_ctx.$slots, "buttonNext", normalizeProps20(guardReactiveProps16({ onClick: unref54(next) })), () => [
          createVNode21(unref54(VaButton), {
            "va-child": "nextButton",
            disabled: _ctx.$props.disabled,
            icon: "va-arrow-right",
            preset: "plain",
            size: "small",
            color: __props.color,
            textColor: unref54(currentColor),
            "aria-label": unref54(tp)(_ctx.$props.ariaNextPeriodLabel),
            onClick: unref54(next),
            round: ""
          }, null, 8, ["disabled", "color", "textColor", "aria-label", "onClick"])
        ])
      ])) : createCommentVNode26("", true);
    };
  }
});

// node_modules/vuestic-ui/dist/es/src/components/va-date-picker/components/VaMonthPicker/VaMonthPicker.vue_vue_type_script_setup_true_lang.js
import { defineComponent as defineComponent55, toRefs as toRefs5, computed as computed122, watch as watch36, openBlock as openBlock52, createElementBlock as createElementBlock46, mergeProps as mergeProps28, unref as unref55, Fragment as Fragment15, renderList as renderList11, createVNode as createVNode22, withCtx as withCtx26, renderSlot as renderSlot44, normalizeProps as normalizeProps21, guardReactiveProps as guardReactiveProps17, createTextVNode as createTextVNode16, toDisplayString as toDisplayString20 } from "vue";
import "D:/Desktop/forntend/Front_End_Web_Hotel_Nhom_2/my-nuxt-app/node_modules/vuestic-ui/dist/es/VaMonthPicker.css";
var _hoisted_131 = ["onMouseenter"];
var _sfc_main55 = defineComponent55({
  ...{
    name: "VaMonthPicker"
  },
  __name: "VaMonthPicker",
  props: {
    modelValue: { type: [Date, Array, Object] },
    monthNames: { type: Array, required: true },
    view: { type: Object, default: () => ({ type: "month" }) },
    allowedMonths: { type: Function, default: void 0 },
    highlightToday: { type: Boolean, default: true },
    mode: { type: String, default: "auto" },
    readonly: { type: Boolean, default: false },
    color: { type: String, default: "primary" }
  },
  emits: ["update:modelValue", "hover:month", "click:month"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const { view } = toRefs5(props);
    const months = computed122(() => Array.from(Array(12).keys()).map((month) => new Date(view.value.year, month)));
    const {
      hoveredIndex,
      onClick,
      isToday,
      isSelected,
      isInRange
    } = useDatePicker("month", months, props, emit);
    const isDisabled = (date) => props.allowedMonths === void 0 ? false : !props.allowedMonths(date);
    const {
      focusedCellIndex,
      containerAttributes
    } = useGridKeyboardNavigation({
      rowSize: 3,
      start: 0,
      end: months.value.length,
      onSelected: (selectedIndex) => onClick(months.value[selectedIndex])
    });
    watch36(focusedCellIndex, (index) => {
      hoveredIndex.value = index;
    });
    watch36(hoveredIndex, (index) => {
      focusedCellIndex.value = index;
    });
    return (_ctx, _cache) => {
      return openBlock52(), createElementBlock46("div", mergeProps28({ class: "va-month-picker" }, unref55(containerAttributes)), [
        (openBlock52(true), createElementBlock46(Fragment15, null, renderList11(months.value, (month, monthIndex) => {
          return openBlock52(), createElementBlock46("div", {
            key: monthIndex,
            class: "va-month-picker__month-wrapper",
            onMouseenter: ($event) => hoveredIndex.value = monthIndex,
            onMouseleave: _cache[0] || (_cache[0] = ($event) => hoveredIndex.value = -1)
          }, [
            createVNode22(_sfc_main52, {
              "in-range": !!unref55(isInRange)(month),
              selected: !!unref55(isSelected)(month),
              disabled: !!isDisabled(month),
              today: !!unref55(isToday)(month),
              focused: unref55(hoveredIndex) === monthIndex,
              "highlight-today": __props.highlightToday,
              readonly: _ctx.$props.readonly,
              color: __props.color,
              onClick: ($event) => {
                unref55(onClick)(month);
                focusedCellIndex.value = monthIndex;
              }
            }, {
              default: withCtx26(() => [
                renderSlot44(_ctx.$slots, "month", normalizeProps21(guardReactiveProps17({ monthIndex, month: __props.monthNames[monthIndex] })), () => [
                  createTextVNode16(toDisplayString20(__props.monthNames[monthIndex]), 1)
                ])
              ]),
              _: 2
            }, 1032, ["in-range", "selected", "disabled", "today", "focused", "highlight-today", "readonly", "color", "onClick"])
          ], 40, _hoisted_131);
        }), 128))
      ], 16);
    };
  }
});

// node_modules/vuestic-ui/dist/es/src/components/va-date-picker/components/VaYearPicker/VaYearPicker.vue_vue_type_script_setup_true_lang.js
import { defineComponent as defineComponent56, shallowRef as shallowRef18, toRefs as toRefs6, computed as computed123, onMounted as onMounted20, watch as watch37, openBlock as openBlock53, createElementBlock as createElementBlock47, mergeProps as mergeProps29, unref as unref56, withKeys as withKeys15, withModifiers as withModifiers12, Fragment as Fragment16, renderList as renderList12, createBlock as createBlock25, withCtx as withCtx27, createTextVNode as createTextVNode17, toDisplayString as toDisplayString21 } from "vue";
import "D:/Desktop/forntend/Front_End_Web_Hotel_Nhom_2/my-nuxt-app/node_modules/vuestic-ui/dist/es/VaYearPicker.css";
var _sfc_main56 = defineComponent56({
  ...{
    name: "VaYearPicker"
  },
  __name: "VaYearPicker",
  props: {
    modelValue: { type: [Date, Array, Object] },
    allowedYears: { type: Function, default: void 0 },
    highlightToday: { type: Boolean, default: true },
    startYear: { type: [Number, String], default: 1970 },
    mode: { type: String, default: "auto" },
    view: { type: Object, default: () => ({ type: "year" }) },
    endYear: { type: [Number, String], default: () => (/* @__PURE__ */ new Date()).getFullYear() + 50 },
    readonly: { type: Boolean, default: false },
    color: { type: String, default: "primary" }
  },
  emits: ["update:modelValue", "hover:year", "click:year"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const rootNode = shallowRef18();
    const { view } = toRefs6(props);
    const generateYearsArray = (start, end) => {
      const yearsCount = end - start + 1;
      return Array.from(Array(yearsCount).keys()).map((i) => createYearDate(start + i));
    };
    const startYearComputed = useNumericProp("startYear");
    const endYearComputed = useNumericProp("endYear");
    const years = computed123(() => generateYearsArray(startYearComputed.value, endYearComputed.value));
    const scrollIntoYearIndex = (index) => {
      if (!rootNode.value) {
        return;
      }
      const scrollHeight = rootNode.value.scrollHeight;
      const rootNodeHeight = rootNode.value.offsetHeight;
      const currentYearOffset = scrollHeight / years.value.length * index;
      const cellSize = scrollHeight / years.value.length;
      const relativeScrollPosition = currentYearOffset - rootNode.value.scrollTop;
      if (relativeScrollPosition < 0) {
        rootNode.value.scrollTo({ top: currentYearOffset });
      } else if (relativeScrollPosition > rootNodeHeight) {
        rootNode.value.scrollTo({ top: currentYearOffset - rootNodeHeight + cellSize });
      }
    };
    const scrollIntoYearIndexCenter = (index) => {
      if (!rootNode.value) {
        return;
      }
      const scrollHeight = rootNode.value.scrollHeight;
      const rootNodeHeight = rootNode.value.offsetHeight;
      const currentYearOffset = scrollHeight / years.value.length * index;
      rootNode.value.scrollTo({ top: currentYearOffset - rootNodeHeight / 2 });
    };
    onMounted20(() => {
      const currentYearIndex = years.value.findIndex((date) => date.getFullYear() === view.value.year);
      scrollIntoYearIndexCenter(currentYearIndex);
    });
    const {
      hoveredIndex,
      onClick,
      isToday,
      isSelected,
      isInRange
    } = useDatePicker("year", years, props, emit);
    const isYearDisabled = (year) => props.allowedYears === void 0 ? false : !props.allowedYears(year);
    const {
      focusedCellIndex,
      containerAttributes
    } = useGridKeyboardNavigation({
      rowSize: 1,
      start: 0,
      end: years.value.length,
      onFocusIndex: computed123(() => years.value.findIndex((date) => date.getFullYear() === view.value.year)),
      onSelected: (selectedIndex) => onClick(years.value[selectedIndex])
    });
    watch37(focusedCellIndex, (index) => index !== -1 && scrollIntoYearIndex(index));
    watch37(focusedCellIndex, (index) => {
      hoveredIndex.value = index;
    });
    watch37(hoveredIndex, (index) => {
      focusedCellIndex.value = index;
    });
    return (_ctx, _cache) => {
      return openBlock53(), createElementBlock47("div", mergeProps29({
        ref_key: "rootNode",
        ref: rootNode,
        class: "va-year-picker"
      }, unref56(containerAttributes), {
        onKeydown: _cache[1] || (_cache[1] = withKeys15(withModifiers12(() => {
        }, ["prevent"]), ["space"]))
      }), [
        (openBlock53(true), createElementBlock47(Fragment16, null, renderList12(years.value, (year, index) => {
          return openBlock53(), createBlock25(_sfc_main52, {
            key: year.toString(),
            "in-range": unref56(isInRange)(year),
            selected: unref56(isSelected)(year),
            disabled: isYearDisabled(year),
            today: unref56(isToday)(year),
            focused: unref56(focusedCellIndex) === index,
            "highlight-today": __props.highlightToday,
            readonly: _ctx.$props.readonly,
            color: __props.color,
            onClick: ($event) => {
              unref56(onClick)(year);
              focusedCellIndex.value = index;
            },
            onMouseenter: ($event) => hoveredIndex.value = index,
            onMouseleave: _cache[0] || (_cache[0] = ($event) => hoveredIndex.value = -1)
          }, {
            default: withCtx27(() => [
              createTextVNode17(toDisplayString21(year.getFullYear()), 1)
            ]),
            _: 2
          }, 1032, ["in-range", "selected", "disabled", "today", "focused", "highlight-today", "readonly", "color", "onClick", "onMouseenter"]);
        }), 128))
      ], 16);
    };
  }
});

// node_modules/vuestic-ui/dist/es/src/components/va-date-picker/VaDatePicker.vue_vue_type_script_setup_true_lang.js
import "D:/Desktop/forntend/Front_End_Web_Hotel_Nhom_2/my-nuxt-app/node_modules/vuestic-ui/dist/es/VaDatePicker.css";
var _hoisted_132 = { class: "va-date-picker__picker-wrapper" };
var DEFAULT_MONTH_NAMES = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
var DEFAULT_WEEKDAY_NAMES = ["SU", "MO", "TU", "WE", "TH", "FR", "SA"];
var _sfc_main57 = defineComponent57({
  ...{
    name: "VaDatePicker"
  },
  __name: "VaDatePicker",
  props: {
    ...defineChildProps({
      prevButton: VaButton,
      nextButton: VaButton,
      middleButton: VaButton
    }),
    ...useStatefulProps,
    ...useComponentPresetProp,
    ...extractComponentProps(_sfc_main54),
    ...extractComponentProps(_sfc_main53),
    ...extractComponentProps(_sfc_main55),
    ...extractComponentProps(_sfc_main56),
    modelValue: { type: [Date, Array, Object] },
    monthNames: { type: Array, default: DEFAULT_MONTH_NAMES },
    weekdayNames: { type: Array, default: DEFAULT_WEEKDAY_NAMES },
    view: { type: Object },
    type: { type: String, default: "day" },
    readonly: { type: Boolean, default: false },
    disabled: { type: Boolean, default: false },
    // Colors
    color: { type: String, default: void 0 },
    weekendsColor: { type: String, default: void 0 }
  },
  emits: [
    ...useStatefulEmits,
    ...extractComponentEmits(_sfc_main54),
    ...extractComponentEmits(_sfc_main56),
    ...extractComponentEmits(_sfc_main53),
    ...extractComponentEmits(_sfc_main55)
  ],
  setup(__props, { expose: __expose, emit: __emit }) {
    const props = __props;
    useChildComponents(props);
    const emit = __emit;
    const currentPicker = ref47();
    const { valueComputed } = useStateful(props, emit);
    const { syncView } = useView(props, emit, { type: props.type });
    const classComputed = computed124(() => ({
      "va-date-picker_without-week-days": props.hideWeekDays,
      "va-date-picker_disabled": props.disabled
    }));
    const onDayModelValueUpdate = (modelValue) => {
      if (props.readonly) {
        return;
      }
      if (props.type === "day") {
        valueComputed.value = modelValue;
      }
    };
    const onMonthClick = (date) => {
      emit("click:month", date);
      const year = date.getFullYear();
      const month = date.getMonth();
      if (props.type !== "month") {
        syncView.value = { type: "day", year, month };
      }
    };
    const onMonthModelValueUpdate = (modelValue) => {
      if (props.type === "month") {
        valueComputed.value = modelValue;
      }
    };
    const onYearClick = (date) => {
      emit("click:year", date);
      const year = date.getFullYear();
      if (props.type !== "year") {
        syncView.value = { type: "month", year, month: syncView.value.month };
      }
    };
    const onYearModelValueUpdate = (modelValue) => {
      if (props.type === "year") {
        valueComputed.value = modelValue;
      }
    };
    const { colorsToCSSVariable } = useColors();
    const styleComputed = computed124(() => ({
      ...colorsToCSSVariable({
        color: props.color,
        "weekends-color": props.weekendsColor
      }, "va-date-picker")
    }));
    const focusCurrentPicker = () => {
      var _a2;
      return (_a2 = currentPicker.value) == null ? void 0 : _a2.$el.focus();
    };
    watch38(syncView, (newValue, prevValue) => {
      if (newValue.type === prevValue.type) {
        return;
      }
      nextTick8(focusCurrentPicker);
    });
    const isPickerReadonly = (pickerName) => {
      return props.readonly && props.type === pickerName;
    };
    const dayPickerProps = filterComponentProps(extractComponentProps(_sfc_main53));
    const headerProps = filterComponentProps(extractComponentProps(_sfc_main54));
    const monthPickerProps = filterComponentProps(extractComponentProps(_sfc_main55));
    const yearPickerProps = filterComponentProps(extractComponentProps(_sfc_main56));
    __expose({
      focus: focusCurrentPicker,
      focusCurrentPicker
    });
    return (_ctx, _cache) => {
      return openBlock54(), createElementBlock48("div", {
        class: normalizeClass25(["va-date-picker", classComputed.value]),
        style: normalizeStyle29(styleComputed.value)
      }, [
        createVNode23(_sfc_main54, mergeProps30(unref57(headerProps), {
          view: unref57(syncView),
          "onUpdate:view": _cache[0] || (_cache[0] = ($event) => isRef7(syncView) ? syncView.value = $event : null)
        }), createSlots5({ _: 2 }, [
          renderList13(_ctx.$slots, (_, name) => {
            return {
              name,
              fn: withCtx28((bind) => [
                renderSlot45(_ctx.$slots, name, normalizeProps22(guardReactiveProps18(bind)))
              ])
            };
          })
        ]), 1040, ["view"]),
        createElementVNode24("div", _hoisted_132, [
          unref57(syncView).type === "day" ? (openBlock54(), createBlock26(_sfc_main53, mergeProps30({
            key: 0,
            ref_key: "currentPicker",
            ref: currentPicker
          }, unref57(dayPickerProps), {
            "model-value": unref57(valueComputed),
            view: unref57(syncView),
            readonly: _ctx.$props.disabled || isPickerReadonly("day"),
            "onUpdate:modelValue": onDayModelValueUpdate,
            "onHover:day": _cache[1] || (_cache[1] = (value) => _ctx.$emit("hover:day", value)),
            "onClick:day": _cache[2] || (_cache[2] = (value) => _ctx.$emit("click:day", value))
          }), createSlots5({ _: 2 }, [
            renderList13(_ctx.$slots, (_, name) => {
              return {
                name,
                fn: withCtx28((bind) => [
                  renderSlot45(_ctx.$slots, name, normalizeProps22(guardReactiveProps18(bind)))
                ])
              };
            })
          ]), 1040, ["model-value", "view", "readonly"])) : createCommentVNode27("", true),
          unref57(syncView).type === "month" ? (openBlock54(), createBlock26(_sfc_main55, mergeProps30({
            key: 1,
            ref_key: "currentPicker",
            ref: currentPicker
          }, unref57(monthPickerProps), {
            view: unref57(syncView),
            "model-value": unref57(valueComputed),
            readonly: _ctx.$props.disabled || isPickerReadonly("month"),
            "onUpdate:modelValue": onMonthModelValueUpdate,
            "onHover:month": _cache[3] || (_cache[3] = (value) => _ctx.$emit("hover:month", value)),
            "onClick:month": onMonthClick
          }), createSlots5({ _: 2 }, [
            renderList13(_ctx.$slots, (_, name) => {
              return {
                name,
                fn: withCtx28((bind) => [
                  renderSlot45(_ctx.$slots, name, normalizeProps22(guardReactiveProps18(bind)))
                ])
              };
            })
          ]), 1040, ["view", "model-value", "readonly"])) : createCommentVNode27("", true),
          unref57(syncView).type === "year" ? (openBlock54(), createBlock26(_sfc_main56, mergeProps30({
            key: 2,
            ref_key: "currentPicker",
            ref: currentPicker
          }, unref57(yearPickerProps), {
            view: unref57(syncView),
            "model-value": unref57(valueComputed),
            readonly: _ctx.$props.disabled || isPickerReadonly("year"),
            "onHover:year": _cache[4] || (_cache[4] = (value) => _ctx.$emit("hover:year", value)),
            "onUpdate:modelValue": onYearModelValueUpdate,
            "onClick:year": onYearClick
          }), createSlots5({ _: 2 }, [
            renderList13(_ctx.$slots, (_, name) => {
              return {
                name,
                fn: withCtx28((bind) => [
                  renderSlot45(_ctx.$slots, name, normalizeProps22(guardReactiveProps18(bind)))
                ])
              };
            })
          ]), 1040, ["view", "model-value", "readonly"])) : createCommentVNode27("", true)
        ])
      ], 6);
    };
  }
});

// node_modules/vuestic-ui/dist/es/src/composables/useDropdownable.js
import { computed as computed125, unref as unref58, watch as watch39 } from "vue";
var VaDropdownProps2 = extractComponentProps(
  VaDropdown,
  ["innerAnchorSelector", "stateful", "keyboardNavigation", "modelValue"]
);
var useDropdownableProps = {
  ...VaDropdownProps2,
  modelValue: {},
  /**
   * Close dropdown on value updated.
   * @default null - behavior controlled by component
   */
  closeOnChange: { type: Boolean, default: null },
  isOpen: { type: Boolean, default: void 0 }
};
var useDropdownableEmits = ["update:isOpen"];
var useDropdownable = function(props, emit, options = {}) {
  const [isOpenSync] = useSyncProp("isOpen", props, emit, false);
  const doWatch = computed125(() => props.closeOnChange !== null ? props.closeOnChange : unref58(options.defaultCloseOnValueUpdate || false));
  watch39(() => props.modelValue, () => {
    if (doWatch.value) {
      isOpenSync.value = false;
    }
  });
  return {
    dropdownProps: filterComponentProps(VaDropdownProps2),
    isOpenSync
  };
};

// node_modules/vuestic-ui/dist/es/src/components/va-date-input/VaDateInput.vue_vue_type_script_setup_true_lang.js
import "D:/Desktop/forntend/Front_End_Web_Hotel_Nhom_2/my-nuxt-app/node_modules/vuestic-ui/dist/es/VaDateInput.css";
var VaInputWrapperPropsDeclaration = extractComponentProps(VaInputWrapper, ["focused", "maxLength", "counterValue"]);
var VaDatePickerPropsDeclaration = extractComponentProps(_sfc_main57);
var _sfc_main58 = defineComponent58({
  ...{
    name: "VaDateInput"
  },
  __name: "VaDateInput",
  props: {
    ...useDropdownableProps,
    ...useClearableProps,
    ...VaInputWrapperPropsDeclaration,
    ...VaDatePickerPropsDeclaration,
    ...useValidationProps,
    ...useComponentPresetProp,
    clearValue: { type: void 0, default: void 0 },
    modelValue: { type: [Date, Array, Object, String, Number] },
    resetOnClose: { type: Boolean, default: true },
    closeOnContentClick: { type: Boolean, default: false },
    offset: { ...useDropdownableProps.offset, default: () => [2, 0] },
    format: { type: Function },
    formatDate: { type: Function, default: (d) => d.toLocaleDateString() },
    /** Force model value to string instead of date */
    formatValue: { type: Function },
    parse: { type: Function },
    parseDate: { type: Function },
    delimiter: { type: String, default: ", " },
    rangeDelimiter: { type: String, default: " ~ " },
    manualInput: { type: Boolean, default: false },
    color: { type: String, default: "primary" },
    leftIcon: { type: Boolean, default: false },
    icon: { type: String, default: "va-calendar" },
    ariaToggleDropdownLabel: useTranslationProp("$t:toggleDropdown"),
    ariaResetLabel: useTranslationProp("$t:resetDate"),
    ariaSelectedDateLabel: useTranslationProp("$t:selectedDate")
  },
  emits: [
    ...useFocusEmits,
    ...extractComponentEmits(_sfc_main57),
    ...useClearableEmits,
    ...useValidationEmits,
    ...useStatefulEmits,
    ...useDropdownableEmits,
    "update:text"
  ],
  setup(__props, { expose: __expose, emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const input = shallowRef19();
    const datePicker = ref48();
    const { resetOnClose } = toRefs7(props);
    const { trapFocusIn, freeFocus } = useTrapFocus();
    const trapFocus = () => {
      const el = unwrapEl(datePicker.value);
      if (!el) {
        freeFocus();
        return;
      }
      trapFocusIn(el);
    };
    watch40([datePicker], () => {
      trapFocus();
    });
    const { valueComputed: statefulValue } = useStateful(props, emit);
    const { isOpenSync, dropdownProps } = useDropdownable(props, emit, {
      defaultCloseOnValueUpdate: computed126(() => {
        if (Array.isArray(valueComputed.value)) {
          return false;
        }
        if (isRange3(valueComputed.value) && valueComputed.value.end === null) {
          return false;
        }
        return true;
      })
    });
    const isRangeModelValueGuardDisabled = computed126(() => !resetOnClose.value);
    const {
      valueComputed,
      reset: resetInvalidRange
    } = useRangeModelValueGuard(statefulValue, isRangeModelValueGuardDisabled);
    watch40(isOpenSync, (isOpened) => {
      if (!isOpened && !isRangeModelValueGuardDisabled.value) {
        resetInvalidRange();
      }
    });
    const { isFocused: isInputFocused, focus, blur, onFocus: focusListener, onBlur: blurListener } = useFocus(input);
    const isPickerFocused = useFocusDeep(datePicker);
    const dateOrNothing = (date) => date ? props.formatDate(date) : "...";
    const { parseDateInputValue, isValid } = useDateParser(props);
    watch40(valueComputed, () => {
      isValid.value = true;
    });
    const modelValueToString = (value) => {
      if (props.format) {
        return props.format(valueComputed.value);
      }
      if (isDates(value)) {
        return value.map((d) => props.formatDate(d)).join(props.delimiter);
      }
      if (isSingleDate2(value)) {
        return props.formatDate(value);
      }
      if (isRange3(value)) {
        return dateOrNothing(value.start) + props.rangeDelimiter + dateOrNothing(value.end);
      }
      if (value === null || value === void 0) {
        return "";
      }
      return "";
    };
    const {
      text,
      normalized: valueWithoutText
    } = useDateInputModelValue(valueComputed, toRef8(props, "mode"), parseDateInputValue, modelValueToString, props.formatValue);
    const valueText = computed126(() => {
      if (!isValid.value) {
        return "";
      }
      if (!valueComputed.value) {
        if (!props.clearValue) {
          return "";
        }
        return modelValueToString(props.clearValue);
      }
      return text.value;
    });
    const onInputTextChanged = ({ target }) => {
      if (props.disabled) {
        return;
      }
      const inputValue = target.value;
      if (isValid.value) {
        valueComputed.value = inputValue === "" ? props.clearValue : parseDateInputValue(inputValue);
      }
    };
    const reset = () => withoutValidation(() => {
      statefulValue.value = props.clearValue;
      emit("clear");
      resetValidation();
    });
    const hideAndFocus = () => {
      isOpenSync.value = false;
      focus();
    };
    const focusDatePicker = () => {
      nextTick9(() => {
        var _a2;
        return (_a2 = datePicker.value) == null ? void 0 : _a2.focusCurrentPicker();
      });
    };
    const focusInputOrPicker = () => {
      isOpenSync.value ? focusDatePicker() : focus();
    };
    const checkProhibitedDropdownOpening = (e) => {
      if (isOpenSync.value) {
        return false;
      }
      if (props.disabled || props.readonly) {
        return true;
      }
      if (e === void 0) {
        return false;
      }
      return props.manualInput && (e == null ? void 0 : e.code) !== "Space";
    };
    const toggleDropdown = (event) => {
      if (checkProhibitedDropdownOpening(event instanceof KeyboardEvent ? event : void 0)) {
        return;
      }
      isOpenSync.value = !isOpenSync.value;
      nextTick9(focusInputOrPicker);
    };
    const showDropdown = () => {
      if (props.disabled || props.readonly) {
        return;
      }
      isOpenSync.value = true;
      nextTick9(focusDatePicker);
    };
    const {
      isDirty,
      isTouched,
      computedError,
      computedErrorMessages,
      listeners,
      validationAriaAttributes,
      validate,
      withoutValidation,
      resetValidation
    } = useValidation(props, emit, { reset, focus, value: valueComputed });
    watch40(isOpenSync, (isOpen) => {
      if (!isOpen) {
        isTouched.value = true;
      }
    });
    const hasError = computed126(() => !isValid.value && valueComputed.value !== props.clearValue || computedError.value);
    const slots = useSlots7();
    const filterSlots = computed126(() => {
      const slotsWithIcons = [
        props.leftIcon && "prependInner",
        (!props.leftIcon || props.clearable) && "icon"
      ];
      return Object.keys(slots).filter((slot) => !slotsWithIcons.includes(slot));
    });
    const {
      canBeCleared,
      clearIconProps,
      onFocus,
      onBlur
    } = useClearable(props, valueComputed);
    const cursorStyleComputed = computed126(() => {
      if (props.disabled) {
        return {};
      }
      if (props.manualInput) {
        return { cursor: "text" };
      }
      return { cursor: "pointer" };
    });
    const iconTabindexComputed = computed126(() => {
      if (!props.manualInput) {
        return -1;
      }
      return props.disabled || props.readonly ? -1 : 0;
    });
    const iconProps = computed126(() => ({
      role: iconTabindexComputed.value === 0 ? "button" : "none",
      ariaHidden: iconTabindexComputed.value === -1,
      name: props.icon,
      color: "secondary",
      tabindex: iconTabindexComputed.value
    }));
    const filteredWrapperProps = filterComponentProps(VaInputWrapperPropsDeclaration);
    const computedInputWrapperProps = computed126(() => ({
      ...filteredWrapperProps.value,
      focused: isInputFocused.value || isPickerFocused.value,
      error: hasError.value,
      errorMessages: computedErrorMessages.value,
      readonly: props.readonly || !props.manualInput
    }));
    const computedInputListeners = computed126(() => ({
      focus: () => {
        if (props.disabled) {
          return;
        }
        focusListener();
        if (props.readonly) {
          return;
        }
        onFocus();
      },
      blur: () => {
        if (props.disabled) {
          return;
        }
        blurListener();
        if (props.readonly) {
          return;
        }
        onBlur();
        listeners.onBlur();
      }
    }));
    const { tp } = useTranslation();
    const attrs = useAttrs5();
    const inputAttributesComputed = computed126(() => ({
      readonly: props.readonly || !props.manualInput,
      disabled: props.disabled,
      tabindex: props.disabled ? -1 : 0,
      placeholder: props.placeholder,
      value: valueText.value,
      ariaLabel: props.label || tp(props.ariaSelectedDateLabel),
      ariaRequired: props.requiredMark,
      ariaDisabled: props.disabled,
      ariaReadOnly: props.readonly,
      ...validationAriaAttributes.value,
      ...omit(attrs, ["class", "style"])
    }));
    const dropdownPropsComputed = computed126(() => ({
      ...dropdownProps.value,
      stateful: false,
      innerAnchorSelector: ".va-input-wrapper__field",
      trigger: ["click", "right-click", "enter", "space"]
    }));
    const inputWrapperProps = computedInputWrapperProps;
    const inputListeners = computedInputListeners;
    const datePickerProps = filterComponentProps(VaDatePickerPropsDeclaration);
    __expose({
      valueText,
      valueWithoutText,
      valueDate: valueWithoutText,
      focus,
      blur,
      reset,
      validate,
      showDropdown,
      hideAndFocus,
      toggleDropdown,
      focusDatePicker,
      isDirty,
      isTouched
    });
    return (_ctx, _cache) => {
      return openBlock55(), createBlock27(unref59(VaDropdown), mergeProps31({
        modelValue: unref59(isOpenSync),
        "onUpdate:modelValue": _cache[9] || (_cache[9] = ($event) => isRef8(isOpenSync) ? isOpenSync.value = $event : null),
        class: ["va-date-input", _ctx.$attrs.class],
        style: _ctx.$attrs.style
      }, dropdownPropsComputed.value, {
        onOpen: focusDatePicker,
        role: "none"
      }), {
        anchor: withCtx29(() => [
          renderSlot46(_ctx.$slots, "input", normalizeProps23(guardReactiveProps19({ valueText: valueText.value, inputAttributes: inputAttributesComputed.value, inputWrapperProps: unref59(inputWrapperProps), inputListeners: unref59(inputListeners) })), () => [
            createVNode24(unref59(VaInputWrapper), mergeProps31({
              class: "va-date-input__anchor",
              style: cursorStyleComputed.value
            }, unref59(inputWrapperProps), toHandlers5(unref59(inputListeners)), {
              "model-value": valueText.value,
              onChange: onInputTextChanged
            }), createSlots6({
              icon: withCtx29(() => [
                unref59(canBeCleared) ? (openBlock55(), createBlock27(unref59(VaIcon), mergeProps31({
                  key: 0,
                  "aria-label": unref59(tp)(_ctx.$props.ariaResetLabel)
                }, { ...iconProps.value, ...unref59(clearIconProps) }, {
                  onClick: withModifiers13(reset, ["stop"]),
                  onKeydown: [
                    withKeys16(withModifiers13(reset, ["stop"]), ["enter"]),
                    withKeys16(withModifiers13(reset, ["stop"]), ["space"])
                  ]
                }), null, 16, ["aria-label", "onKeydown"])) : createCommentVNode28("", true),
                !_ctx.$props.leftIcon && _ctx.$props.icon ? (openBlock55(), createBlock27(unref59(VaIcon), mergeProps31({
                  key: 1,
                  "aria-label": unref59(tp)(_ctx.$props.ariaToggleDropdownLabel)
                }, iconProps.value), null, 16, ["aria-label"])) : createCommentVNode28("", true)
              ]),
              _: 2
            }, [
              renderList14(filterSlots.value, (name) => {
                return {
                  name,
                  fn: withCtx29((slotScope) => [
                    renderSlot46(_ctx.$slots, name, normalizeProps23(guardReactiveProps19(slotScope)))
                  ])
                };
              }),
              _ctx.$slots.prependInner || _ctx.$props.leftIcon ? {
                name: "prependInner",
                fn: withCtx29((slotScope) => [
                  renderSlot46(_ctx.$slots, "prependInner", normalizeProps23(guardReactiveProps19(slotScope))),
                  _ctx.$props.leftIcon ? (openBlock55(), createBlock27(unref59(VaIcon), mergeProps31({
                    key: 0,
                    "aria-label": unref59(tp)(_ctx.$props.ariaToggleDropdownLabel)
                  }, iconProps.value), null, 16, ["aria-label"])) : createCommentVNode28("", true)
                ]),
                key: "0"
              } : void 0
            ]), 1040, ["style", "model-value"])
          ])
        ]),
        default: withCtx29(() => [
          createVNode24(unref59(VaDropdownContent), {
            class: "va-date-input__dropdown-content",
            onKeydown: _cache[8] || (_cache[8] = withKeys16(($event) => unref59(focus)(), ["esc"])),
            role: "dialog"
          }, {
            default: withCtx29(() => [
              createVNode24(_sfc_main57, mergeProps31({
                ref_key: "datePicker",
                ref: datePicker
              }, unref59(datePickerProps), {
                modelValue: unref59(valueWithoutText),
                "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => isRef8(valueWithoutText) ? valueWithoutText.value = $event : null),
                "onClick:day": _cache[1] || (_cache[1] = ($event) => _ctx.$emit("click:day", $event)),
                "onClick:month": _cache[2] || (_cache[2] = ($event) => _ctx.$emit("click:month", $event)),
                "onClick:year": _cache[3] || (_cache[3] = ($event) => _ctx.$emit("click:year", $event)),
                "onHover:day": _cache[4] || (_cache[4] = ($event) => _ctx.$emit("hover:day", $event)),
                "onHover:month": _cache[5] || (_cache[5] = ($event) => _ctx.$emit("hover:month", $event)),
                "onHover:year": _cache[6] || (_cache[6] = ($event) => _ctx.$emit("hover:year", $event)),
                "onUpdate:view": _cache[7] || (_cache[7] = ($event) => {
                  _ctx.$nextTick(() => trapFocus());
                  _ctx.$emit("update:view", $event);
                })
              }), createSlots6({ _: 2 }, [
                renderList14(_ctx.$slots, (_, name) => {
                  return {
                    name,
                    fn: withCtx29((bind) => [
                      renderSlot46(_ctx.$slots, name, normalizeProps23(guardReactiveProps19(bind)))
                    ])
                  };
                })
              ]), 1040, ["modelValue"])
            ]),
            _: 3
          })
        ]),
        _: 3
      }, 16, ["modelValue", "class", "style"]);
    };
  }
});

// node_modules/vuestic-ui/dist/es/src/components/va-date-input/index.js
var VaDateInput = withConfigTransport$1(_sfc_main58);

// node_modules/vuestic-ui/dist/es/src/components/va-date-picker/index.js
var VaDatePicker = withConfigTransport$1(_sfc_main57);

// node_modules/vuestic-ui/dist/es/src/components/va-divider/VaDivider.vue_vue_type_script_setup_true_lang.js
import { defineComponent as defineComponent59, computed as computed127, useSlots as useSlots8, openBlock as openBlock56, createElementBlock as createElementBlock49, normalizeClass as normalizeClass26, normalizeStyle as normalizeStyle30, renderSlot as renderSlot47, createCommentVNode as createCommentVNode29 } from "vue";
import "D:/Desktop/forntend/Front_End_Web_Hotel_Nhom_2/my-nuxt-app/node_modules/vuestic-ui/dist/es/VaDivider.css";
var _hoisted_133 = ["aria-orientation"];
var _hoisted_215 = {
  key: 0,
  class: "va-divider__text"
};
var prefixClass = "va-divider";
var _sfc_main59 = defineComponent59({
  ...{
    name: "VaDivider"
  },
  __name: "VaDivider",
  props: {
    ...useComponentPresetProp,
    vertical: { type: Boolean, default: false },
    dashed: { type: Boolean, default: false },
    inset: { type: Boolean, default: false },
    orientation: {
      type: String,
      default: "center",
      validator: (value) => ["left", "right", "center"].includes(value)
    },
    color: { type: String, default: "backgroundBorder" }
  },
  setup(__props) {
    const props = __props;
    const { getColor } = useColors();
    const colorComputed = computed127(() => getColor(props.color));
    const slots = useSlots8();
    const hasSlot = computed127(() => !!slots.default);
    const classComputed = computed127(() => ({
      [`${prefixClass}--vertical`]: props.vertical,
      [`${prefixClass}--inset`]: props.inset,
      [`${prefixClass}--${props.orientation}`]: props.orientation && !props.vertical,
      [`${prefixClass}--dashed`]: props.dashed
    }));
    return (_ctx, _cache) => {
      return openBlock56(), createElementBlock49("div", {
        role: "separator",
        class: normalizeClass26(["va-divider", classComputed.value]),
        "aria-orientation": __props.vertical ? "vertical" : "horizontal",
        "aria-hidden": true,
        style: normalizeStyle30(`--va-color-computed: ${String(colorComputed.value)}`)
      }, [
        hasSlot.value && !__props.vertical ? (openBlock56(), createElementBlock49("div", _hoisted_215, [
          renderSlot47(_ctx.$slots, "default")
        ])) : createCommentVNode29("", true)
      ], 14, _hoisted_133);
    };
  }
});

// node_modules/vuestic-ui/dist/es/src/components/va-divider/index.js
var VaDivider = withConfigTransport$1(_sfc_main59);

// node_modules/vuestic-ui/dist/es/src/components/va-file-upload/VaFileUpload.vue_vue_type_script_setup_true_lang.js
import { defineComponent as defineComponent72, shallowRef as shallowRef20, ref as ref52, computed as computed138, onMounted as onMounted23, provide as provide5, toRef as toRef10, openBlock as openBlock69, createElementBlock as createElementBlock60, normalizeClass as normalizeClass36, unref as unref66, normalizeStyle as normalizeStyle36, renderSlot as renderSlot54, createElementVNode as createElementVNode31, toDisplayString as toDisplayString27, createCommentVNode as createCommentVNode35, createVNode as createVNode29, withCtx as withCtx36, createTextVNode as createTextVNode21, createBlock as createBlock33, mergeProps as mergeProps34 } from "vue";

// node_modules/vuestic-ui/dist/es/src/components/va-file-upload/types.js
var VaFileUploadKey = Symbol("VaFileUpload");

// node_modules/vuestic-ui/dist/es/src/components/va-file-upload/VaFileUploadList/VaFileUploadList.vue_vue_type_script_setup_true_lang.js
import { defineComponent as defineComponent71, computed as computed137, openBlock as openBlock68, createBlock as createBlock32, unref as unref65, normalizeClass as normalizeClass35, withCtx as withCtx35, createElementBlock as createElementBlock59, Fragment as Fragment19, renderList as renderList15, mergeProps as mergeProps33, createCommentVNode as createCommentVNode34 } from "vue";

// node_modules/vuestic-ui/dist/es/src/components/va-file-upload/VaFileUploadListItem/VaFileUploadListItem.vue_vue_type_script_setup_true_lang.js
import { defineComponent as defineComponent68, ref as ref50, openBlock as openBlock65, createBlock as createBlock29, unref as unref62, normalizeClass as normalizeClass33, withCtx as withCtx32, createVNode as createVNode26, createElementVNode as createElementVNode28, createElementBlock as createElementBlock57, toDisplayString as toDisplayString24, createCommentVNode as createCommentVNode31, withModifiers as withModifiers14, withKeys as withKeys17 } from "vue";

// node_modules/vuestic-ui/dist/es/src/components/va-list/VaList.vue_vue_type_script_setup_true_lang.js
import { defineComponent as defineComponent60, computed as computed128, openBlock as openBlock57, createElementBlock as createElementBlock50, normalizeClass as normalizeClass27, renderSlot as renderSlot48 } from "vue";
import "D:/Desktop/forntend/Front_End_Web_Hotel_Nhom_2/my-nuxt-app/node_modules/vuestic-ui/dist/es/VaList.css";
var _sfc_main60 = defineComponent60({
  ...{
    name: "VaList"
  },
  __name: "VaList",
  props: {
    ...useComponentPresetProp,
    fit: { type: Boolean, default: false }
  },
  setup(__props) {
    const props = __props;
    const computedClass = computed128(() => ({ "va-list--fit": props.fit }));
    return (_ctx, _cache) => {
      return openBlock57(), createElementBlock50("div", {
        class: normalizeClass27(["va-list", computedClass.value]),
        role: "list"
      }, [
        renderSlot48(_ctx.$slots, "default")
      ], 2);
    };
  }
});

// node_modules/vuestic-ui/dist/es/src/components/va-list/VaListItem.vue_vue_type_script_setup_true_lang.js
import { defineComponent as defineComponent61, computed as computed129, openBlock as openBlock58, createBlock as createBlock28, resolveDynamicComponent as resolveDynamicComponent6, unref as unref60, normalizeClass as normalizeClass28, withCtx as withCtx30, createElementVNode as createElementVNode25, renderSlot as renderSlot49 } from "vue";
import "D:/Desktop/forntend/Front_End_Web_Hotel_Nhom_2/my-nuxt-app/node_modules/vuestic-ui/dist/es/VaListItem.css";
var _sfc_main61 = defineComponent61({
  ...{
    name: "VaListItem"
  },
  __name: "VaListItem",
  props: {
    ...useRouterLinkProps,
    ...useComponentPresetProp,
    tag: { type: String, default: "div" },
    disabled: { type: Boolean, default: false }
  },
  emits: ["focus", "click"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const tabIndexComputed = computed129(() => props.disabled ? -1 : 0);
    const computedClass = useBem("va-list-item", () => ({
      ...pick(props, ["disabled"])
    }));
    const {
      tagComputed,
      hrefComputed
    } = useRouterLink(props);
    return (_ctx, _cache) => {
      return openBlock58(), createBlock28(resolveDynamicComponent6(unref60(tagComputed)), {
        class: normalizeClass28(["va-list-item", unref60(computedClass)]),
        role: "listitem",
        href: unref60(hrefComputed),
        target: _ctx.target,
        to: _ctx.to,
        replace: _ctx.replace,
        exact: _ctx.exact,
        "active-class": _ctx.activeClass,
        "exact-active-class": _ctx.exactActiveClass,
        tabindex: tabIndexComputed.value
      }, {
        default: withCtx30(() => [
          createElementVNode25("div", {
            class: "va-list-item__inner",
            onClick: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("click")),
            onFocus: _cache[1] || (_cache[1] = ($event) => _ctx.$emit("focus"))
          }, [
            renderSlot49(_ctx.$slots, "default")
          ], 32)
        ]),
        _: 3
      }, 8, ["href", "target", "to", "replace", "exact", "active-class", "exact-active-class", "class", "tabindex"]);
    };
  }
});

// node_modules/vuestic-ui/dist/es/src/components/va-list/VaListLabel.vue_vue_type_script_setup_true_lang.js
import { defineComponent as defineComponent62, computed as computed130, openBlock as openBlock59, createElementBlock as createElementBlock51, normalizeStyle as normalizeStyle31, renderSlot as renderSlot50 } from "vue";
import "D:/Desktop/forntend/Front_End_Web_Hotel_Nhom_2/my-nuxt-app/node_modules/vuestic-ui/dist/es/VaListLabel.css";
var _sfc_main62 = defineComponent62({
  ...{
    name: "VaListLabel"
  },
  __name: "VaListLabel",
  props: {
    ...useComponentPresetProp,
    color: { type: String, default: "primary" }
  },
  setup(__props) {
    const props = __props;
    const { getColor } = useColors();
    const computedStyle = computed130(() => ({
      color: getColor(props.color)
    }));
    return (_ctx, _cache) => {
      return openBlock59(), createElementBlock51("div", {
        class: "va-list-label",
        style: normalizeStyle31(computedStyle.value)
      }, [
        renderSlot50(_ctx.$slots, "default")
      ], 4);
    };
  }
});

// node_modules/vuestic-ui/dist/es/src/components/va-list/VaListItemLabel.vue_vue_type_script_setup_true_lang.js
import { defineComponent as defineComponent63, computed as computed131, openBlock as openBlock60, createElementBlock as createElementBlock52, normalizeClass as normalizeClass29, normalizeStyle as normalizeStyle32, renderSlot as renderSlot51 } from "vue";
import "D:/Desktop/forntend/Front_End_Web_Hotel_Nhom_2/my-nuxt-app/node_modules/vuestic-ui/dist/es/VaListItemLabel.css";
var _sfc_main63 = defineComponent63({
  ...{
    name: "VaListItemLabel"
  },
  __name: "VaListItemLabel",
  props: {
    ...useComponentPresetProp,
    caption: { type: Boolean, default: false },
    lines: { type: [Number, String], default: 1 }
  },
  setup(__props) {
    const props = __props;
    const linesComputed = useNumericProp("lines");
    const computedClass = computed131(() => ({ "va-list-item-label--caption": props.caption }));
    const computedStyle = computed131(() => ({ "-webkit-line-clamp": linesComputed.value }));
    return (_ctx, _cache) => {
      return openBlock60(), createElementBlock52("div", {
        class: normalizeClass29(["va-list-item-label", computedClass.value]),
        style: normalizeStyle32(computedStyle.value)
      }, [
        renderSlot51(_ctx.$slots, "default")
      ], 6);
    };
  }
});

// node_modules/vuestic-ui/dist/es/src/components/va-list/VaListItemSection.vue_vue_type_script_setup_true_lang.js
import { defineComponent as defineComponent64, computed as computed132, openBlock as openBlock61, createElementBlock as createElementBlock53, normalizeClass as normalizeClass30, renderSlot as renderSlot52 } from "vue";
import "D:/Desktop/forntend/Front_End_Web_Hotel_Nhom_2/my-nuxt-app/node_modules/vuestic-ui/dist/es/VaListItemSection.css";
var _sfc_main64 = defineComponent64({
  ...{
    name: "VaListItemSection"
  },
  __name: "VaListItemSection",
  props: {
    ...useComponentPresetProp,
    icon: { type: Boolean, default: false },
    avatar: { type: Boolean, default: false }
  },
  setup(__props) {
    const props = __props;
    const computedClass = computed132(() => ({
      "va-list-item-section--main": !props.icon && !props.avatar,
      "va-list-item-section--icon": props.icon,
      "va-list-item-section--avatar": props.avatar
    }));
    return (_ctx, _cache) => {
      return openBlock61(), createElementBlock53("div", {
        class: normalizeClass30(["va-list-item-section", computedClass.value])
      }, [
        renderSlot52(_ctx.$slots, "default")
      ], 2);
    };
  }
});

// node_modules/vuestic-ui/dist/es/src/components/va-list/VaListSeparator.vue_vue_type_script_setup_true_lang.js
import { defineComponent as defineComponent65, computed as computed133, openBlock as openBlock62, createElementBlock as createElementBlock54, normalizeClass as normalizeClass31 } from "vue";
import "D:/Desktop/forntend/Front_End_Web_Hotel_Nhom_2/my-nuxt-app/node_modules/vuestic-ui/dist/es/VaListSeparator.css";
var _sfc_main65 = defineComponent65({
  ...{
    name: "VaListSeparator"
  },
  __name: "VaListSeparator",
  props: {
    ...useComponentPresetProp,
    fit: { type: Boolean, default: false },
    spaced: { type: Boolean, default: false }
  },
  setup(__props) {
    const props = __props;
    const computedClass = computed133(() => ({
      "va-list-separator--offset": !props.fit,
      "va-list-separator--spaced": props.spaced
    }));
    return (_ctx, _cache) => {
      return openBlock62(), createElementBlock54("div", {
        "aria-hidden": "true",
        class: normalizeClass31(["va-list-separator", computedClass.value])
      }, null, 2);
    };
  }
});

// node_modules/vuestic-ui/dist/es/src/components/va-list/index.js
var VaListItem = withConfigTransport$1(_sfc_main61);
var VaListLabel = withConfigTransport$1(_sfc_main62);
var VaListItemLabel = withConfigTransport$1(_sfc_main63);
var VaListItemSection = withConfigTransport$1(_sfc_main64);
var VaListSeparator = withConfigTransport$1(_sfc_main65);
var VaList = withConfigTransport$1(_sfc_main60);

// node_modules/vuestic-ui/dist/es/src/components/va-file-upload/VaFileUploadUndo/VaFileUploadUndo.vue_vue_type_script_setup_true_lang.js
import { defineComponent as defineComponent67, ref as ref49, computed as computed135, onMounted as onMounted21, openBlock as openBlock64, createElementBlock as createElementBlock56, Fragment as Fragment18, createVNode as createVNode25, unref as unref61, normalizeStyle as normalizeStyle34, createElementVNode as createElementVNode27, normalizeClass as normalizeClass32, toDisplayString as toDisplayString23, withCtx as withCtx31, createTextVNode as createTextVNode19 } from "vue";

// node_modules/vuestic-ui/dist/es/src/components/va-progress-bar/VaProgressBar.vue_vue_type_script_setup_true_lang.js
import { defineComponent as defineComponent66, computed as computed134, openBlock as openBlock63, createElementBlock as createElementBlock55, mergeProps as mergeProps32, renderSlot as renderSlot53, normalizeProps as normalizeProps24, guardReactiveProps as guardReactiveProps20, Fragment as Fragment17, createTextVNode as createTextVNode18, toDisplayString as toDisplayString22, createCommentVNode as createCommentVNode30, createElementVNode as createElementVNode26, normalizeStyle as normalizeStyle33 } from "vue";
import "D:/Desktop/forntend/Front_End_Web_Hotel_Nhom_2/my-nuxt-app/node_modules/vuestic-ui/dist/es/VaProgressBar.css";
var _hoisted_134 = {
  key: 0,
  class: "va-progress-bar__info"
};
var _sfc_main66 = defineComponent66({
  ...{
    name: "VaProgressBar"
  },
  __name: "VaProgressBar",
  props: {
    ...useComponentPresetProp,
    modelValue: { type: [Number, String], default: 0 },
    indeterminate: { type: Boolean, default: false },
    color: { type: String, default: "primary" },
    size: {
      type: [Number, String],
      default: "medium"
    },
    buffer: { type: [Number, String], default: 100 },
    rounded: { type: Boolean, default: true },
    reverse: { type: Boolean, default: false },
    contentInside: { type: Boolean, default: false },
    showPercent: { type: Boolean, default: false },
    max: { type: [Number, String], default: 100 },
    ariaLabel: useTranslationProp("$t:progressState")
  },
  setup(__props) {
    const props = __props;
    const { getColor, getHoverColor: getHoverColor2 } = useColors();
    const colorComputed = computed134(() => getColor(props.color));
    const { textColorComputed } = useTextColor(colorComputed);
    const isTextSize = computed134(() => typeof props.size === "string" && ["small", "medium", "large"].includes(props.size));
    const getCSSHeight = () => {
      if (typeof props.size === "number") {
        return `${props.size}px`;
      }
      if (isTextSize.value) {
        return;
      }
      return props.size;
    };
    const { tp } = useTranslation();
    const progressBarValue = computed134(() => 100 / Number(props.max) * Number(props.modelValue));
    const rootClass = computed134(() => ({
      "va-progress-bar--square": !props.rounded,
      [`va-progress-bar--${props.size}`]: isTextSize.value
    }));
    const rooStyle = computed134(() => ({
      "--va-progress-bar-color": colorComputed.value,
      "--va-progress-bar-background-color": getHoverColor2(colorComputed.value)
    }));
    const wrapperStyle = computed134(() => ({
      height: getCSSHeight()
    }));
    const bufferStyle = computed134(() => ({
      width: `${props.indeterminate ? 100 : clamp(Number(props.buffer), 0, 100)}%`,
      color: textColorComputed.value,
      [props.reverse ? "right" : "left"]: 0
    }));
    const progressStyle = computed134(() => ({
      marginLeft: props.reverse ? "auto" : void 0,
      width: `${clamp(progressBarValue.value, 0, 100)}%`
    }));
    const intermediateStyle = computed134(() => ({
      animationDirection: props.reverse ? "reverse" : "normal"
    }));
    const ariaAttributesComputed = computed134(() => ({
      role: "progressbar",
      "aria-label": tp(props.ariaLabel),
      "aria-valuenow": !props.indeterminate ? props.modelValue : void 0
    }));
    return (_ctx, _cache) => {
      return openBlock63(), createElementBlock55("div", mergeProps32({
        class: ["va-progress-bar", rootClass.value],
        style: rooStyle.value
      }, ariaAttributesComputed.value), [
        !_ctx.$props.contentInside ? (openBlock63(), createElementBlock55("div", _hoisted_134, [
          renderSlot53(_ctx.$slots, "default", normalizeProps24(guardReactiveProps20({ value: _ctx.$props.modelValue })), () => [
            _ctx.$props.showPercent ? (openBlock63(), createElementBlock55(Fragment17, { key: 0 }, [
              createTextVNode18(toDisplayString22(_ctx.$props.modelValue) + "% ", 1)
            ], 64)) : createCommentVNode30("", true)
          ])
        ])) : createCommentVNode30("", true),
        createElementVNode26("div", {
          class: "va-progress-bar__wrapper",
          style: normalizeStyle33(wrapperStyle.value)
        }, [
          createElementVNode26("div", {
            class: "va-progress-bar__buffer",
            style: normalizeStyle33(bufferStyle.value)
          }, [
            _ctx.$props.contentInside ? renderSlot53(_ctx.$slots, "default", normalizeProps24(mergeProps32({ key: 0 }, { value: _ctx.$props.modelValue })), () => [
              _ctx.$props.showPercent ? (openBlock63(), createElementBlock55(Fragment17, { key: 0 }, [
                createTextVNode18(toDisplayString22(_ctx.$props.modelValue) + "% ", 1)
              ], 64)) : createCommentVNode30("", true)
            ]) : createCommentVNode30("", true)
          ], 4),
          __props.indeterminate ? (openBlock63(), createElementBlock55(Fragment17, { key: 0 }, [
            createElementVNode26("div", {
              class: "va-progress-bar__progress--indeterminate-start",
              style: normalizeStyle33(intermediateStyle.value)
            }, null, 4),
            createElementVNode26("div", {
              class: "va-progress-bar__progress--indeterminate-end",
              style: normalizeStyle33(intermediateStyle.value)
            }, null, 4)
          ], 64)) : (openBlock63(), createElementBlock55("div", {
            key: 1,
            class: "va-progress-bar__progress",
            style: normalizeStyle33(progressStyle.value)
          }, null, 4))
        ], 4)
      ], 16);
    };
  }
});

// node_modules/vuestic-ui/dist/es/src/components/va-progress-bar/index.js
var VaProgressBar = withConfigTransport$1(_sfc_main66);

// node_modules/vuestic-ui/dist/es/src/composables/useStrictInject.js
import { inject as inject7 } from "vue";
var useStrictInject = (injectionSymbol, errorMessage) => {
  const strictInjection = inject7(injectionSymbol);
  if (!strictInjection) {
    throw new Error(errorMessage);
  }
  return strictInjection;
};

// node_modules/vuestic-ui/dist/es/src/components/va-file-upload/VaFileUploadUndo/VaFileUploadUndo.vue_vue_type_script_setup_true_lang.js
import "D:/Desktop/forntend/Front_End_Web_Hotel_Nhom_2/my-nuxt-app/node_modules/vuestic-ui/dist/es/VaFileUploadUndo.css";
var _hoisted_135 = { class: "va-file-upload-undo__text" };
var INJECTION_ERROR_MESSAGE = "The VaFileUploadUndo component should be used in the context of VaFileUpload component";
var _sfc_main67 = defineComponent67({
  ...{
    name: "VaFileUploadUndo"
  },
  __name: "VaFileUploadUndo",
  props: {
    vertical: { type: Boolean, default: false }
  },
  emits: ["recover"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const progress = ref49(100);
    const {
      undoDuration,
      undoButtonText,
      deletedFileMessage
    } = useStrictInject(VaFileUploadKey, INJECTION_ERROR_MESSAGE);
    const computedClasses = useBem("va-file-upload-undo", () => ({
      vertical: props.vertical
    }));
    const undoDurationStyle = computed135(() => `${undoDuration.value ?? 0}ms`);
    onMounted21(() => {
      const timer = setTimeout(() => {
        progress.value = 0;
        clearTimeout(timer);
      }, 0);
    });
    return (_ctx, _cache) => {
      return openBlock64(), createElementBlock56(Fragment18, null, [
        createVNode25(unref61(VaProgressBar), {
          "model-value": progress.value,
          rounded: false,
          class: "va-file-upload-undo-progress-bar",
          style: normalizeStyle34(`--va-undo-duration-style: ${String(undoDurationStyle.value)}`)
        }, null, 8, ["model-value", "style"]),
        createElementVNode27("div", {
          class: normalizeClass32(["va-file-upload-undo", unref61(computedClasses)]),
          style: normalizeStyle34(`--va-undo-duration-style: ${String(undoDurationStyle.value)}`)
        }, [
          createElementVNode27("span", _hoisted_135, toDisplayString23(unref61(deletedFileMessage)), 1),
          createVNode25(unref61(VaButton), {
            class: "va-file-upload-undo__button",
            "aria-label": unref61(undoButtonText),
            size: "small",
            outline: "",
            onClick: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("recover"))
          }, {
            default: withCtx31(() => [
              createTextVNode19(toDisplayString23(unref61(undoButtonText)), 1)
            ]),
            _: 1
          }, 8, ["aria-label"])
        ], 6)
      ], 64);
    };
  }
});

// node_modules/vuestic-ui/dist/es/src/components/va-file-upload/VaFileUploadUndo/index.js
var VaFileUploadUndo = withConfigTransport$1(_sfc_main67);

// node_modules/vuestic-ui/dist/es/src/components/va-file-upload/VaFileUploadListItem/VaFileUploadListItem.vue_vue_type_script_setup_true_lang.js
import "D:/Desktop/forntend/Front_End_Web_Hotel_Nhom_2/my-nuxt-app/node_modules/vuestic-ui/dist/es/VaFileUploadListItem.css";
var _hoisted_136 = { class: "va-file-upload-list-item__content" };
var _hoisted_216 = {
  key: 0,
  class: "va-file-upload-list-item__name"
};
var _hoisted_310 = { class: "va-file-upload-list-item__size" };
var INJECTION_ERROR_MESSAGE2 = "The VaFileUploadListItem component should be used in the context of VaFileUpload component";
var _sfc_main68 = defineComponent68({
  ...{
    name: "VaFileUploadListItem"
  },
  __name: "VaFileUploadListItem",
  props: {
    file: { type: Object, default: null },
    color: { type: String, default: "success" },
    ariaRemoveFileLabel: useTranslationProp("$t:removeFile")
  },
  emits: ["remove"],
  setup(__props, { emit: __emit }) {
    const { tp } = useTranslation();
    const emit = __emit;
    const {
      undo,
      disabled,
      undoDuration
    } = useStrictInject(VaFileUploadKey, INJECTION_ERROR_MESSAGE2);
    const { onFocus, onBlur } = useFocus();
    const removed = ref50(false);
    const removeFile = () => {
      if (undo.value) {
        removed.value = true;
        setTimeout(() => {
          if (removed.value) {
            emit("remove");
            removed.value = false;
          }
        }, undoDuration.value ?? 0);
      } else {
        emit("remove");
        removed.value = false;
      }
    };
    const recoverFile = () => {
      removed.value = false;
    };
    const computedClasses = useBem("va-file-upload-list-item", () => ({
      undo: removed.value
    }));
    return (_ctx, _cache) => {
      return openBlock65(), createBlock29(unref62(VaListItem), {
        class: normalizeClass33(["va-file-upload-list-item", unref62(computedClasses)]),
        tabindex: "-1",
        disabled: unref62(disabled),
        "aria-disabled": unref62(disabled)
      }, {
        default: withCtx32(() => [
          removed.value && unref62(undo) ? (openBlock65(), createBlock29(unref62(VaListItemSection), { key: 0 }, {
            default: withCtx32(() => [
              createVNode26(unref62(VaFileUploadUndo), { onRecover: recoverFile })
            ]),
            _: 1
          })) : (openBlock65(), createBlock29(unref62(VaListItemSection), { key: 1 }, {
            default: withCtx32(() => [
              createElementVNode28("div", _hoisted_136, [
                __props.file && __props.file.name ? (openBlock65(), createElementBlock57("div", _hoisted_216, toDisplayString24(__props.file && __props.file.name), 1)) : createCommentVNode31("", true),
                createElementVNode28("div", _hoisted_310, toDisplayString24(__props.file && __props.file.size), 1),
                !unref62(disabled) ? (openBlock65(), createBlock29(unref62(VaButton), {
                  key: 1,
                  flat: "",
                  color: "danger",
                  icon: "clear",
                  class: "va-file-upload-list-item__delete",
                  "aria-label": unref62(tp)(_ctx.$props.ariaRemoveFileLabel),
                  onClick: withModifiers14(removeFile, ["stop"]),
                  onKeydown: [
                    withKeys17(withModifiers14(removeFile, ["stop"]), ["enter"]),
                    withKeys17(withModifiers14(removeFile, ["stop"]), ["space"])
                  ],
                  onFocus: unref62(onFocus),
                  onBlur: unref62(onBlur)
                }, null, 8, ["aria-label", "onKeydown", "onFocus", "onBlur"])) : createCommentVNode31("", true)
              ])
            ]),
            _: 1
          }))
        ]),
        _: 1
      }, 8, ["class", "disabled", "aria-disabled"]);
    };
  }
});

// node_modules/vuestic-ui/dist/es/src/components/va-file-upload/VaFileUploadListItem/index.js
var VaFileUploadListItem = withConfigTransport$1(_sfc_main68);

// node_modules/vuestic-ui/dist/es/src/components/va-file-upload/VaFileUploadGalleryItem/VaFileUploadGalleryItem.vue_vue_type_script_setup_true_lang.js
import { defineComponent as defineComponent69, ref as ref51, computed as computed136, onMounted as onMounted22, watch as watch41, toRef as toRef9, openBlock as openBlock66, createBlock as createBlock30, unref as unref63, normalizeClass as normalizeClass34, withCtx as withCtx33, createVNode as createVNode27, createElementBlock as createElementBlock58, createCommentVNode as createCommentVNode32, createElementVNode as createElementVNode29, normalizeStyle as normalizeStyle35, toDisplayString as toDisplayString25 } from "vue";
import "D:/Desktop/forntend/Front_End_Web_Hotel_Nhom_2/my-nuxt-app/node_modules/vuestic-ui/dist/es/VaFileUploadGalleryItem.css";
var _hoisted_137 = ["src", "alt"];
var _hoisted_217 = { class: "va-file-upload-gallery-item__overlay" };
var _hoisted_311 = ["title"];
var INJECTION_ERROR_MESSAGE3 = "The VaFileUploadGalleryItem component should be used in the context of VaFileUpload component";
var _sfc_main69 = defineComponent69({
  ...{
    name: "VaFileUploadGalleryItem"
  },
  __name: "VaFileUploadGalleryItem",
  props: {
    file: { type: Object, default: null },
    color: { type: String, default: "success" },
    ariaRemoveFileLabel: useTranslationProp("$t:removeFile")
  },
  emits: ["remove"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const {
      undo,
      disabled,
      undoDuration
    } = useStrictInject(VaFileUploadKey, INJECTION_ERROR_MESSAGE3);
    const { isFocused, onFocus, onBlur } = useFocus();
    const previewImage = ref51("");
    const removed = ref51(false);
    const overlayStylesComputed = computed136(() => ({
      backgroundColor: colorToRgba(props.color, 0.7)
    }));
    const classesComputed = useBem("va-file-upload-gallery-item", () => ({
      notImage: !previewImage.value,
      focused: isFocused.value,
      undo: removed.value
    }));
    const removeImage = () => {
      if (undo.value) {
        removed.value = true;
        setTimeout(() => {
          if (!removed.value) {
            return;
          }
          emit("remove");
          removed.value = false;
        }, undoDuration.value ?? 0);
      } else {
        emit("remove");
        removed.value = false;
      }
    };
    const recoverImage = () => {
      removed.value = false;
    };
    const convertToImg = () => {
      if (!props.file.name || !props.file.image) {
        return;
      }
      if (props.file.image.url) {
        previewImage.value = props.file.image.url;
      } else if (props.file.image instanceof File) {
        const reader = new FileReader();
        reader.readAsDataURL(props.file.image);
        reader.onload = (e) => {
          var _a2, _b;
          if (((_a2 = e.target) == null ? void 0 : _a2.result).includes("image")) {
            previewImage.value = (_b = e.target) == null ? void 0 : _b.result;
          }
        };
      }
    };
    onMounted22(convertToImg);
    watch41(() => props.file, convertToImg);
    const { t, tp } = useTranslation();
    const { textColorComputed } = useTextColor(toRef9(props, "color"));
    return (_ctx, _cache) => {
      return openBlock66(), createBlock30(unref63(VaListItem), {
        class: normalizeClass34(["va-file-upload-gallery-item", unref63(classesComputed)]),
        tabindex: "-1",
        disabled: unref63(disabled),
        "aria-disabled": unref63(disabled),
        onFocus: unref63(onFocus),
        onBlur: unref63(onBlur)
      }, {
        default: withCtx33(() => [
          removed.value && unref63(undo) ? (openBlock66(), createBlock30(unref63(VaListItemSection), { key: 0 }, {
            default: withCtx33(() => [
              createVNode27(unref63(VaFileUploadUndo), {
                vertical: "",
                onRecover: recoverImage
              })
            ]),
            _: 1
          })) : (openBlock66(), createBlock30(unref63(VaListItemSection), { key: 1 }, {
            default: withCtx33(() => [
              previewImage.value ? (openBlock66(), createElementBlock58("img", {
                key: 0,
                src: previewImage.value,
                alt: __props.file.name || "",
                class: "va-file-upload-gallery-item__image"
              }, null, 8, _hoisted_137)) : createCommentVNode32("", true),
              createElementVNode29("div", _hoisted_217, [
                createElementVNode29("div", {
                  class: "va-file-upload-gallery-item__overlay-background",
                  style: normalizeStyle35(overlayStylesComputed.value)
                }, null, 4),
                __props.file && __props.file.name ? (openBlock66(), createElementBlock58("div", {
                  key: 0,
                  class: "va-file-upload-gallery-item__name",
                  title: __props.file.name,
                  style: normalizeStyle35({ color: unref63(textColorComputed) })
                }, toDisplayString25(__props.file.name), 13, _hoisted_311)) : createCommentVNode32("", true),
                !unref63(disabled) ? (openBlock66(), createBlock30(unref63(VaButton), {
                  key: 1,
                  flat: "",
                  color: "danger",
                  icon: "va-delete",
                  class: "va-file-upload-gallery-item__delete",
                  "aria-label": unref63(tp)(_ctx.$props.ariaRemoveFileLabel),
                  onClick: removeImage,
                  onFocus: unref63(onFocus),
                  onBlur: unref63(onBlur)
                }, null, 8, ["aria-label", "onFocus", "onBlur"])) : createCommentVNode32("", true)
              ])
            ]),
            _: 1
          }))
        ]),
        _: 1
      }, 8, ["class", "disabled", "aria-disabled", "onFocus", "onBlur"]);
    };
  }
});

// node_modules/vuestic-ui/dist/es/src/components/va-file-upload/VaFileUploadGalleryItem/index.js
var VaFileUploadGalleryItem = withConfigTransport$1(_sfc_main69);

// node_modules/vuestic-ui/dist/es/src/components/va-file-upload/VaFileUploadSingleItem/VaFileUploadSingleItem.vue_vue_type_script_setup_true_lang.js
import { defineComponent as defineComponent70, openBlock as openBlock67, createBlock as createBlock31, unref as unref64, withCtx as withCtx34, createVNode as createVNode28, createElementVNode as createElementVNode30, toDisplayString as toDisplayString26, createTextVNode as createTextVNode20, createCommentVNode as createCommentVNode33 } from "vue";
import "D:/Desktop/forntend/Front_End_Web_Hotel_Nhom_2/my-nuxt-app/node_modules/vuestic-ui/dist/es/VaFileUploadSingleItem.css";
var _hoisted_138 = { class: "va-file-upload-single-item__name" };
var INJECTION_ERROR_MESSAGE4 = "The VaFileUploadSingleItem component should be used in the context of VaFileUpload component";
var _sfc_main70 = defineComponent70({
  ...{
    name: "VaFileUploadSingleItem"
  },
  __name: "VaFileUploadSingleItem",
  props: {
    file: { type: Object, default: null },
    ariaRemoveFileLabel: useTranslationProp("$t:removeFile")
  },
  emits: ["remove"],
  setup(__props, { emit: __emit }) {
    const { t, tp } = useTranslation();
    const { disabled } = useStrictInject(VaFileUploadKey, INJECTION_ERROR_MESSAGE4);
    return (_ctx, _cache) => {
      return openBlock67(), createBlock31(unref64(VaListItem), {
        disabled: unref64(disabled),
        "aria-disabled": unref64(disabled),
        class: "va-file-upload-single-item",
        tabindex: "-1"
      }, {
        default: withCtx34(() => [
          createVNode28(unref64(VaListItemSection), { class: "va-file-upload-single-item__content" }, {
            default: withCtx34(() => [
              createElementVNode30("div", _hoisted_138, toDisplayString26(__props.file && __props.file.name), 1),
              !unref64(disabled) ? (openBlock67(), createBlock31(unref64(VaButton), {
                key: 0,
                class: "va-file-upload-single-item__button",
                "aria-label": unref64(tp)(_ctx.$props.ariaRemoveFileLabel),
                size: "small",
                color: "danger",
                preset: "secondary",
                onClick: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("remove"))
              }, {
                default: withCtx34(() => [
                  createTextVNode20(" Delete ")
                ]),
                _: 1
              }, 8, ["aria-label"])) : createCommentVNode33("", true)
            ]),
            _: 1
          })
        ]),
        _: 1
      }, 8, ["disabled", "aria-disabled"]);
    };
  }
});

// node_modules/vuestic-ui/dist/es/src/components/va-file-upload/VaFileUploadSingleItem/index.js
var VaFileUploadSingleItem = withConfigTransport$1(_sfc_main70);

// node_modules/vuestic-ui/dist/es/src/components/va-file-upload/VaFileUploadList/VaFileUploadList.vue_vue_type_script_setup_true_lang.js
import "D:/Desktop/forntend/Front_End_Web_Hotel_Nhom_2/my-nuxt-app/node_modules/vuestic-ui/dist/es/VaFileUploadList.css";
var VaFileUploadGalleryItemProps = extractComponentProps(VaFileUploadGalleryItem);
var VaFileUploadListItemProps = extractComponentProps(VaFileUploadListItem);
var VaFileUploadSingleItemProps = extractComponentProps(VaFileUploadSingleItem);
var _sfc_main71 = defineComponent71({
  ...{
    name: "VaFileUploadList"
  },
  __name: "VaFileUploadList",
  props: {
    type: { type: String, default: "" },
    files: { type: Array, default: null },
    ...VaFileUploadGalleryItemProps,
    ...VaFileUploadListItemProps,
    ...VaFileUploadSingleItemProps
  },
  emits: ["remove", "removeSingle"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const filesList = computed137(() => props.files.map(convertFile));
    const convertFile = (file) => ({
      name: file.name || file.url || "",
      size: formatSize(file.size),
      date: formatDate(/* @__PURE__ */ new Date()),
      image: file
    });
    const formatSize = (bytes) => {
      if (bytes === 0) {
        return "0 Bytes";
      }
      if (!bytes) {
        return "";
      }
      const k = 1024;
      const sizes = ["Bytes", "KB", "MB", "GB", "TB", "PB", "EB", "ZB", "YB"];
      const i = Math.floor(Math.log(bytes) / Math.log(k));
      return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + " " + sizes[i];
    };
    const formatDate = (date = /* @__PURE__ */ new Date()) => {
      return date.toLocaleDateString("en-US", {
        hour: "2-digit",
        minute: "2-digit",
        month: "short",
        day: "numeric",
        year: "numeric"
      });
    };
    const galleryItemProps = filterComponentProps(VaFileUploadGalleryItemProps);
    const itemProps = filterComponentProps(VaFileUploadListItemProps);
    const singleItemProps = filterComponentProps(VaFileUploadSingleItemProps);
    return (_ctx, _cache) => {
      return openBlock68(), createBlock32(unref65(VaList), {
        class: normalizeClass35(["va-file-upload-list", `va-file-upload-list--${__props.type}`]),
        role: __props.type !== "single" ? "list" : void 0
      }, {
        default: withCtx35(() => [
          __props.type === "list" ? (openBlock68(true), createElementBlock59(Fragment19, { key: 0 }, renderList15(filesList.value, (file, index) => {
            return openBlock68(), createBlock32(unref65(VaFileUploadListItem), mergeProps33({
              key: file.name
            }, unref65(itemProps), {
              file,
              role: "listitem",
              onRemove: ($event) => _ctx.$emit("remove", index)
            }), null, 16, ["file", "onRemove"]);
          }), 128)) : createCommentVNode34("", true),
          __props.type === "gallery" ? (openBlock68(true), createElementBlock59(Fragment19, { key: 1 }, renderList15(filesList.value, (file, index) => {
            return openBlock68(), createBlock32(unref65(VaFileUploadGalleryItem), mergeProps33(unref65(galleryItemProps), {
              key: file.name,
              file,
              role: "listitem",
              onRemove: ($event) => _ctx.$emit("remove", index)
            }), null, 16, ["file", "onRemove"]);
          }), 128)) : createCommentVNode34("", true),
          __props.type === "single" && filesList.value.length ? (openBlock68(), createBlock32(unref65(VaFileUploadSingleItem), mergeProps33({ key: 2 }, unref65(singleItemProps), {
            file: filesList.value[filesList.value.length - 1],
            onRemove: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("removeSingle"))
          }), null, 16, ["file"])) : createCommentVNode34("", true)
        ]),
        _: 1
      }, 8, ["role", "class"]);
    };
  }
});

// node_modules/vuestic-ui/dist/es/src/components/va-file-upload/VaFileUploadList/index.js
var VaFileUploadList = withConfigTransport$1(_sfc_main71);

// node_modules/vuestic-ui/dist/es/src/components/va-file-upload/VaFileUpload.vue_vue_type_script_setup_true_lang.js
import "D:/Desktop/forntend/Front_End_Web_Hotel_Nhom_2/my-nuxt-app/node_modules/vuestic-ui/dist/es/VaFileUpload.css";
var _hoisted_139 = { class: "va-file-upload__field" };
var _hoisted_218 = {
  key: 0,
  class: "va-file-upload__field__text"
};
var _hoisted_312 = ["accept", "multiple", "disabled"];
var VaFileUploadListProps = extractComponentProps(VaFileUploadList);
var _sfc_main72 = defineComponent72({
  ...{
    name: "VaFileUpload"
  },
  __name: "VaFileUpload",
  props: {
    ...useComponentPresetProp,
    ...VaFileUploadListProps,
    fileTypes: { type: String, default: "" },
    dropzone: { type: Boolean, default: false },
    hideFileList: { type: Boolean, default: false },
    color: { type: String, default: "primary" },
    disabled: { type: Boolean, default: false },
    undo: { type: Boolean, default: false },
    undoDuration: { type: [Number, String], default: 3e3 },
    undoButtonText: useTranslationProp("$t:undo"),
    dropZoneText: useTranslationProp("$t:dropzone"),
    uploadButtonText: useTranslationProp("$t:uploadFile"),
    deletedFileMessage: useTranslationProp("$t:fileDeleted"),
    fileIncorrectMessage: useTranslationProp("$t:fileTypeIncorrect"),
    modelValue: {
      type: [Object, Array],
      default: () => []
    },
    type: {
      type: String,
      default: "list",
      validator: (value) => ["list", "gallery", "single"].includes(value)
    }
  },
  emits: ["update:modelValue", "file-removed", "file-added"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const fileInputRef = shallowRef20();
    const modal = ref52(false);
    const dropzoneHighlight = ref52(false);
    const { getColor, shiftHSLAColor: shiftHSLAColor2 } = useColors();
    const colorComputed = computed138(() => getColor(props.color));
    const computedStyle = computed138(() => ({
      backgroundColor: props.dropzone ? shiftHSLAColor2(colorComputed.value, { a: dropzoneHighlight.value ? -0.82 : -0.92 }) : "transparent"
    }));
    const computedClasses = useBem("va-file-upload", () => ({
      dropzone: props.dropzone,
      disabled: props.disabled
    }));
    const files = computed138({
      get() {
        return Array.isArray(props.modelValue) ? props.modelValue : [props.modelValue];
      },
      set(files2) {
        if (props.type === "single") {
          emit("update:modelValue", files2[0]);
        } else {
          emit("update:modelValue", files2);
        }
      }
    });
    const filterInvalidFiles = (files2) => files2.filter((file) => {
      const fileName = file.name || file.url;
      if (!fileName) {
        return false;
      }
      if (file.url) {
        return true;
      }
      const MIMETypes = ["audio/*", "video/*", "image/*"];
      const isContainedMIMEType = MIMETypes.find((t) => props.fileTypes.includes(t));
      if (isContainedMIMEType) {
        return true;
      }
      const extension = fileName.substring(fileName.lastIndexOf(".") + 1).toLowerCase();
      const isCorrectExt = props.fileTypes.includes(extension);
      if (!isCorrectExt) {
        modal.value = true;
      }
      return isCorrectExt;
    });
    const uploadFile = (e) => {
      var _a2, _b;
      const f = ((_a2 = e.target) == null ? void 0 : _a2.files) || ((_b = e.dataTransfer) == null ? void 0 : _b.files);
      if (!f) {
        return;
      }
      const validatedFiles = props.fileTypes ? filterInvalidFiles(Array.from(f)) : f;
      files.value = props.type === "single" ? validatedFiles : [...files.value, ...validatedFiles];
      emit("file-added", validatedFiles);
    };
    const changeFieldValue = (e) => {
      uploadFile(e);
      if (fileInputRef.value) {
        fileInputRef.value.value = "";
      }
    };
    const removeFile = (index) => {
      if (index in files.value) {
        const removedFile = files.value[index];
        files.value = files.value.filter((item, idx) => idx !== index);
        emit("file-removed", removedFile);
      }
    };
    const removeSingleFile = () => {
      if (files.value.length > 0) {
        const removedFile = files.value[0];
        files.value = [];
        emit("file-removed", removedFile);
      }
    };
    const callFileDialogue = () => {
      if (fileInputRef.value) {
        fileInputRef.value.click();
      }
    };
    onMounted23(() => {
      if (Array.isArray(files.value)) {
        const filteredFiles = filterInvalidFiles(files.value);
        if (filteredFiles.length !== files.value.length) {
          files.value = filteredFiles;
        }
      }
    });
    const { tp } = useTranslation();
    provide5(VaFileUploadKey, {
      undo: toRef10(props, "undo"),
      disabled: toRef10(props, "disabled"),
      undoDuration: useNumericProp("undoDuration"),
      undoButtonText: computed138(() => tp(props.undoButtonText)),
      deletedFileMessage: computed138(() => tp(props.deletedFileMessage))
    });
    const fileUploadListProps = filterComponentProps(VaFileUploadListProps);
    return (_ctx, _cache) => {
      return openBlock69(), createElementBlock60("div", {
        class: normalizeClass36(["va-file-upload", unref66(computedClasses)]),
        style: normalizeStyle36(computedStyle.value)
      }, [
        renderSlot54(_ctx.$slots, "default", {}, () => [
          createElementVNode31("div", _hoisted_139, [
            __props.dropzone ? (openBlock69(), createElementBlock60("div", _hoisted_218, toDisplayString27(unref66(tp)(__props.dropZoneText)), 1)) : createCommentVNode35("", true),
            createVNode29(unref66(VaButton), {
              class: "va-file-upload__field__button",
              disabled: __props.disabled,
              "aria-disabled": __props.disabled,
              color: colorComputed.value,
              style: normalizeStyle36({ "pointer-events": dropzoneHighlight.value ? "none" : void 0 }),
              onChange: changeFieldValue,
              onClick: callFileDialogue
            }, {
              default: withCtx36(() => [
                createTextVNode21(toDisplayString27(unref66(tp)(__props.uploadButtonText)), 1)
              ]),
              _: 1
            }, 8, ["disabled", "aria-disabled", "color", "style"])
          ])
        ]),
        createElementVNode31("input", {
          ref_key: "fileInputRef",
          ref: fileInputRef,
          type: "file",
          class: "va-file-upload__field__input",
          tabindex: -1,
          "aria-hidden": "true",
          accept: __props.fileTypes,
          multiple: __props.type !== "single",
          disabled: __props.disabled,
          onChange: changeFieldValue,
          onDragenter: _cache[0] || (_cache[0] = ($event) => dropzoneHighlight.value = true),
          onDragleave: _cache[1] || (_cache[1] = ($event) => dropzoneHighlight.value = false)
        }, null, 40, _hoisted_312),
        files.value.length && !_ctx.$props.hideFileList ? (openBlock69(), createBlock33(unref66(VaFileUploadList), mergeProps34({ key: 0 }, unref66(fileUploadListProps), {
          type: __props.type,
          files: files.value,
          color: colorComputed.value,
          onRemove: removeFile,
          onRemoveSingle: removeSingleFile
        }), null, 16, ["type", "files", "color"])) : createCommentVNode35("", true),
        createVNode29(unref66(VaModal), {
          modelValue: modal.value,
          "onUpdate:modelValue": _cache[2] || (_cache[2] = ($event) => modal.value = $event),
          "hide-default-actions": "",
          message: unref66(tp)("$t:fileTypeIncorrect")
        }, null, 8, ["modelValue", "message"])
      ], 6);
    };
  }
});

// node_modules/vuestic-ui/dist/es/src/components/va-file-upload/index.js
var VaFileUpload = withConfigTransport$1(_sfc_main72);

// node_modules/vuestic-ui/dist/es/src/components/va-form/VaForm.vue_vue_type_script_setup_true_lang.js
import { defineComponent as defineComponent73, watch as watch42, onMounted as onMounted24, computed as computed141, openBlock as openBlock70, createBlock as createBlock34, resolveDynamicComponent as resolveDynamicComponent7, mergeProps as mergeProps35, withCtx as withCtx37, renderSlot as renderSlot55, normalizeProps as normalizeProps25, guardReactiveProps as guardReactiveProps21, unref as unref68 } from "vue";

// node_modules/vuestic-ui/dist/es/src/composables/useForm/useFormParent.js
import { provide as provide6, computed as computed140, unref as unref67, toRef as toRef11 } from "vue";

// node_modules/vuestic-ui/dist/es/src/composables/useForm/formContext.js
import { ref as ref53, computed as computed139 } from "vue";
var createFormContext = (options) => {
  const fields = ref53(/* @__PURE__ */ new Map());
  return {
    // Vue unwrap ref automatically, but types are not for some reason
    immediate: computed139(() => options.immediate),
    fields: computed139(() => [...fields.value.values()]),
    forceHideErrors: computed139(() => options.hideErrors),
    forceHideErrorMessages: computed139(() => options.hideErrorMessages),
    forceHideLoading: computed139(() => options.hideLoading),
    forceDirty: ref53(false),
    registerField: (uid, field) => {
      fields.value.set(uid, field);
    },
    unregisterField: (uid) => {
      fields.value.delete(uid);
    }
  };
};

// node_modules/vuestic-ui/dist/es/src/composables/useForm/useFormParent.js
var useFormParent = (options) => {
  const formContext = createFormContext(options);
  provide6(FormServiceKey, formContext);
  const { fields, forceDirty } = formContext;
  const fieldNames = computed140(() => fields.value.map((field) => unref67(field.name)).filter(Boolean));
  const fieldsNamed = computed140(() => fields.value.reduce((acc, field) => {
    if (unref67(field.name)) {
      acc[unref67(field.name)] = field;
    }
    return acc;
  }, {}));
  const formData = computed140(() => fields.value.reduce((acc, field) => {
    if (unref67(field.name)) {
      acc[unref67(field.name)] = unref67(field.value);
    }
    return acc;
  }, {}));
  const isValid = computed140(() => fields.value.every((field) => unref67(field.isValid)));
  const isLoading = computed140(() => fields.value.some((field) => unref67(field.isLoading)));
  const errorMessages = computed140(() => fields.value.map((field) => unref67(field.errorMessages)).flat());
  const errorMessagesNamed = computed140(() => fields.value.reduce((acc, field) => {
    if (unref67(field.name)) {
      acc[unref67(field.name)] = unref67(field.errorMessages);
    }
    return acc;
  }, {}));
  const isDirty = computed140({
    get() {
      return fields.value.some((field) => unref67(field.isDirty)) || forceDirty.value;
    },
    set(v) {
      forceDirty.value = v;
      fields.value.forEach((field) => {
        field.isDirty = v;
      });
    }
  });
  const isTouched = computed140({
    get() {
      return fields.value.some((field) => field.isTouched);
    },
    set(v) {
      fields.value.forEach((field) => {
        field.isTouched = v;
      });
    }
  });
  const validate = () => {
    isDirty.value = true;
    return fields.value.reduce((acc, field) => {
      return field.validate() && acc;
    }, true);
  };
  const validateAsync = () => {
    isDirty.value = true;
    return Promise.all(fields.value.map((field) => field.validateAsync())).then((results) => {
      return results.every(Boolean);
    });
  };
  const reset = () => {
    isDirty.value = false;
    fields.value.forEach((field) => field.reset());
  };
  const resetValidation = () => {
    isDirty.value = false;
    fields.value.forEach((field) => field.resetValidation());
  };
  const focus = () => {
    var _a2;
    (_a2 = fields.value[0]) == null ? void 0 : _a2.focus();
  };
  const focusInvalidField = () => {
    const invalidField = fields.value.find((field) => !field.isValid);
    invalidField == null ? void 0 : invalidField.focus();
  };
  useFormChild({
    name: toRef11(options, "name"),
    isValid,
    isLoading,
    isDirty,
    isTouched,
    validate,
    validateAsync,
    reset,
    resetValidation,
    focus,
    errorMessages
  });
  return {
    immediate: computed140(() => options.immediate),
    isDirty,
    isTouched,
    formData,
    fields,
    fieldsNamed,
    fieldNames,
    isValid,
    isLoading,
    errorMessages,
    errorMessagesNamed,
    validate,
    validateAsync,
    reset,
    resetValidation,
    focus,
    focusInvalidField
  };
};

// node_modules/vuestic-ui/dist/es/src/components/va-form/VaForm.vue_vue_type_script_setup_true_lang.js
import "D:/Desktop/forntend/Front_End_Web_Hotel_Nhom_2/my-nuxt-app/node_modules/vuestic-ui/dist/es/VaForm.css";
var statefulProps = { stateful: true };
var statefulConfig = {
  VaInput: statefulProps,
  VaSelect: statefulProps,
  VaCheckbox: statefulProps,
  VaRadio: statefulProps,
  VaDatePicker: statefulProps,
  VaTimePicker: statefulProps,
  VaColorPicker: statefulProps,
  VaSlider: statefulProps,
  VaSwitch: statefulProps,
  VaFileUpload: statefulProps,
  VaRating: statefulProps,
  VaDateInput: statefulProps,
  VaTimeInput: statefulProps
};
var _sfc_main73 = defineComponent73({
  ...{
    name: "VaForm"
  },
  __name: "VaForm",
  props: {
    ...useComponentPresetProp,
    autofocus: { type: Boolean, default: false },
    immediate: { type: Boolean, default: false },
    tag: { type: String, default: "form" },
    trigger: { type: String, default: "blur" },
    modelValue: { type: Boolean, default: true },
    hideErrors: { type: Boolean, default: false },
    hideErrorMessages: { type: Boolean, default: false },
    hideLoading: { type: Boolean, default: false },
    stateful: { type: Boolean, default: false },
    name: { type: String, default: void 0 }
  },
  emits: ["update:modelValue"],
  setup(__props, { expose: __expose, emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const context = useFormParent(props);
    watch42(context.isValid, (value) => {
      emit("update:modelValue", value);
    });
    watch42(() => props.autofocus, (value) => {
      if (value) {
        context.focus();
      }
    });
    onMounted24(() => {
      if (props.autofocus) {
        context.focus();
      }
    });
    watch42(context.fields, (newVal) => {
      if (newVal.length && props.immediate) {
        context.validate();
      }
    }, { immediate: true });
    useLocalConfigProvider(computed141(() => {
      if (!props.stateful) {
        return {};
      }
      return statefulConfig;
    }));
    const {
      immediate: immediateComputed,
      isDirty,
      isTouched,
      formData,
      fields,
      fieldsNamed,
      fieldNames,
      isValid,
      isLoading,
      errorMessages,
      errorMessagesNamed,
      validate,
      validateAsync,
      reset,
      resetValidation,
      focus,
      focusInvalidField
    } = context;
    __expose({
      immediate: immediateComputed,
      isDirty,
      formData,
      fields,
      fieldsNamed,
      fieldNames,
      isValid,
      isTouched,
      isLoading,
      errorMessages,
      errorMessagesNamed,
      validate,
      validateAsync,
      reset,
      resetValidation,
      focus,
      focusInvalidField
    });
    return (_ctx, _cache) => {
      return openBlock70(), createBlock34(resolveDynamicComponent7(__props.tag), mergeProps35({
        class: "va-form",
        onSubmit: _cache[0] || (_cache[0] = (e) => _ctx.$attrs.action === void 0 && e.preventDefault())
      }, _ctx.$attrs), {
        default: withCtx37(() => [
          renderSlot55(_ctx.$slots, "default", normalizeProps25(guardReactiveProps21({
            isValid: unref68(isValid),
            isDirty: unref68(isDirty),
            isTouched: unref68(isTouched),
            isLoading: unref68(isLoading),
            errorMessages: unref68(errorMessages),
            errorMessagesNamed: unref68(errorMessagesNamed),
            formData: unref68(formData),
            fields: unref68(fields),
            fieldsNamed: unref68(fieldsNamed),
            fieldNames: unref68(fieldNames),
            validate: unref68(validate),
            validateAsync: unref68(validateAsync),
            reset: unref68(reset),
            resetValidation: unref68(resetValidation),
            focus: unref68(focus),
            focusInvalidField: unref68(focusInvalidField)
          })))
        ]),
        _: 3
      }, 16);
    };
  }
});

// node_modules/vuestic-ui/dist/es/src/components/va-form/index.js
var VaForm = withConfigTransport$1(_sfc_main73);

// node_modules/vuestic-ui/dist/es/src/components/va-infinite-scroll/VaInfiniteScroll.vue_vue_type_script_setup_true_lang.js
import { defineComponent as defineComponent74, shallowRef as shallowRef21, ref as ref54, computed as computed142, watch as watch43, openBlock as openBlock71, createBlock as createBlock35, resolveDynamicComponent as resolveDynamicComponent8, normalizeClass as normalizeClass37, withCtx as withCtx38, renderSlot as renderSlot56, createElementVNode as createElementVNode32, createVNode as createVNode30, unref as unref69, createCommentVNode as createCommentVNode36 } from "vue";

// node_modules/vuestic-ui/dist/es/src/utils/sleep.js
var sleep = (ms = 0) => {
  return new Promise((resolve) => setTimeout(resolve, ms));
};

// node_modules/vuestic-ui/dist/es/src/components/va-infinite-scroll/hooks/useScroll.js
import { onMounted as onMounted25, onBeforeUnmount as onBeforeUnmount18 } from "vue";
var useScroll = (props, element, handler) => {
  const addScrollListener = () => {
    var _a2;
    (_a2 = element.value) == null ? void 0 : _a2.addEventListener(
      "scroll",
      handler.value,
      { passive: true }
    );
  };
  const removeScrollListener = () => {
    var _a2;
    (_a2 = element.value) == null ? void 0 : _a2.removeEventListener(
      "scroll",
      handler.value
    );
  };
  onMounted25(() => {
    if (!element.value) {
      return;
    }
    element.value.style.overflowY = "scroll";
    if (props.reverse) {
      element.value.scrollTop = element.value.scrollHeight;
    }
    addScrollListener();
  });
  onBeforeUnmount18(removeScrollListener);
  return {
    addScrollListener,
    removeScrollListener
  };
};

// node_modules/vuestic-ui/dist/es/src/components/va-infinite-scroll/VaInfiniteScroll.vue_vue_type_script_setup_true_lang.js
import "D:/Desktop/forntend/Front_End_Web_Hotel_Nhom_2/my-nuxt-app/node_modules/vuestic-ui/dist/es/VaInfiniteScroll.css";
var _hoisted_140 = { class: "va-infinite-scroll__spinner__default" };
var _sfc_main74 = defineComponent74({
  ...{
    name: "VaInfiniteScroll"
  },
  __name: "VaInfiniteScroll",
  props: {
    ...useComponentPresetProp,
    load: { type: Function, required: true },
    offset: { type: [Number, String], default: 500 },
    reverse: { type: Boolean, default: false },
    disabled: { type: Boolean, default: false },
    scrollTarget: { type: [String, Object], default: null },
    debounce: { type: [Number, String], default: 100 },
    tag: { type: String, default: "div" }
  },
  emits: ["onload", "onerror"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const element = shallowRef21();
    const spinnerSlotContainer = shallowRef21();
    const fetching = ref54(false);
    const error = ref54(false);
    const forcedScrolling = ref54(false);
    const debouncedLoad = ref54();
    const notScrolledContentBeforeLoad = ref54(0);
    const prevScrollTop = ref54(0);
    const scrollTargetElement = computed142(() => {
      var _a2;
      let target;
      if (typeof props.scrollTarget === "string") {
        target = document.querySelector(props.scrollTarget);
      } else {
        target = props.scrollTarget || ((_a2 = element.value) == null ? void 0 : _a2.parentElement);
      }
      return target || document.body;
    });
    const {
      addScrollListener,
      removeScrollListener
    } = useScroll(props, scrollTargetElement, debouncedLoad);
    const offsetComputed = useNumericProp("offset");
    const debounceComputed = useNumericProp("debounce");
    const { getColor } = useColors();
    const spinnerColor = computed142(() => {
      return error.value ? getColor("danger") : getColor("primary");
    });
    const spinnerHeight = computed142(() => {
      var _a2;
      return ((_a2 = spinnerSlotContainer.value) == null ? void 0 : _a2.offsetHeight) || 0;
    });
    const computedOffset = computed142(() => {
      return offsetComputed.value + spinnerHeight.value;
    });
    const stop = () => {
      if (props.disabled) {
        return;
      }
      fetching.value = false;
      removeScrollListener();
    };
    const resume = () => {
      if (props.disabled) {
        return;
      }
      addScrollListener();
    };
    const onLoad = () => {
      const { scrollTop, scrollHeight, clientHeight } = scrollTargetElement.value;
      notScrolledContentBeforeLoad.value = scrollHeight - scrollTop;
      const scrollDelta = scrollTop - prevScrollTop.value;
      prevScrollTop.value = scrollTop;
      if (props.disabled || error.value || fetching.value) {
        return;
      }
      if (forcedScrolling.value) {
        forcedScrolling.value = false;
        return;
      }
      const isReverseScrollDirection = props.reverse && scrollDelta > 0 || !props.reverse && scrollDelta < 0;
      if (isReverseScrollDirection) {
        return;
      }
      const offset2 = props.reverse ? scrollTop : scrollHeight - scrollTop - clientHeight;
      if (offset2 > computedOffset.value) {
        return;
      }
      fetching.value = true;
      props.load().then(finishLoading).catch(onError);
    };
    const forceSetScrollTopToTarget = (value) => {
      forcedScrolling.value = true;
      scrollTargetElement.value.scrollTop = value;
    };
    const updateTargetElementScrollTop = () => {
      const { scrollTop, scrollHeight, clientHeight } = scrollTargetElement.value;
      if (props.reverse) {
        const isScrolledUp = scrollHeight - scrollTop < notScrolledContentBeforeLoad.value;
        const isSpinnerHidden = scrollTop >= spinnerHeight.value;
        if (isScrolledUp && isSpinnerHidden) {
          return;
        }
        scrollHeight - notScrolledContentBeforeLoad.value > spinnerHeight.value ? forceSetScrollTopToTarget(scrollHeight - notScrolledContentBeforeLoad.value) : forceSetScrollTopToTarget(spinnerHeight.value);
      }
      if (!props.reverse) {
        const isSpinnerHidden = scrollHeight - scrollTop - clientHeight >= spinnerHeight.value;
        !isSpinnerHidden && forceSetScrollTopToTarget(scrollHeight - clientHeight - spinnerHeight.value);
      }
    };
    const finishLoading = () => {
      updateTargetElementScrollTop();
      fetching.value = false;
      emit("onload");
    };
    const stopErrorDisplay = () => {
      updateTargetElementScrollTop();
      forcedScrolling.value = false;
      error.value = false;
      fetching.value = false;
      emit("onerror");
    };
    const onError = () => {
      stop();
      error.value = true;
      sleep(1200).then(stopErrorDisplay).then(resume);
    };
    watch43(() => debounceComputed.value, (value) => {
      debouncedLoad.value = debounce(onLoad, value);
    }, { immediate: true });
    watch43(() => props.disabled, (value) => {
      value ? stop() : resume();
    });
    return (_ctx, _cache) => {
      return openBlock71(), createBlock35(resolveDynamicComponent8(_ctx.$props.tag), {
        ref_key: "element",
        ref: element,
        role: "feed",
        class: normalizeClass37(["va-infinite-scroll", { "va-infinite-scroll--reversed": _ctx.$props.reverse }]),
        "aria-busy": fetching.value
      }, {
        default: withCtx38(() => [
          renderSlot56(_ctx.$slots, "default"),
          createElementVNode32("div", {
            ref_key: "spinnerSlotContainer",
            ref: spinnerSlotContainer,
            class: normalizeClass37(["va-infinite-scroll__spinner", { "va-infinite-scroll__spinner--invisible": !fetching.value }])
          }, [
            !_ctx.$props.disabled ? renderSlot56(_ctx.$slots, "loading", { key: 0 }, () => [
              createElementVNode32("div", _hoisted_140, [
                createVNode30(unref69(VaProgressCircle), {
                  size: "small",
                  thickness: 0.15,
                  color: spinnerColor.value,
                  indeterminate: ""
                }, null, 8, ["color"])
              ])
            ]) : createCommentVNode36("", true)
          ], 2)
        ]),
        _: 3
      }, 8, ["class", "aria-busy"]);
    };
  }
});

// node_modules/vuestic-ui/dist/es/src/components/va-infinite-scroll/index.js
var VaInfiniteScroll = withConfigTransport$1(_sfc_main74);

// node_modules/vuestic-ui/dist/es/src/components/va-layout/VaLayout.vue_vue_type_script_setup_true_lang.js
import { defineComponent as defineComponent78, computed as computed147, watchEffect as watchEffect8, useSlots as useSlots9, openBlock as openBlock76, createElementBlock as createElementBlock65, normalizeStyle as normalizeStyle39, unref as unref70, Fragment as Fragment21, renderList as renderList16, createVNode as createVNode33, withCtx as withCtx41, renderSlot as renderSlot61, createElementVNode as createElementVNode34 } from "vue";

// node_modules/vuestic-ui/dist/es/src/components/va-layout/hooks/useGridTemplateArea.js
import { computed as computed143 } from "vue";
var areaIndexes = {
  top: [0, 1, 2],
  left: [0, 3, 6],
  right: [2, 5, 8],
  bottom: [6, 7, 8]
};
var areaElements = ["left", "right", "top", "bottom"];
var useGridTemplateArea = (props) => {
  const sort = () => {
    return [...areaElements].sort((a, b) => {
      return (props[a].order ?? 0) - (props[b].order ?? 0);
    });
  };
  const applyTemplate = (template, areaIndexes2, areaName) => {
    areaIndexes2.forEach((index) => {
      template[index] = areaName;
    });
  };
  return computed143(() => {
    const sorted = sort();
    const template = [
      ".",
      ".",
      ".",
      ".",
      ".",
      ".",
      ".",
      ".",
      "."
    ].map(() => "content");
    sorted.forEach((areaName) => {
      applyTemplate(template, areaIndexes[areaName], areaName);
    });
    return [
      '"' + template.slice(0, 3).join(" ") + '"',
      '"' + template.slice(3, 6).join(" ") + '"',
      '"' + template.slice(6, 9).join(" ") + '"'
    ].join(" ");
  });
};

// node_modules/vuestic-ui/dist/es/src/components/va-layout/hooks/useLayout.js
import { ref as ref55, computed as computed144, provide as provide7, inject as inject8, watchEffect as watchEffect7, onBeforeUnmount as onBeforeUnmount19 } from "vue";
var useLayoutProps = {
  top: {
    type: Object,
    default: () => ({ order: 2 })
  },
  right: {
    type: Object,
    default: () => ({ order: 1 })
  },
  left: {
    type: Object,
    default: () => ({ order: 1 })
  },
  bottom: {
    type: Object,
    default: () => ({ order: 2 })
  }
};
var VaLayoutKey = "VaLayout";
var useLayout = (props) => {
  const items2 = ref55({
    top: null,
    right: null,
    bottom: null,
    left: null
  });
  const paddings = computed144(() => {
    const { top, right, bottom, left } = items2.value;
    const { top: topConfig, right: rightConfig, bottom: bottomConfig, left: leftConfig } = props;
    return {
      top: top && !topConfig.absolute ? top.sizes.height : 0,
      right: right && !rightConfig.absolute ? right.sizes.width : 0,
      bottom: bottom && !bottomConfig.absolute ? bottom.sizes.height : 0,
      left: left && !leftConfig.absolute ? left.sizes.width : 0
    };
  });
  const orders = computed144(() => ({
    top: props.top.order || 0,
    right: props.right.order || 0,
    bottom: props.bottom.order || 0,
    left: props.left.order || 0
  }));
  provide7(VaLayoutKey, {
    items: items2,
    paddings,
    orders
  });
  return {
    paddings,
    orders,
    items: items2
  };
};
var useFixedLayoutChild = (area, sizes) => {
  const layout = inject8(VaLayoutKey, null);
  if (!layout) {
    throw new Error("VaLayoutChild must be used inside VaLayout");
  }
  watchEffect7(() => {
    if (sizes.value) {
      layout.items.value[area] = {
        sizes: sizes.value
      };
    } else {
      layout.items.value[area] = null;
    }
  });
  onBeforeUnmount19(() => {
    layout.items.value[area] = null;
  });
  return {
    paddings: computed144(() => {
      return Object.keys(layout.paddings.value).reduce((acc, key) => {
        if (layout.orders.value[key] > layout.orders.value[area]) {
          acc[key] = layout.paddings.value[key];
        }
        return acc;
      }, {});
    })
  };
};

// node_modules/vuestic-ui/dist/es/src/components/va-layout/components/VaLayoutArea.vue_vue_type_script_setup_true_lang.js
import { defineComponent as defineComponent77, computed as computed146, openBlock as openBlock75, createElementBlock as createElementBlock64, Fragment as Fragment20, createBlock as createBlock36, normalizeStyle as normalizeStyle38, withCtx as withCtx40, createElementVNode as createElementVNode33, normalizeClass as normalizeClass39, renderSlot as renderSlot60, createVNode as createVNode32, Transition as Transition4, createCommentVNode as createCommentVNode37 } from "vue";

// node_modules/vuestic-ui/dist/es/src/components/va-layout/components/VaLayoutAbsoluteWrapper.js
import { openBlock as openBlock72, createElementBlock as createElementBlock61, renderSlot as renderSlot57 } from "vue";
import "D:/Desktop/forntend/Front_End_Web_Hotel_Nhom_2/my-nuxt-app/node_modules/vuestic-ui/dist/es/VaLayoutAbsoluteWrapper.css";
var _sfc_main75 = {};
var _hoisted_141 = { class: "va-layout__absolute-area-wrapper" };
function _sfc_render3(_ctx, _cache) {
  return openBlock72(), createElementBlock61("div", _hoisted_141, [
    renderSlot57(_ctx.$slots, "default")
  ]);
}
var VaLayoutAbsoluteWrapper = _export_sfc(_sfc_main75, [["render", _sfc_render3]]);

// node_modules/vuestic-ui/dist/es/src/components/va-layout/components/VaLayoutFixedWrapper.vue_vue_type_script_setup_true_lang.js
import { defineComponent as defineComponent76, ref as ref57, computed as computed145, openBlock as openBlock74, createElementBlock as createElementBlock63, normalizeStyle as normalizeStyle37, createVNode as createVNode31, normalizeClass as normalizeClass38, withCtx as withCtx39, renderSlot as renderSlot59 } from "vue";

// node_modules/vuestic-ui/dist/es/src/components/va-layout/components/VaResizeObserver.vue_vue_type_script_setup_true_lang.js
import { defineComponent as defineComponent75, ref as ref56, watch as watch44, openBlock as openBlock73, createElementBlock as createElementBlock62, renderSlot as renderSlot58 } from "vue";
var _sfc_main76 = defineComponent75({
  ...{
    name: "VaLayoutSizeKeeper"
  },
  __name: "VaResizeObserver",
  emits: {
    resize: (size2) => true
  },
  setup(__props, { emit: __emit }) {
    const emit = __emit;
    const el = ref56();
    let observer = null;
    watch44(el, (newEl) => {
      if (observer) {
        observer.disconnect();
      }
      observer = new ResizeObserver(([el2]) => {
        emit("resize", el2.contentRect);
      });
      observer.observe(newEl);
    });
    return (_ctx, _cache) => {
      return openBlock73(), createElementBlock62("div", {
        class: "va-resize-observer",
        ref_key: "el",
        ref: el
      }, [
        renderSlot58(_ctx.$slots, "default")
      ], 512);
    };
  }
});

// node_modules/vuestic-ui/dist/es/src/components/va-layout/components/VaLayoutFixedWrapper.vue_vue_type_script_setup_true_lang.js
import "D:/Desktop/forntend/Front_End_Web_Hotel_Nhom_2/my-nuxt-app/node_modules/vuestic-ui/dist/es/VaLayoutFixedWrapper.css";
var _sfc_main77 = defineComponent76({
  ...{
    name: "VaLayoutFixedWrapper"
  },
  __name: "VaLayoutFixedWrapper",
  props: {
    area: { type: String, required: true }
  },
  setup(__props) {
    const props = __props;
    const size2 = ref57(null);
    const direction = computed145(() => {
      if (props.area === "top" || props.area === "bottom") {
        return "vertical";
      } else {
        return "horizontal";
      }
    });
    const getPxOrZero = (value) => {
      if (!value) {
        return "0px";
      }
      return value + "px";
    };
    const styles = computed145(() => {
      if (direction.value === "vertical") {
        return { width: `calc(100% - ${getPxOrZero(paddings.value.left)} - ${getPxOrZero(paddings.value.right)})`, [props.area]: 0 };
      } else {
        return { height: `calc(100% - ${getPxOrZero(paddings.value.top)} - ${getPxOrZero(paddings.value.bottom)})`, [props.area]: 0 };
      }
    });
    const { paddings } = useFixedLayoutChild(props.area, size2);
    computed145(() => {
      return Object.keys(paddings.value).reduce((acc, key) => {
        if (key === props.area) {
          return acc;
        }
        return {
          ...acc,
          [key]: `${paddings.value[key]}px`
        };
      }, {});
    });
    return (_ctx, _cache) => {
      return openBlock74(), createElementBlock63("div", {
        class: "va-layout-fixed-wrapper",
        style: normalizeStyle37([[{
          height: size2.value && direction.value === "vertical" ? size2.value.height + "px" : "auto",
          width: size2.value && direction.value === "horizontal" ? size2.value.width + "px" : "auto"
        }], `--va-styles-width: ${String(styles.value.width)};--va-styles-height: ${String(styles.value.height)}`])
      }, [
        createVNode31(_sfc_main76, {
          class: normalizeClass38(["va-layout-fixed-wrapper__content", `va-layout-fixed-wrapper__content--${__props.area}`]),
          style: normalizeStyle37(!size2.value ? { position: "relative" } : {}),
          onResize: _cache[0] || (_cache[0] = ($event) => size2.value = $event)
        }, {
          default: withCtx39(() => [
            renderSlot59(_ctx.$slots, "default")
          ]),
          _: 3
        }, 8, ["class", "style"])
      ], 4);
    };
  }
});

// node_modules/vuestic-ui/dist/es/src/components/va-layout/components/VaLayoutArea.vue_vue_type_script_setup_true_lang.js
import "D:/Desktop/forntend/Front_End_Web_Hotel_Nhom_2/my-nuxt-app/node_modules/vuestic-ui/dist/es/VaLayoutArea.css";
var _sfc_main78 = defineComponent77({
  ...{
    name: "VaLayoutArea"
  },
  __name: "VaLayoutArea",
  props: {
    area: { type: String, required: true },
    config: { type: Object, required: true }
  },
  emits: ["overlay-click"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const absolute = computed146(() => props.config.absolute || false);
    const fixed = computed146(() => props.config.fixed || false);
    const overlay = computed146(() => props.config.overlay || false);
    const zIndex = computed146(() => (props.config.order || 0) + 1);
    return (_ctx, _cache) => {
      return openBlock75(), createElementBlock64(Fragment20, null, [
        absolute.value ? (openBlock75(), createBlock36(VaLayoutAbsoluteWrapper, {
          key: 0,
          style: normalizeStyle38(`--va-props-area: ${String(_ctx.$props.area)};--va-z-index: ${String(zIndex.value)};--va-z-index-1: ${String(zIndex.value - 1)}`)
        }, {
          default: withCtx40(() => [
            createElementVNode33("div", {
              class: normalizeClass39(`va-layout-area va-layout__area va-layout__area--${__props.area}`)
            }, [
              fixed.value ? (openBlock75(), createBlock36(_sfc_main77, {
                key: 0,
                area: __props.area
              }, {
                default: withCtx40(() => [
                  renderSlot60(_ctx.$slots, "default")
                ]),
                _: 3
              }, 8, ["area"])) : renderSlot60(_ctx.$slots, "default", { key: 1 })
            ], 2)
          ]),
          _: 3
        }, 8, ["style"])) : (openBlock75(), createElementBlock64("div", {
          key: 1,
          class: normalizeClass39(`va-layout-area va-layout__area va-layout__area--${__props.area}`),
          style: normalizeStyle38(`--va-props-area: ${String(_ctx.$props.area)};--va-z-index: ${String(zIndex.value)};--va-z-index-1: ${String(zIndex.value - 1)}`)
        }, [
          fixed.value ? (openBlock75(), createBlock36(_sfc_main77, {
            key: 0,
            area: __props.area
          }, {
            default: withCtx40(() => [
              renderSlot60(_ctx.$slots, "default")
            ]),
            _: 3
          }, 8, ["area"])) : renderSlot60(_ctx.$slots, "default", { key: 1 })
        ], 6)),
        createVNode32(Transition4, {
          style: normalizeStyle38(`--va-props-area: ${String(_ctx.$props.area)};--va-z-index: ${String(zIndex.value)};--va-z-index-1: ${String(zIndex.value - 1)}`)
        }, {
          default: withCtx40(() => [
            overlay.value ? (openBlock75(), createElementBlock64("div", {
              key: 0,
              class: normalizeClass39(["va-layout-area__overlay", { "va-layout-area__overlay--fixed": fixed.value }]),
              onClick: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("overlay-click"))
            }, null, 2)) : createCommentVNode37("", true)
          ]),
          _: 1
        }, 8, ["style"])
      ], 64);
    };
  }
});

// node_modules/vuestic-ui/dist/es/src/components/va-layout/VaLayout.vue_vue_type_script_setup_true_lang.js
import "D:/Desktop/forntend/Front_End_Web_Hotel_Nhom_2/my-nuxt-app/node_modules/vuestic-ui/dist/es/VaLayout.css";
var _hoisted_142 = { class: "va-layout__area va-layout__area--content" };
var areaNames = [
  "top",
  "left",
  "right",
  "bottom"
];
var _sfc_main79 = defineComponent78({
  ...{
    name: "VaLayout"
  },
  __name: "VaLayout",
  props: {
    ...useLayoutProps,
    allowBodyScrollOnOverlay: { type: Boolean, default: false }
  },
  emits: [
    "top-overlay-click",
    "left-overlay-click",
    "right-overlay-click",
    "bottom-overlay-click"
  ],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const { paddings } = useLayout(props);
    const doDisableScroll = computed147(() => {
      return !props.allowBodyScrollOnOverlay && areaNames.some((area) => {
        var _a2;
        return (_a2 = props[area]) == null ? void 0 : _a2.overlay;
      });
    });
    const document2 = useDocument();
    watchEffect8(() => {
      var _a2;
      const overflowParent = (_a2 = document2.value) == null ? void 0 : _a2.body;
      if (!overflowParent) {
        return;
      }
      if (doDisableScroll.value) {
        overflowParent.style.overflow = "hidden";
      } else {
        overflowParent.style.overflow = "";
      }
    });
    const templateArea = useGridTemplateArea(props);
    const slots = useSlots9();
    const verticalTemplate = computed147(() => {
      return [
        slots.top ? "min-content" : "0fr",
        "1fr",
        slots.bottom ? "min-content" : "0fr"
      ].filter(Boolean).join(" ");
    });
    const horizontalTemplate = computed147(() => {
      return [
        slots.left ? "min-content" : "0fr",
        "1fr",
        slots.right ? "min-content" : "0fr"
      ].filter(Boolean).join(" ");
    });
    return (_ctx, _cache) => {
      return openBlock76(), createElementBlock65("div", {
        class: "va-layout",
        style: normalizeStyle39(`--va-horizontal-template: ${String(horizontalTemplate.value)};--va-vertical-template: ${String(verticalTemplate.value)};--va-template-area: ${String(unref70(templateArea))};--va-paddings-top-px: ${String(unref70(paddings).top + "px")};--va-paddings-bottom-px: ${String(unref70(paddings).bottom + "px")};--va-paddings-left-px: ${String(unref70(paddings).left + "px")};--va-paddings-right-px: ${String(unref70(paddings).right + "px")}`)
      }, [
        (openBlock76(), createElementBlock65(Fragment21, null, renderList16(areaNames, (area) => {
          return createVNode33(_sfc_main78, {
            key: area,
            area,
            config: _ctx.$props[area] || {},
            onOverlayClick: ($event) => _ctx.$emit(`${area}-overlay-click`)
          }, {
            default: withCtx41(() => [
              renderSlot61(_ctx.$slots, area)
            ]),
            _: 2
          }, 1032, ["area", "config", "onOverlayClick"]);
        }), 64)),
        createElementVNode34("div", _hoisted_142, [
          renderSlot61(_ctx.$slots, "default", {}, () => [
            renderSlot61(_ctx.$slots, "content")
          ])
        ])
      ], 4);
    };
  }
});

// node_modules/vuestic-ui/dist/es/src/components/va-layout/index.js
var VaLayout = withConfigTransport(_sfc_main79);

// node_modules/vuestic-ui/dist/es/src/components/va-navbar/VaNavbar.vue_vue_type_script_setup_true_lang.js
import { defineComponent as defineComponent79, computed as computed148, openBlock as openBlock77, createElementBlock as createElementBlock66, normalizeClass as normalizeClass40, unref as unref71, normalizeStyle as normalizeStyle40, renderSlot as renderSlot62, createElementVNode as createElementVNode35, createCommentVNode as createCommentVNode38 } from "vue";
import "D:/Desktop/forntend/Front_End_Web_Hotel_Nhom_2/my-nuxt-app/node_modules/vuestic-ui/dist/es/VaNavbar.css";
var _hoisted_143 = { class: "va-navbar__left" };
var _hoisted_219 = { class: "va-navbar__center" };
var _hoisted_313 = { class: "va-navbar__right" };
var _sfc_main80 = defineComponent79({
  ...{
    name: "VaNavbar"
  },
  __name: "VaNavbar",
  props: {
    ...useFixedBarProps,
    ...useComponentPresetProp,
    color: { type: String, default: "background-secondary" },
    textColor: { type: String },
    shape: { type: Boolean, default: false },
    shadowed: { type: Boolean, default: false },
    bordered: { type: Boolean, default: false }
  },
  setup(__props) {
    const props = __props;
    const { scrollRoot, isScrolledDown } = setupScroll(props.fixed);
    const { fixedBarStyleComputed } = useFixedBar(props, isScrolledDown);
    const { getColor, shiftHSLAColor: shiftHSLAColor2 } = useColors();
    const color = computed148(() => getColor(props.color));
    const { textColorComputed } = useTextColor(color);
    const shapeStyleComputed = computed148(() => ({
      borderTopColor: shiftHSLAColor2(color.value, { h: -1, s: -11, l: 10 })
    }));
    const computedStyle = computed148(() => ({
      ...fixedBarStyleComputed.value,
      backgroundColor: color.value,
      color: textColorComputed.value,
      fill: textColorComputed.value
    }));
    const bemClasses = useBem("va-navbar", () => ({
      shadowed: props.shadowed,
      bordered: props.bordered
    }));
    return (_ctx, _cache) => {
      return openBlock77(), createElementBlock66("header", {
        ref_key: "scrollRoot",
        ref: scrollRoot,
        class: normalizeClass40(["va-navbar", unref71(bemClasses)]),
        style: normalizeStyle40(computedStyle.value)
      }, [
        renderSlot62(_ctx.$slots, "default", {}, () => [
          createElementVNode35("div", _hoisted_143, [
            renderSlot62(_ctx.$slots, "left")
          ]),
          createElementVNode35("div", _hoisted_219, [
            renderSlot62(_ctx.$slots, "center")
          ]),
          createElementVNode35("div", _hoisted_313, [
            renderSlot62(_ctx.$slots, "right")
          ])
        ]),
        __props.shape ? (openBlock77(), createElementBlock66("div", {
          key: 0,
          class: "va-navbar__background-shape",
          style: normalizeStyle40(shapeStyleComputed.value)
        }, null, 4)) : createCommentVNode38("", true)
      ], 6);
    };
  }
});

// node_modules/vuestic-ui/dist/es/src/components/va-navbar/VaNavbarItem/VaNavbarItem.js
import { defineComponent as defineComponent80, openBlock as openBlock78, createElementBlock as createElementBlock67, renderSlot as renderSlot63 } from "vue";
import "D:/Desktop/forntend/Front_End_Web_Hotel_Nhom_2/my-nuxt-app/node_modules/vuestic-ui/dist/es/VaNavbarItem.css";
var _sfc_main81 = defineComponent80({
  name: "VaNavbarItem",
  props: {}
  // TODO: In web components build props are required (it's a vue bug)
});
var _hoisted_144 = { class: "va-navbar__item" };
function _sfc_render4(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock78(), createElementBlock67("div", _hoisted_144, [
    renderSlot63(_ctx.$slots, "default")
  ]);
}
var _VaNavbarItem = _export_sfc(_sfc_main81, [["render", _sfc_render4]]);

// node_modules/vuestic-ui/dist/es/src/components/va-navbar/index.js
var VaNavbar = withConfigTransport$1(_sfc_main80);
var VaNavbarItem = withConfigTransport$1(_VaNavbarItem);

// node_modules/vuestic-ui/dist/es/src/components/va-option-list/VaOptionList.vue_vue_type_script_setup_true_lang.js
import { defineComponent as defineComponent83, computed as computed151, onMounted as onMounted26, openBlock as openBlock81, createBlock as createBlock39, unref as unref74, withCtx as withCtx44, createElementVNode as createElementVNode38, createElementBlock as createElementBlock70, Fragment as Fragment23, renderList as renderList18, renderSlot as renderSlot66, normalizeProps as normalizeProps28, guardReactiveProps as guardReactiveProps24, mergeProps as mergeProps38 } from "vue";

// node_modules/vuestic-ui/dist/es/src/components/va-radio/VaRadio.vue_vue_type_script_setup_true_lang.js
import { defineComponent as defineComponent81, shallowRef as shallowRef22, computed as computed149, openBlock as openBlock79, createBlock as createBlock37, unref as unref72, normalizeStyle as normalizeStyle41, withCtx as withCtx42, createElementVNode as createElementVNode36, mergeProps as mergeProps36, createElementBlock as createElementBlock68, Fragment as Fragment22, renderList as renderList17, normalizeClass as normalizeClass41, renderSlot as renderSlot64, normalizeProps as normalizeProps26, guardReactiveProps as guardReactiveProps22, createTextVNode as createTextVNode22, toDisplayString as toDisplayString28, createCommentVNode as createCommentVNode39 } from "vue";
import "D:/Desktop/forntend/Front_End_Web_Hotel_Nhom_2/my-nuxt-app/node_modules/vuestic-ui/dist/es/VaRadio.css";
var _hoisted_145 = ["role"];
var _hoisted_220 = ["value", "checked", "aria-checked", "onChange"];
var _hoisted_314 = createElementVNode36("span", {
  "aria-hidden": "true",
  class: "va-radio__icon"
}, [
  createElementVNode36("span", { class: "va-radio__icon__background" }),
  createElementVNode36("span", { class: "va-radio__icon__dot" })
], -1);
var _sfc_main82 = defineComponent81({
  ...{
    name: "VaRadio"
  },
  __name: "VaRadio",
  props: {
    ...useSelectableProps,
    ...useComponentPresetProp,
    ...useSelectableListProps,
    modelValue: {
      type: [Boolean, Array, String, Object, Number],
      default: null
    },
    options: {
      type: Array,
      default: () => []
    },
    name: { type: String, default: "" },
    label: { type: String, default: void 0 },
    leftLabel: { type: Boolean, default: false },
    color: { type: String, default: "primary" },
    option: {
      type: [Object, String, Number],
      default: void 0
    },
    vertical: { type: Boolean, default: false }
  },
  emits: useSelectableEmits,
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const { getColor } = useColors();
    const elements = {
      container: shallowRef22(),
      input: shallowRef22(),
      label: shallowRef22()
    };
    const {
      computedError,
      computedErrorMessages,
      validationAriaAttributes,
      onBlur,
      onFocus
    } = useSelectable(props, emit, elements);
    const { getText: originalGetText, getDisabled: originalGetDisabled, getValue } = useSelectableList(props);
    const getText = (option) => {
      if (props.options.length > 0) {
        return originalGetText(option);
      }
      return props.label ?? originalGetText(option);
    };
    const getDisabled = (option) => originalGetDisabled(option) || props.disabled;
    const isNoOption = computed149(() => props.options.length === 0 && !props.option);
    const isChecked = (option) => {
      if (isNoOption.value) {
        return props.modelValue;
      }
      return props.modelValue === getValue(option);
    };
    const computedOptions = computed149(() => {
      if (isNoOption.value) {
        return [{}];
      }
      if (props.option) {
        return [props.option];
      } else {
        return props.options;
      }
    });
    const radioClass = (option) => ({
      "va-radio--left-label": props.leftLabel,
      "va-radio--selected": isChecked(option),
      "va-radio--readonly": props.readonly,
      "va-radio--disabled": props.disabled,
      "va-radio--indeterminate": props.indeterminate,
      "va-radio--error": computedError.value,
      "va-radio--single-option": isNoOption.value
    });
    const selectOption = (option, event) => {
      var _a2;
      if (isNoOption.value) {
        emit("update:modelValue", ((_a2 = event == null ? void 0 : event.target) == null ? void 0 : _a2.checked) || false);
        return;
      }
      emit("update:modelValue", option);
    };
    const labelStyle = computed149(() => {
      return {
        color: computedError.value ? getColor("danger") : ""
      };
    });
    computed149(() => {
      const style = {
        background: getColor(props.color),
        borderColor: getColor(props.color)
      };
      if (computedError.value) {
        style.borderColor = getColor("danger");
      }
      return style;
    });
    const iconBackgroundComputedStyles = computed149(() => ({
      backgroundColor: getColor(props.color)
    }));
    const iconDotComputedStyles = computed149(() => {
      return {
        borderColor: computedError.value ? getColor("danger") : getColor(props.color),
        backgroundColor: getColor(props.color)
      };
    });
    const iconComputedStyles = computed149(() => {
      return { borderColor: computedError.value ? getColor("danger") : getColor(props.color) };
    });
    const componentId = useComponentUuid();
    const computedName = computed149(() => props.name || componentId);
    const inputAttributesComputed = (option) => {
      const disabled = getDisabled(option);
      return {
        name: computedName.value,
        disabled,
        readonly: props.readonly,
        tabindex: disabled ? -1 : 0
      };
    };
    const flexDirection = computed149(() => props.vertical ? "column" : "row");
    const roleComputed = computed149(() => {
      var _a2;
      return ((_a2 = props.options) == null ? void 0 : _a2.length) > 0 ? "radiogroup" : "";
    });
    return (_ctx, _cache) => {
      return openBlock79(), createBlock37(unref72(_sfc_main3), {
        disabled: _ctx.disabled,
        success: _ctx.success,
        messages: _ctx.messages,
        error: unref72(computedError),
        "error-messages": unref72(computedErrorMessages),
        "error-count": _ctx.errorCount,
        onBlur: unref72(onBlur),
        style: normalizeStyle41(`--va-flex-direction: ${String(flexDirection.value)};--va-label-style-color: ${String(labelStyle.value.color)};--va-icon-computed-styles-border-color: ${String(iconComputedStyles.value.borderColor)};--va-icon-dot-computed-styles-border-color: ${String(iconDotComputedStyles.value.borderColor)};--va-icon-dot-computed-styles-background-color: ${String(iconDotComputedStyles.value.backgroundColor)};--va-icon-background-computed-styles-background-color: ${String(iconBackgroundComputedStyles.value.backgroundColor)}`)
      }, {
        default: withCtx42(({ ariaAttributes }) => [
          createElementVNode36("div", mergeProps36({
            ref: "container",
            class: "va-radio",
            role: roleComputed.value
          }, ariaAttributes), [
            (openBlock79(true), createElementBlock68(Fragment22, null, renderList17(computedOptions.value, (option, index) => {
              return openBlock79(), createElementBlock68("label", {
                key: index,
                class: normalizeClass41([radioClass(option), "va-radio__square"])
              }, [
                createElementVNode36("input", mergeProps36({
                  ref_for: true,
                  ref: "input",
                  class: "va-radio__input",
                  type: "radio",
                  role: "radio",
                  value: isChecked(option),
                  checked: isChecked(option),
                  "aria-checked": isChecked(option)
                }, { ...inputAttributesComputed(option), ...ariaAttributes }, {
                  onChange: ($event) => selectOption(unref72(getValue)(option), $event),
                  onFocus: _cache[0] || (_cache[0] = //@ts-ignore
                  (...args) => unref72(onFocus) && unref72(onFocus)(...args)),
                  onBlur: _cache[1] || (_cache[1] = //@ts-ignore
                  (...args) => unref72(onBlur) && unref72(onBlur)(...args))
                }), null, 16, _hoisted_220),
                renderSlot64(_ctx.$slots, "icon", normalizeProps26(guardReactiveProps22({
                  value: isChecked(option),
                  text: getText(option),
                  disabled: getDisabled(option),
                  index
                })), () => [
                  _hoisted_314
                ]),
                getText(option) || _ctx.$slots.default ? (openBlock79(), createElementBlock68("div", {
                  key: 0,
                  ref_for: true,
                  ref: "label",
                  class: "va-radio__text"
                }, [
                  renderSlot64(_ctx.$slots, "default", normalizeProps26(guardReactiveProps22({
                    value: isChecked(option),
                    text: getText(option),
                    disabled: getDisabled(option),
                    index
                  })), () => [
                    createTextVNode22(toDisplayString28(getText(option)), 1)
                  ])
                ], 512)) : createCommentVNode39("", true)
              ], 2);
            }), 128))
          ], 16, _hoisted_145)
        ]),
        _: 3
      }, 8, ["disabled", "success", "messages", "error", "error-messages", "error-count", "onBlur", "style"]);
    };
  }
});

// node_modules/vuestic-ui/dist/es/src/components/va-radio/index.js
var VaRadio = withConfigTransport$1(_sfc_main82);

// node_modules/vuestic-ui/dist/es/src/components/va-switch/VaSwitch.vue_vue_type_script_setup_true_lang.js
import { defineComponent as defineComponent82, shallowRef as shallowRef23, computed as computed150, useSlots as useSlots10, openBlock as openBlock80, createBlock as createBlock38, unref as unref73, normalizeClass as normalizeClass42, normalizeStyle as normalizeStyle42, withCtx as withCtx43, createElementVNode as createElementVNode37, mergeProps as mergeProps37, toHandlers as toHandlers6, withKeys as withKeys18, createElementBlock as createElementBlock69, renderSlot as renderSlot65, createTextVNode as createTextVNode23, toDisplayString as toDisplayString29, createCommentVNode as createCommentVNode40, normalizeProps as normalizeProps27, guardReactiveProps as guardReactiveProps23, withModifiers as withModifiers15 } from "vue";
import "D:/Desktop/forntend/Front_End_Web_Hotel_Nhom_2/my-nuxt-app/node_modules/vuestic-ui/dist/es/VaSwitch.css";
var _hoisted_146 = { class: "va-switch__inner" };
var _hoisted_221 = { class: "va-switch__checker-wrapper" };
var _hoisted_315 = { class: "va-switch__checker" };
var _hoisted_48 = { class: "va-switch__checker-circle" };
var _hoisted_57 = ["id"];
var _sfc_main83 = defineComponent82({
  ...{
    name: "VaSwitch"
  },
  __name: "VaSwitch",
  props: {
    ...useSelectableProps,
    ...useComponentPresetProp,
    id: { type: String, default: "" },
    name: { type: String, default: "" },
    modelValue: {
      type: [Number, Boolean, Array, String, Object],
      default: false
    },
    trueLabel: { type: String, default: null },
    falseLabel: { type: String, default: null },
    trueInnerLabel: { type: String, default: null },
    falseInnerLabel: { type: String, default: null },
    ariaLabel: useTranslationProp("$t:switch"),
    color: { type: String, default: "primary" },
    offColor: { type: String, default: "background-element" },
    size: {
      type: String,
      default: "medium",
      validator: (value) => ["medium", "small", "large"].includes(value)
    }
  },
  emits: [
    ...useSelectableEmits,
    "focus",
    "blur",
    "update:modelValue"
  ],
  setup(__props, { expose: __expose, emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const elements = {
      container: shallowRef23(),
      input: shallowRef23(),
      label: shallowRef23()
    };
    const { getColor } = useColors();
    const { hasKeyboardFocus, keyboardFocusListeners } = useKeyboardOnlyFocus();
    const {
      isChecked,
      computedError,
      isIndeterminate,
      computedErrorMessages,
      validationAriaAttributes,
      toggleSelection,
      onBlur,
      onFocus,
      reset,
      focus,
      isDirty,
      isTouched,
      isLoading,
      isError
    } = useSelectable(props, emit, elements);
    const computedBackground = computed150(() => getColor(isChecked.value ? props.color : props.offColor));
    const { textColorComputed } = useTextColor(computedBackground);
    const computedInnerLabel = computed150(() => {
      if (props.trueInnerLabel && isChecked.value) {
        return props.trueInnerLabel;
      }
      if (props.falseInnerLabel && !isChecked.value) {
        return props.falseInnerLabel;
      }
      return "";
    });
    const computedLabel = computed150(() => {
      if (props.trueLabel && isChecked.value) {
        return props.trueLabel;
      }
      if (props.falseLabel && !isChecked.value) {
        return props.falseLabel;
      }
      return props.label;
    });
    const computedClass = useBem("va-switch", () => ({
      ...pick(props, ["readonly", "disabled", "leftLabel"]),
      checked: isChecked.value,
      indeterminate: isIndeterminate.value,
      small: props.size === "small",
      large: props.size === "large",
      error: computedError.value,
      keyboardFocus: hasKeyboardFocus.value
    }));
    const styleComputed = computed150(() => ({
      lineHeight: computedErrorMessages.value.length ? 1 : 0
    }));
    const progressCircleSize = computed150(() => {
      const size2 = { small: "15px", medium: "20px", large: "25px" };
      return size2[props.size];
    });
    const trackStyle = computed150(() => ({
      borderColor: computedError.value ? getColor("danger") : "",
      backgroundColor: computedBackground.value
    }));
    const labelStyle = computed150(() => ({
      color: computedError.value ? getColor("danger") : ""
    }));
    const trackLabelStyle = computed150(() => ({
      color: textColorComputed.value,
      "text-align": isChecked.value ? "left" : "right"
    }));
    const slots = useSlots10();
    const componentId = useComponentUuid();
    const ariaLabelIdComputed = computed150(() => `aria-label-id-${componentId}`);
    const inputAttributesComputed = computed150(() => ({
      id: props.id || void 0,
      name: props.name || void 0,
      disabled: props.disabled,
      readonly: props.readonly,
      "aria-disabled": props.disabled,
      "aria-readonly": props.readonly,
      "aria-checked": !!props.modelValue,
      "aria-label": !slots.default ? props.ariaLabel : void 0,
      "aria-labelledby": computedLabel.value || slots.default ? ariaLabelIdComputed.value : void 0,
      tabindex: props.disabled ? -1 : 0,
      checked: isChecked.value,
      ...validationAriaAttributes.value
    }));
    const onEnterKeyPress = () => {
      var _a2;
      (_a2 = elements.input.value) == null ? void 0 : _a2.click();
    };
    const input = elements.input;
    __expose({
      focus,
      reset,
      isDirty,
      isTouched,
      isLoading,
      isError
    });
    return (_ctx, _cache) => {
      return openBlock80(), createBlock38(unref73(_sfc_main3), {
        class: normalizeClass42(["va-switch", unref73(computedClass)]),
        style: normalizeStyle42(styleComputed.value),
        disabled: _ctx.$props.disabled,
        success: _ctx.$props.success,
        messages: _ctx.$props.messages,
        error: unref73(computedError),
        "error-messages": unref73(computedErrorMessages),
        "error-count": _ctx.$props.errorCount
      }, {
        default: withCtx43(() => [
          createElementVNode37("div", {
            ref: "container",
            class: "va-switch__container",
            tabindex: "-1",
            onBlur: _cache[5] || (_cache[5] = //@ts-ignore
            (...args) => unref73(onBlur) && unref73(onBlur)(...args)),
            onClick: _cache[6] || (_cache[6] = //@ts-ignore
            (...args) => unref73(toggleSelection) && unref73(toggleSelection)(...args))
          }, [
            createElementVNode37("div", _hoisted_146, [
              createElementVNode37("input", mergeProps37({
                ref_key: "input",
                ref: input,
                type: "checkbox",
                class: "va-switch__input",
                role: "switch"
              }, inputAttributesComputed.value, toHandlers6(unref73(keyboardFocusListeners), true), {
                onFocus: _cache[0] || (_cache[0] = //@ts-ignore
                (...args) => unref73(onFocus) && unref73(onFocus)(...args)),
                onBlur: _cache[1] || (_cache[1] = //@ts-ignore
                (...args) => unref73(onBlur) && unref73(onBlur)(...args)),
                onKeypress: withKeys18(onEnterKeyPress, ["enter"])
              }), null, 16),
              createElementVNode37("div", {
                class: "va-switch__track",
                "aria-hidden": "true",
                style: normalizeStyle42(trackStyle.value)
              }, [
                computedInnerLabel.value || _ctx.$slots.innerLabel ? (openBlock80(), createElementBlock69("div", {
                  key: 0,
                  class: "va-switch__track-label",
                  style: normalizeStyle42(trackLabelStyle.value)
                }, [
                  renderSlot65(_ctx.$slots, "innerLabel", {}, () => [
                    createTextVNode23(toDisplayString29(computedInnerLabel.value), 1)
                  ])
                ], 4)) : createCommentVNode40("", true),
                createElementVNode37("div", _hoisted_221, [
                  createElementVNode37("div", _hoisted_315, [
                    renderSlot65(_ctx.$slots, "checker", normalizeProps27(guardReactiveProps23({ value: unref73(isChecked) })), () => [
                      createElementVNode37("div", _hoisted_48, [
                        _ctx.$props.loading ? (openBlock80(), createBlock38(unref73(VaProgressCircle), {
                          key: 0,
                          indeterminate: "",
                          size: progressCircleSize.value,
                          color: trackStyle.value.backgroundColor
                        }, null, 8, ["size", "color"])) : createCommentVNode40("", true)
                      ])
                    ])
                  ])
                ])
              ], 4)
            ]),
            computedLabel.value || _ctx.$slots.default ? (openBlock80(), createElementBlock69("div", {
              key: 0,
              ref: "label",
              class: "va-switch__label",
              style: normalizeStyle42(labelStyle.value),
              id: ariaLabelIdComputed.value,
              onBlur: _cache[2] || (_cache[2] = //@ts-ignore
              (...args) => unref73(onBlur) && unref73(onBlur)(...args)),
              onClick: _cache[3] || (_cache[3] = //@ts-ignore
              (...args) => unref73(toggleSelection) && unref73(toggleSelection)(...args)),
              onKeydown: _cache[4] || (_cache[4] = withKeys18(withModifiers15(
                //@ts-ignore
                (...args) => unref73(toggleSelection) && unref73(toggleSelection)(...args),
                ["stop"]
              ), ["enter"]))
            }, [
              renderSlot65(_ctx.$slots, "default", {}, () => [
                createTextVNode23(toDisplayString29(computedLabel.value), 1)
              ])
            ], 44, _hoisted_57)) : createCommentVNode40("", true)
          ], 544)
        ]),
        _: 3
      }, 8, ["class", "style", "disabled", "success", "messages", "error", "error-messages", "error-count"]);
    };
  }
});

// node_modules/vuestic-ui/dist/es/src/components/va-switch/index.js
var VaSwitch = withConfigTransport$1(_sfc_main83);

// node_modules/vuestic-ui/dist/es/src/composables/useArrayRefs.js
import { shallowRef as shallowRef24, onBeforeUpdate } from "vue";
var useArrayRefs = () => {
  const itemRefs = shallowRef24([]);
  const setItemRef = (el) => {
    if (!el) {
      return;
    }
    itemRefs.value.push(el);
  };
  const setItemRefByIndex = (index) => (el) => {
    if (!el) {
      return;
    }
    itemRefs.value[index] = el;
  };
  onBeforeUpdate(() => {
    itemRefs.value = [];
  });
  return {
    itemRefs,
    setItemRef,
    setItemRefByIndex
  };
};

// node_modules/vuestic-ui/dist/es/src/components/va-option-list/VaOptionList.vue_vue_type_script_setup_true_lang.js
import "D:/Desktop/forntend/Front_End_Web_Hotel_Nhom_2/my-nuxt-app/node_modules/vuestic-ui/dist/es/VaOptionList.css";
var _hoisted_147 = { class: "va-option-list__list" };
var _sfc_main84 = defineComponent83({
  ...{
    name: "VaOptionList"
  },
  __name: "VaOptionList",
  props: {
    ...useComponentPresetProp,
    ...useSelectableListProps,
    ...useValidationProps,
    ...useStatefulProps,
    type: {
      type: String,
      default: "checkbox",
      validator: (type) => ["radio", "checkbox", "switch"].includes(type)
    },
    disabled: { type: Boolean, default: false },
    readonly: { type: Boolean, default: false },
    defaultValue: { type: [String, Number, Boolean, Object, Array] },
    name: { type: String, default: "" },
    color: { type: String, default: "primary" },
    leftLabel: { type: Boolean, default: false },
    modelValue: { type: [String, Number, Boolean, Object, Array] }
  },
  emits: [...useStatefulEmits, ...useValidationEmits, "clear"],
  setup(__props, { expose: __expose, emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const { valueComputed } = useStateful(props, emit, "modelValue", { defaultValue: props.defaultValue });
    const { getValue, getText, getTrackBy, getDisabled } = useSelectableList(props);
    const { itemRefs, setItemRef } = useArrayRefs();
    const isRadio = computed151(() => props.type === "radio");
    const selectedValue = computed151({
      get() {
        const value = isRadio.value ? null : [];
        return valueComputed.value || value;
      },
      set(value) {
        if (props.readonly) {
          return;
        }
        if (isRadio.value && !Array.isArray(value)) {
          valueComputed.value = value ? getValue(value) : value;
        } else {
          valueComputed.value = Array.isArray(value) ? value.map(getValue) : [value ? getValue(value) : value];
        }
      }
    });
    const isDisabled = (option) => props.disabled || getDisabled(option);
    const reset = () => withoutValidation(() => {
      valueComputed.value = null;
      emit("clear");
      resetValidation();
    });
    const focus = () => {
      const firstActiveEl = Array.isArray(itemRefs.value) && itemRefs.value.find((el) => !el.disabled);
      if (firstActiveEl && typeof firstActiveEl.focus === "function") {
        firstActiveEl.focus();
      }
    };
    const {
      computedError,
      computedErrorMessages,
      withoutValidation,
      resetValidation
    } = useValidation(props, emit, { reset, focus, value: valueComputed });
    const computedProps = computed151(() => pick(props, ["name", "color", "readonly", "leftLabel"]));
    onMounted26(() => {
      if (isDev && props.type !== "radio" && !Array.isArray(props.modelValue)) {
        console.warn(`Prop 'modelValue = ${props.modelValue}' has not a proper type!
 For component property 'type = ${props.type}' it must be of type 'array'.`);
      }
    });
    __expose({
      focus,
      reset
    });
    return (_ctx, _cache) => {
      return openBlock81(), createBlock39(unref74(_sfc_main3), {
        error: unref74(computedError),
        "error-messages": unref74(computedErrorMessages),
        "error-count": _ctx.$props.errorCount
      }, {
        default: withCtx44(() => [
          createElementVNode38("ul", _hoisted_147, [
            (openBlock81(true), createElementBlock70(Fragment23, null, renderList18(_ctx.$props.options, (option) => {
              return openBlock81(), createElementBlock70("li", {
                key: unref74(getTrackBy)(option)
              }, [
                renderSlot66(_ctx.$slots, "default", normalizeProps28(guardReactiveProps24({ option, selectedValue: selectedValue.value, isDisabled, getText: unref74(getText), getValue: unref74(getValue) })), () => [
                  _ctx.$props.type === "radio" ? (openBlock81(), createBlock39(unref74(VaRadio), mergeProps38({
                    key: 0,
                    ref_for: true,
                    ref: unref74(setItemRef),
                    modelValue: selectedValue.value,
                    "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => selectedValue.value = $event),
                    label: unref74(getText)(option),
                    disabled: isDisabled(option),
                    option: unref74(getValue)(option)
                  }, computedProps.value), null, 16, ["modelValue", "label", "disabled", "option"])) : _ctx.$props.type === "checkbox" ? (openBlock81(), createBlock39(unref74(VaCheckbox), mergeProps38({
                    key: 1,
                    ref_for: true,
                    ref: unref74(setItemRef),
                    modelValue: selectedValue.value,
                    "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => selectedValue.value = $event),
                    label: unref74(getText)(option),
                    disabled: isDisabled(option),
                    "array-value": unref74(getValue)(option)
                  }, computedProps.value), null, 16, ["modelValue", "label", "disabled", "array-value"])) : (openBlock81(), createBlock39(unref74(VaSwitch), mergeProps38({
                    key: 2,
                    ref_for: true,
                    ref: unref74(setItemRef),
                    modelValue: selectedValue.value,
                    "onUpdate:modelValue": _cache[2] || (_cache[2] = ($event) => selectedValue.value = $event),
                    label: unref74(getText)(option),
                    disabled: isDisabled(option),
                    "array-value": unref74(getValue)(option)
                  }, computedProps.value), null, 16, ["modelValue", "label", "disabled", "array-value"]))
                ])
              ]);
            }), 128))
          ])
        ]),
        _: 3
      }, 8, ["error", "error-messages", "error-count"]);
    };
  }
});

// node_modules/vuestic-ui/dist/es/src/components/va-option-list/index.js
var VaOptionList = withConfigTransport$1(_sfc_main84);

// node_modules/vuestic-ui/dist/es/src/components/va-pagination/VaPagination.vue_vue_type_script_setup_true_lang.js
import { defineComponent as defineComponent84, shallowRef as shallowRef25, ref as ref58, computed as computed152, toRefs as toRefs8, watch as watch45, openBlock as openBlock82, createElementBlock as createElementBlock71, normalizeClass as normalizeClass43, unref as unref75, withKeys as withKeys19, withModifiers as withModifiers16, renderSlot as renderSlot67, normalizeProps as normalizeProps29, mergeProps as mergeProps39, createBlock as createBlock40, createCommentVNode as createCommentVNode41, Fragment as Fragment24, renderList as renderList19, withCtx as withCtx45, createTextVNode as createTextVNode24, toDisplayString as toDisplayString30, withDirectives as withDirectives6, vModelDynamic as vModelDynamic3, nextTick as nextTick10 } from "vue";

// node_modules/vuestic-ui/dist/es/src/components/va-pagination/setPaginationRange.js
var setPaginationRange = (currentPage = 1, visiblePages, pages, includeBoundary = false) => {
  let start = 0;
  if (pages === 0) {
    pages = 1;
  }
  if (visiblePages > pages) {
    visiblePages = pages;
  }
  if (visiblePages === 0) {
    start = 1;
    visiblePages = pages > 10 ? 10 : pages;
  } else {
    const paginationMiddlePage = visiblePages / 2;
    if (currentPage - paginationMiddlePage <= 0 || currentPage > pages) {
      start = 1;
    } else {
      start = currentPage + paginationMiddlePage > pages ? pages - visiblePages + 1 : Math.ceil(currentPage - paginationMiddlePage);
    }
  }
  const range = [];
  for (let i = 0; i < visiblePages; i++) {
    range.push(start + i);
  }
  if (includeBoundary && visiblePages < 7) {
    pages >= 7 && warn(
      "[va-pagination] To work in a proper way, the `boundaryNumbers` prop needs at least 7 visible pages to be set via the `visiblePages` prop (first, last, 2 boundaries, current, previous, next)."
    );
  } else if (includeBoundary) {
    start !== 1 && range.splice(0, 2, 1, "...");
    range[range.length - 1] !== pages && range.splice(-2, 2, "...", pages);
  }
  return range;
};

// node_modules/vuestic-ui/dist/es/src/components/va-pagination/VaPagination.vue_vue_type_script_setup_true_lang.js
import "D:/Desktop/forntend/Front_End_Web_Hotel_Nhom_2/my-nuxt-app/node_modules/vuestic-ui/dist/es/VaPagination.css";
var _hoisted_148 = ["aria-label", "onKeydown"];
var _hoisted_222 = ["aria-label"];
var _sfc_main85 = defineComponent84({
  ...{
    name: "VaPagination"
  },
  __name: "VaPagination",
  props: {
    ...useStatefulProps,
    ...useComponentPresetProp,
    modelValue: { type: Number, default: 1 },
    visiblePages: { type: [Number, String], default: 0 },
    pages: { type: [Number, String], default: 0 },
    disabled: { type: Boolean, default: false },
    color: { type: String, default: "primary" },
    size: {
      type: String,
      default: "medium",
      validator: (v) => ["small", "medium", "large"].includes(v)
    },
    boundaryLinks: { type: Boolean, default: true },
    boundaryNumbers: { type: Boolean, default: false },
    directionLinks: { type: Boolean, default: true },
    input: { type: Boolean, default: false },
    hideOnSinglePage: { type: Boolean, default: false },
    total: { type: [Number, String], default: null },
    pageSize: { type: [Number, String], default: null },
    boundaryIconLeft: { type: String, default: "va-arrow-first" },
    boundaryIconRight: { type: String, default: "va-arrow-last" },
    directionIconLeft: { type: String, default: "va-arrow-left" },
    directionIconRight: { type: String, default: "va-arrow-right" },
    gapped: { type: Boolean, default: false },
    borderColor: { type: String, default: "" },
    rounded: { type: Boolean, default: false },
    /** @deprecated Use activeButtonProps="{ color: 'myColor' }" */
    activePageColor: { type: String, default: "" },
    activeButtonProps: { type: Object, default: () => ({}) },
    buttonProps: { type: Object, default: () => ({}) },
    buttonsPreset: { type: String, default: "primary" },
    ariaLabel: useTranslationProp("$t:pagination"),
    ariaGoToTheFirstPageLabel: useTranslationProp("$t:goToTheFirstPage"),
    ariaGoToPreviousPageLabel: useTranslationProp("$t:goToPreviousPage"),
    ariaGoToSpecificPageLabel: useTranslationProp("$t:goToSpecificPage"),
    ariaGoToSpecificPageInputLabel: useTranslationProp("$t:goToSpecificPageInput"),
    ariaGoToNextPageLabel: useTranslationProp("$t:goNextPage"),
    ariaGoToLastPageLabel: useTranslationProp("$t:goLastPage")
  },
  emits: [...useStatefulEmits],
  setup(__props, { expose: __expose, emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const htmlInput = shallowRef25();
    const inputValue = ref58("");
    const usesTotal = computed152(() => !!((totalComputed.value || totalComputed.value === 0) && pageSizeComputed.value));
    const { valueComputed } = useStateful(props, emit);
    const currentValue = computed152({
      get: () => usesTotal.value ? Math.ceil(valueComputed.value / pageSizeComputed.value) || 1 : valueComputed.value,
      set: (value) => {
        valueComputed.value = value;
      }
    });
    const visiblePagesComputed = useNumericProp("visiblePages");
    const pagesComputed = useNumericProp("pages");
    const totalComputed = useNumericProp("total");
    const pageSizeComputed = useNumericProp("pageSize");
    const paginationRange = computed152(() => {
      const { boundaryNumbers } = props;
      const value = currentValue.value || 1;
      const totalPages = usesTotal.value ? Math.ceil(totalComputed.value / pageSizeComputed.value) : pagesComputed.value;
      return setPaginationRange(value, visiblePagesComputed.value, totalPages, boundaryNumbers);
    });
    const lastPage = computed152(() => usesTotal.value ? Math.ceil(totalComputed.value / pageSizeComputed.value) || 1 : +pagesComputed.value);
    const isLastPageNotVisible = computed152(() => !!visiblePagesComputed.value && lastPage.value > visiblePagesComputed.value || props.input);
    const showBoundaryLinks = computed152(() => {
      const { boundaryLinks, boundaryNumbers } = props;
      return isLastPageNotVisible.value && boundaryLinks && !boundaryNumbers;
    });
    const showDirectionLinks = computed152(() => isLastPageNotVisible.value && props.directionLinks);
    const showPagination = computed152(() => lastPage.value > 1 || !props.hideOnSinglePage && lastPage.value <= 1);
    const focusInput = () => {
      inputValue.value = String(currentValue.value);
      nextTick10(() => {
        var _a2;
        return (_a2 = htmlInput.value) == null ? void 0 : _a2.setSelectionRange(0, htmlInput.value.value.length);
      });
    };
    const { setItemRefByIndex, itemRefs } = useArrayRefs();
    const onUserInput = (pageNum) => {
      var _a2;
      if (pageNum === "..." || pageNum === currentValue.value) {
        return;
      }
      const limitedPageNum = clamp(pageNum, 1, lastPage.value);
      currentValue.value = usesTotal.value ? (limitedPageNum - 1) * pageSizeComputed.value + 1 : limitedPageNum;
      (_a2 = itemRefs.value[pageNum - 1]) == null ? void 0 : _a2.focus();
    };
    const resetInput = () => {
      var _a2;
      inputValue.value = "";
      (_a2 = htmlInput.value) == null ? void 0 : _a2.blur();
    };
    const changeValue = () => {
      if (+inputValue.value === currentValue.value) {
        resetInput();
      }
      if (!inputValue.value.length) {
        return;
      }
      let pageNum = Number.parseInt(inputValue.value);
      switch (true) {
        case pageNum < 1:
          pageNum = 1;
          break;
        case pageNum > lastPage.value:
          pageNum = lastPage.value;
          break;
        case isNaN(pageNum):
          pageNum = currentValue.value;
          break;
      }
      onUserInput(pageNum);
      resetInput();
    };
    const { getColor, colorToRgba: colorToRgba2 } = useColors();
    const inputBorderColorComputed = computed152(() => {
      const { color, buttonsPreset } = toRefs8(props);
      if (!color.value) {
        return "transparent";
      }
      switch (buttonsPreset.value) {
        case "default":
          return getColor(color.value);
        case void 0:
        case "primary":
          return colorToRgba2(getColor(color.value), 0.1);
        default:
          return "transparent";
      }
    });
    const inputStyleComputed = computed152(() => ({
      cursor: "default",
      color: getColor(props.color),
      opacity: props.disabled ? 0.4 : 1,
      borderColor: inputBorderColorComputed.value
    }));
    watch45([usesTotal, () => pagesComputed.value], () => {
      if (isDev && usesTotal.value && pagesComputed.value) {
        throw new Error("Please, use either `total` and `page-size` props, or `pages`.");
      }
    });
    const inputAttributesComputed = computed152(() => ({
      disabled: props.disabled,
      placeholder: `${currentValue.value}/${lastPage.value}`
    }));
    const buttonPropsComputed = computed152(() => ({
      size: props.size,
      preset: props.buttonsPreset,
      color: props.color,
      borderColor: props.borderColor,
      round: props.rounded,
      ...props.buttonProps
    }));
    const currentPageButtonProps = computed152(() => ({
      preset: props.buttonsPreset === "default" ? "primary" : "default",
      color: props.activePageColor || props.color,
      ...props.activeButtonProps
    }));
    const getPageButtonProps = (n) => {
      if (!isNaN(+n) && n === currentValue.value) {
        return Object.assign({}, buttonPropsComputed.value, currentPageButtonProps.value);
      }
      return buttonPropsComputed.value;
    };
    const isStandAloneInput = computed152(() => props.input && !props.boundaryLinks && !props.directionLinks);
    const inputClassComputed = useBem("va-pagination__input", () => ({
      sm: props.size === "small" && isStandAloneInput.value,
      md: props.size === "medium" && isStandAloneInput.value,
      lg: props.size === "large" && isStandAloneInput.value,
      auto: !isStandAloneInput.value
    }));
    const classComputed = useBem("va-pagination", () => ({
      ...pick(props, ["gapped", "rounded", "disabled"]),
      bordered: !!props.borderColor
    }));
    const goNextPage = () => onUserInput(currentValue.value + 1);
    const goPrevPage = () => onUserInput(currentValue.value - 1);
    const { tp } = useTranslation();
    __expose({
      goNextPage,
      goPrevPage
    });
    return (_ctx, _cache) => {
      return showPagination.value ? (openBlock82(), createElementBlock71("nav", {
        key: 0,
        class: normalizeClass43(["va-pagination", unref75(classComputed)]),
        "aria-label": unref75(tp)(_ctx.$props.ariaLabel),
        onKeydown: [
          withKeys19(withModifiers16(goPrevPage, ["stop"]), ["left"]),
          withKeys19(withModifiers16(goNextPage, ["stop"]), ["right"]),
          withKeys19(withModifiers16(goPrevPage, ["stop"]), ["up"]),
          withKeys19(withModifiers16(goNextPage, ["stop"]), ["down"])
        ]
      }, [
        showBoundaryLinks.value ? renderSlot67(_ctx.$slots, "firstPageLink", normalizeProps29(mergeProps39({ key: 0 }, { onClick: () => onUserInput(1), disabled: _ctx.$props.disabled || currentValue.value === 1 })), () => [
          showBoundaryLinks.value ? (openBlock82(), createBlock40(unref75(VaButton), mergeProps39({
            key: 0,
            "aria-label": unref75(tp)(_ctx.$props.ariaGoToTheFirstPageLabel),
            disabled: _ctx.$props.disabled || currentValue.value === 1,
            icon: _ctx.$props.boundaryIconLeft
          }, buttonPropsComputed.value, {
            onClick: _cache[0] || (_cache[0] = ($event) => onUserInput(1))
          }), null, 16, ["aria-label", "disabled", "icon"])) : createCommentVNode41("", true)
        ]) : createCommentVNode41("", true),
        showDirectionLinks.value ? renderSlot67(_ctx.$slots, "prevPageLink", normalizeProps29(mergeProps39({ key: 1 }, { onClick: goPrevPage, disabled: _ctx.$props.disabled || currentValue.value === 1 })), () => [
          showDirectionLinks.value ? (openBlock82(), createBlock40(unref75(VaButton), mergeProps39({
            key: 0,
            "aria-label": unref75(tp)(_ctx.$props.ariaGoToPreviousPageLabel),
            disabled: _ctx.$props.disabled || currentValue.value === 1,
            icon: _ctx.$props.directionIconLeft
          }, buttonPropsComputed.value, { onClick: goPrevPage }), null, 16, ["aria-label", "disabled", "icon"])) : createCommentVNode41("", true)
        ]) : createCommentVNode41("", true),
        !_ctx.$props.input ? renderSlot67(_ctx.$slots, "default", { key: 2 }, () => [
          (openBlock82(true), createElementBlock71(Fragment24, null, renderList19(paginationRange.value, (n, i) => {
            return openBlock82(), createBlock40(unref75(VaButton), mergeProps39({
              key: i,
              ref_for: true,
              ref: unref75(setItemRefByIndex)(i),
              class: { "va-button--ellipsis": n === "...", "va-button--current": n === currentValue.value },
              "aria-label": unref75(tp)(_ctx.$props.ariaGoToSpecificPageLabel, { page: n }),
              "aria-current": n === currentValue.value,
              disabled: _ctx.$props.disabled || n === "..."
            }, getPageButtonProps(n), {
              onClick: ($event) => onUserInput(n)
            }), {
              default: withCtx45(() => [
                createTextVNode24(toDisplayString30(n), 1)
              ]),
              _: 2
            }, 1040, ["class", "aria-label", "aria-current", "disabled", "onClick"]);
          }), 128))
        ]) : withDirectives6((openBlock82(), createElementBlock71("input", mergeProps39({
          key: 3,
          "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => inputValue.value = $event),
          ref_key: "htmlInput",
          ref: htmlInput,
          class: ["va-pagination__input va-button", unref75(inputClassComputed)],
          "aria-label": unref75(tp)(_ctx.$props.ariaGoToSpecificPageInputLabel),
          style: inputStyleComputed.value
        }, inputAttributesComputed.value, {
          onKeydown: withKeys19(changeValue, ["enter"]),
          onFocus: focusInput,
          onBlur: changeValue
        }), null, 16, _hoisted_222)), [
          [vModelDynamic3, inputValue.value]
        ]),
        showDirectionLinks.value ? renderSlot67(_ctx.$slots, "nextPageLink", normalizeProps29(mergeProps39({ key: 4 }, { onClick: goNextPage, disabled: _ctx.$props.disabled || currentValue.value === lastPage.value })), () => [
          showDirectionLinks.value ? (openBlock82(), createBlock40(unref75(VaButton), mergeProps39({
            key: 0,
            "aria-label": unref75(tp)(_ctx.$props.ariaGoToNextPageLabel),
            disabled: _ctx.$props.disabled || currentValue.value === lastPage.value,
            icon: _ctx.$props.directionIconRight
          }, buttonPropsComputed.value, { onClick: goNextPage }), null, 16, ["aria-label", "disabled", "icon"])) : createCommentVNode41("", true)
        ]) : createCommentVNode41("", true),
        showBoundaryLinks.value ? renderSlot67(_ctx.$slots, "lastPageLink", normalizeProps29(mergeProps39({ key: 5 }, { onClick: () => onUserInput(lastPage.value), disabled: _ctx.$props.disabled || currentValue.value === lastPage.value })), () => [
          showBoundaryLinks.value ? (openBlock82(), createBlock40(unref75(VaButton), mergeProps39({
            key: 0,
            "aria-label": unref75(tp)(_ctx.$props.ariaGoToLastPageLabel),
            disabled: _ctx.$props.disabled || currentValue.value === lastPage.value,
            icon: _ctx.$props.boundaryIconRight
          }, buttonPropsComputed.value, {
            onClick: _cache[2] || (_cache[2] = ($event) => onUserInput(lastPage.value))
          }), null, 16, ["aria-label", "disabled", "icon"])) : createCommentVNode41("", true)
        ]) : createCommentVNode41("", true)
      ], 42, _hoisted_148)) : createCommentVNode41("", true);
    };
  }
});

// node_modules/vuestic-ui/dist/es/src/components/va-pagination/index.js
var VaPagination = withConfigTransport$1(_sfc_main85);

// node_modules/vuestic-ui/dist/es/src/components/va-parallax/VaParallax.vue_vue_type_script_setup_true_lang.js
import { defineComponent as defineComponent85, shallowRef as shallowRef26, ref as ref59, computed as computed153, onMounted as onMounted27, onBeforeUnmount as onBeforeUnmount20, openBlock as openBlock83, createElementBlock as createElementBlock72, normalizeStyle as normalizeStyle43, createElementVNode as createElementVNode39, renderSlot as renderSlot68 } from "vue";

// node_modules/vuestic-ui/dist/es/src/composables/useScrollParent.js
var useScrollParent = () => {
  const window2 = useWindow();
  const fakeWindow = new Proxy(window2.value || {}, {
    get: (target, key, rec) => {
      var _a2, _b;
      if (key === "scrollTop") {
        return (_a2 = window2.value) == null ? void 0 : _a2.scrollY;
      }
      if (key === "scrollLeft") {
        return (_b = window2.value) == null ? void 0 : _b.scrollX;
      }
      const value = Reflect.get(target, key, rec);
      if (typeof value === "function") {
        return value.bind(target);
      }
      return value;
    }
  });
  const getScrollableParent = (element) => {
    if (!element) {
      return fakeWindow;
    }
    if (element.scrollHeight > element.clientHeight) {
      return element;
    }
    return getScrollableParent(element.parentElement);
  };
  return { getScrollableParent };
};

// node_modules/vuestic-ui/dist/es/src/components/va-parallax/VaParallax.vue_vue_type_script_setup_true_lang.js
import "D:/Desktop/forntend/Front_End_Web_Hotel_Nhom_2/my-nuxt-app/node_modules/vuestic-ui/dist/es/VaParallax.css";
var _hoisted_149 = { class: "va-parallax__image-container" };
var _hoisted_223 = ["src", "alt"];
var _hoisted_316 = { class: "va-parallax__item-container" };
var _sfc_main86 = defineComponent85({
  ...{
    name: "VaParallax"
  },
  __name: "VaParallax",
  props: {
    ...useComponentPresetProp,
    target: { type: [Object, String] },
    src: { type: String, default: "", required: true },
    alt: { type: String, default: "parallax" },
    height: { type: [Number, String], default: 400 },
    reversed: { type: Boolean, default: false },
    speed: {
      type: [Number, String],
      default: 0.5,
      validator: (value) => {
        const num = Number(value);
        return num >= 0 && num <= 1;
      }
    }
  },
  setup(__props) {
    const props = __props;
    const rootElement = shallowRef26();
    const img = shallowRef26();
    const elOffsetTop = ref59(0);
    const parallax = ref59(0);
    const parallaxDist = ref59(0);
    const percentScrolled = ref59(0);
    const scrollTop = ref59(0);
    const windowHeight = ref59(0);
    const windowBottom = ref59(0);
    const isLoaded = ref59(false);
    const computedWrapperStyles = computed153(() => ({ height: heightComputed.value + "px" }));
    const computedImgStyles = computed153(() => ({
      display: "block",
      transform: `translate(-50%, ${parallax.value}px)`,
      opacity: isLoaded.value ? 1 : 0,
      top: props.reversed ? 0 : "auto"
    }));
    const { getScrollableParent } = useScrollParent();
    const targetElement = computed153(() => {
      var _a2;
      if (!props.target) {
        return getScrollableParent((_a2 = rootElement.value) == null ? void 0 : _a2.parentElement);
      }
      if (props.target instanceof HTMLElement) {
        return props.target;
      }
      const element = document.querySelector(props.target);
      if (element) {
        return element;
      }
      warn("VaParallax target prop got wrong selector. Target is null");
      return null;
    });
    const imgHeight = computed153(() => {
      var _a2;
      return ((_a2 = img.value) == null ? void 0 : _a2.naturalHeight) || 0;
    });
    const heightComputed = useNumericProp("height");
    const speedComputed = useNumericProp("speed");
    const calcDimensions = () => {
      var _a2, _b;
      const offset2 = ((_a2 = rootElement.value) == null ? void 0 : _a2.getBoundingClientRect()) || { top: 0 };
      scrollTop.value = ((_b = targetElement.value) == null ? void 0 : _b.scrollTop) || 0;
      parallaxDist.value = imgHeight.value - heightComputed.value;
      elOffsetTop.value = offset2.top + scrollTop.value;
      windowHeight.value = window.innerHeight;
      windowBottom.value = scrollTop.value + windowHeight.value;
    };
    const translate = () => {
      calcDimensions();
      percentScrolled.value = (windowBottom.value - elOffsetTop.value) / (heightComputed.value + windowHeight.value);
      parallax.value = Math.round(parallaxDist.value * percentScrolled.value) * speedComputed.value;
      if (props.reversed) {
        parallax.value = -parallax.value;
      }
    };
    const addEventListeners = () => {
      var _a2, _b;
      (_a2 = targetElement.value) == null ? void 0 : _a2.addEventListener("scroll", translate);
      (_b = targetElement.value) == null ? void 0 : _b.addEventListener("resize", translate);
    };
    const removeEventListeners = () => {
      var _a2, _b;
      (_a2 = targetElement.value) == null ? void 0 : _a2.removeEventListener("scroll", translate);
      (_b = targetElement.value) == null ? void 0 : _b.removeEventListener("resize", translate);
    };
    const initImage = () => {
      var _a2, _b;
      if ((_a2 = img.value) == null ? void 0 : _a2.complete) {
        translate();
        addEventListeners();
      } else {
        (_b = img.value) == null ? void 0 : _b.addEventListener("load", () => {
          translate();
          addEventListeners();
        }, false);
      }
      isLoaded.value = true;
    };
    onMounted27(initImage);
    onBeforeUnmount20(removeEventListeners);
    return (_ctx, _cache) => {
      return openBlock83(), createElementBlock72("div", {
        ref_key: "rootElement",
        ref: rootElement,
        class: "va-parallax",
        style: normalizeStyle43(computedWrapperStyles.value)
      }, [
        createElementVNode39("div", _hoisted_149, [
          createElementVNode39("img", {
            ref_key: "img",
            ref: img,
            class: "va-parallax__image",
            src: _ctx.$props.src,
            alt: _ctx.$props.alt,
            style: normalizeStyle43(computedImgStyles.value)
          }, null, 12, _hoisted_223)
        ]),
        createElementVNode39("div", _hoisted_316, [
          renderSlot68(_ctx.$slots, "default")
        ])
      ], 4);
    };
  }
});

// node_modules/vuestic-ui/dist/es/src/components/va-parallax/index.js
var VaParallax = withConfigTransport$1(_sfc_main86);

// node_modules/vuestic-ui/dist/es/src/components/va-popover/VaPopover.vue_vue_type_script_setup_true_lang.js
import { defineComponent as defineComponent86, useSlots as useSlots11, computed as computed154, openBlock as openBlock84, createBlock as createBlock41, unref as unref76, mergeProps as mergeProps40, withCtx as withCtx46, createElementVNode as createElementVNode40, normalizeStyle as normalizeStyle44, createElementBlock as createElementBlock73, renderSlot as renderSlot69, createVNode as createVNode34, createCommentVNode as createCommentVNode42, createTextVNode as createTextVNode25, toDisplayString as toDisplayString31 } from "vue";
import "D:/Desktop/forntend/Front_End_Web_Hotel_Nhom_2/my-nuxt-app/node_modules/vuestic-ui/dist/es/VaPopover.css";
var _hoisted_150 = {
  key: 0,
  "aria-hidden": "true",
  class: "va-popover__icon"
};
var _hoisted_224 = { key: 1 };
var _hoisted_317 = {
  key: 0,
  class: "va-popover__title"
};
var _hoisted_49 = {
  key: 1,
  class: "va-popover__body"
};
var VaDropdownProps3 = extractComponentProps(VaDropdown, ["closeOnClickOutside"]);
var _sfc_main87 = defineComponent86({
  ...{
    name: "VaPopover"
  },
  __name: "VaPopover",
  props: {
    ...VaDropdownProps3,
    ...useComponentPresetProp,
    trigger: { ...VaDropdownProps3.trigger, default: ["hover", "enter", "space", "arrow-down", "arrow-up"] },
    color: { type: String, default: "#1b1a1f" },
    // TODO: Make sure add this color to pallete
    textColor: { type: String },
    icon: { type: String, default: "" },
    title: { type: String, default: "" },
    message: { type: String, default: "" },
    autoHide: { type: Boolean, default: true },
    offset: { type: [Array, Number], default: 4 },
    contentClass: { type: String, default: "" }
  },
  setup(__props) {
    const props = __props;
    const VaDropdownPropValues = filterComponentProps(VaDropdownProps3);
    const { getColor, getBoxShadowColor: getBoxShadowColor2 } = useColors();
    const slots = useSlots11();
    const { textColorComputed } = useTextColor(computed154(() => getColor(props.color)));
    const showIconComputed = computed154(() => props.icon || slots.icon);
    const showTitleComputed = computed154(() => props.title || slots.title);
    const showBodyComputed = computed154(() => props.message || slots.body);
    const showPopoverContentComputed = computed154(
      () => showTitleComputed.value || showBodyComputed.value
    );
    const computedPopoverStyle = computed154(() => ({
      boxShadow: `var(--va-popover-content-box-shadow) ${getBoxShadowColor2(getColor(props.color))}`,
      backgroundColor: getColor(props.color),
      color: textColorComputed.value
    }));
    return (_ctx, _cache) => {
      return openBlock84(), createBlock41(unref76(VaDropdown), mergeProps40(unref76(VaDropdownPropValues), {
        "model-value": _ctx.modelValue,
        "close-on-click-outside": __props.autoHide,
        offset: _ctx.$props.offset,
        "content-class": _ctx.$props.contentClass,
        class: "va-popover"
      }), {
        default: withCtx46(() => [
          createElementVNode40("div", {
            style: normalizeStyle44(computedPopoverStyle.value),
            class: "va-popover__content",
            role: "tooltip"
          }, [
            showIconComputed.value ? (openBlock84(), createElementBlock73("div", _hoisted_150, [
              renderSlot69(_ctx.$slots, "icon", {}, () => [
                createVNode34(unref76(VaIcon), {
                  name: _ctx.$props.icon,
                  color: unref76(textColorComputed)
                }, null, 8, ["name", "color"])
              ])
            ])) : createCommentVNode42("", true),
            showPopoverContentComputed.value ? (openBlock84(), createElementBlock73("div", _hoisted_224, [
              showTitleComputed.value ? (openBlock84(), createElementBlock73("div", _hoisted_317, [
                renderSlot69(_ctx.$slots, "title", {}, () => [
                  createTextVNode25(toDisplayString31(_ctx.$props.title), 1)
                ])
              ])) : createCommentVNode42("", true),
              showBodyComputed.value ? (openBlock84(), createElementBlock73("div", _hoisted_49, [
                renderSlot69(_ctx.$slots, "body", {}, () => [
                  createTextVNode25(toDisplayString31(_ctx.$props.message), 1)
                ])
              ])) : createCommentVNode42("", true)
            ])) : createCommentVNode42("", true)
          ], 4)
        ]),
        anchor: withCtx46(() => [
          renderSlot69(_ctx.$slots, "default")
        ]),
        _: 3
      }, 16, ["model-value", "close-on-click-outside", "offset", "content-class"]);
    };
  }
});

// node_modules/vuestic-ui/dist/es/src/components/va-popover/index.js
var VaPopover = withConfigTransport$1(_sfc_main87);

// node_modules/vuestic-ui/dist/es/src/components/va-rating/VaRating.vue_vue_type_script_setup_true_lang.js
import { defineComponent as defineComponent89, computed as computed158, openBlock as openBlock87, createElementBlock as createElementBlock76, normalizeClass as normalizeClass44, unref as unref79, createElementVNode as createElementVNode41, withKeys as withKeys21, Fragment as Fragment25, renderList as renderList20, createBlock as createBlock42, mergeProps as mergeProps41, withCtx as withCtx47, renderSlot as renderSlot71, normalizeProps as normalizeProps31, guardReactiveProps as guardReactiveProps26, createCommentVNode as createCommentVNode43, normalizeStyle as normalizeStyle46, toDisplayString as toDisplayString33 } from "vue";

// node_modules/vuestic-ui/dist/es/src/components/va-rating/hooks/useRating.js
import { ref as ref60, computed as computed155, getCurrentInstance as getCurrentInstance27 } from "vue";

// node_modules/vuestic-ui/dist/es/src/components/va-rating/types.js
var RatingValue = ((RatingValue2) => {
  RatingValue2[RatingValue2["EMPTY"] = 0] = "EMPTY";
  RatingValue2[RatingValue2["HALF"] = 0.5] = "HALF";
  RatingValue2[RatingValue2["FULL"] = 1] = "FULL";
  return RatingValue2;
})(RatingValue || {});

// node_modules/vuestic-ui/dist/es/src/components/va-rating/hooks/useRating.js
var getContext = () => {
  const instance = getCurrentInstance27();
  if (!instance) {
    throw new Error("useRating hooks must be used on top of setup function");
  }
  return {
    props: instance.props,
    emit: instance.emit
  };
};
var useRatingProps = {
  ...useStatefulProps,
  modelValue: { type: Number, default: 0 },
  clearable: { type: Boolean, default: false },
  hover: { type: Boolean, default: false }
};
var useRating = (props) => {
  const { emit } = getContext();
  const { isHovered, onMouseEnter, onMouseLeave } = useHover();
  const { valueComputed: modelValue } = useStateful(props, emit);
  const hoveredValue = ref60(0);
  const visibleValue = computed155(() => !props.disabled && !props.readonly && props.hover && isHovered.value ? hoveredValue.value : modelValue.value);
  const onItemValueUpdate = (itemIndex, newValue) => {
    const newModelValue = itemIndex + newValue;
    if (props.clearable) {
      if (modelValue.value === newModelValue) {
        modelValue.value = 0;
        return;
      }
    }
    modelValue.value = newModelValue;
  };
  const onItemHoveredValueUpdate = (itemIndex, newValue) => {
    if (!props.hover) {
      return;
    }
    hoveredValue.value = itemIndex + newValue;
  };
  const getItemValue = (itemIndex) => {
    const itemValue = visibleValue.value - itemIndex;
    return clamp(itemValue, RatingValue.EMPTY, RatingValue.FULL);
  };
  return {
    visibleValue,
    modelValue,
    hoveredValue,
    isHovered,
    onMouseEnter,
    onMouseLeave,
    onItemValueUpdate,
    onItemHoveredValueUpdate,
    getItemValue
  };
};

// node_modules/vuestic-ui/dist/es/src/components/va-rating/hooks/useVaRatingColors.js
import { computed as computed156 } from "vue";
var useVaRatingColorsProps = {
  unselectedColor: { type: String },
  color: { type: String, default: "primary" },
  modelValue: { type: Number }
};
var useVaRatingColors = (props) => {
  const { getColor, getFocusColor: getFocusColor2, getTextColor } = useColors();
  const computedColor = computed156(() => getColor(props.color));
  const backgroundColor = computed156(() => {
    if (props.unselectedColor) {
      return getColor(props.unselectedColor);
    }
    return getFocusColor2(getColor(props.color));
  });
  const backgroundComputed = computed156(() => {
    if (props.modelValue === RatingValue.HALF) {
      return `linear-gradient(90deg, ${computedColor.value} 50%, ${backgroundColor.value} 50%`;
    }
    if (props.modelValue === RatingValue.EMPTY) {
      return backgroundColor.value;
    }
    return computedColor.value;
  });
  const textColorComputed = computed156(() => {
    if (props.modelValue === RatingValue.FULL) {
      return getColor(getTextColor(computedColor.value));
    }
    return getColor(getTextColor(backgroundColor.value));
  });
  return {
    computedColor,
    backgroundComputed,
    textColorComputed
  };
};

// node_modules/vuestic-ui/dist/es/src/components/va-rating/components/VaRatingItem/VaRatingItem.vue_vue_type_script_setup_true_lang.js
import { defineComponent as defineComponent87, shallowRef as shallowRef27, ref as ref61, computed as computed157, watch as watch46, openBlock as openBlock85, createElementBlock as createElementBlock74, withKeys as withKeys20, withModifiers as withModifiers17, renderSlot as renderSlot70, normalizeProps as normalizeProps30, guardReactiveProps as guardReactiveProps25, createVNode as createVNode35, unref as unref77 } from "vue";
import "D:/Desktop/forntend/Front_End_Web_Hotel_Nhom_2/my-nuxt-app/node_modules/vuestic-ui/dist/es/VaRatingItem.css";
var _hoisted_151 = ["tabindex", "onKeydown"];
var _sfc_main88 = defineComponent87({
  ...{
    name: "VaRatingItem"
  },
  __name: "VaRatingItem",
  props: {
    modelValue: { type: Number, default: 0 },
    icon: { type: String, default: "star" },
    halfIcon: { type: String, default: "star_half" },
    emptyIcon: { type: String, default: "star_outline" },
    halves: { type: Boolean, default: false },
    hover: { type: Boolean, default: false },
    tabindex: { type: [String, Number], default: 0 },
    disabled: { type: Boolean, default: false },
    readonly: { type: Boolean, default: false },
    size: { type: [String, Number], default: "medium" },
    unselectedColor: { type: String },
    color: { type: String, default: "primary" }
  },
  emits: ["update:modelValue", "click", "hover"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const rootEl = shallowRef27();
    const [modelValue] = useSyncProp("modelValue", props, emit, RatingValue.EMPTY);
    const hoveredValue = ref61(null);
    const visibleValue = computed157(() => {
      if (props.hover && !props.disabled && !props.readonly) {
        return hoveredValue.value || modelValue.value;
      }
      return modelValue.value;
    });
    const { getColor } = useColors();
    const computedColor = computed157(() => getColor(
      props.unselectedColor && visibleValue.value === RatingValue.EMPTY ? props.unselectedColor : props.color
    ));
    const onMouseMove = (ev) => {
      if (!rootEl.value) {
        return;
      }
      const { offsetX } = ev;
      const iconWidth = rootEl.value.clientWidth;
      if (props.halves) {
        hoveredValue.value = offsetX / iconWidth <= RatingValue.HALF ? RatingValue.HALF : RatingValue.FULL;
      } else {
        hoveredValue.value = RatingValue.FULL;
      }
    };
    const onMouseLeave = () => {
      hoveredValue.value = null;
    };
    const onClick = () => {
      modelValue.value = hoveredValue.value || RatingValue.FULL;
      emit("click", hoveredValue.value || RatingValue.FULL);
    };
    watch46(hoveredValue, () => emit("hover", hoveredValue.value || RatingValue.EMPTY));
    const computedIconName = computed157(() => {
      if (props.halves && visibleValue.value === RatingValue.HALF) {
        return props.halfIcon;
      }
      if (visibleValue.value === RatingValue.EMPTY) {
        return props.emptyIcon;
      }
      return props.icon;
    });
    const tabIndexComputed = computed157(() => props.disabled ? -1 : props.tabindex);
    return (_ctx, _cache) => {
      return openBlock85(), createElementBlock74("div", {
        ref_key: "rootEl",
        ref: rootEl,
        role: "button",
        class: "va-rating-item",
        tabindex: tabIndexComputed.value,
        onKeydown: [
          withKeys20(onClick, ["enter"]),
          withKeys20(withModifiers17(onClick, ["prevent"]), ["space"])
        ],
        onMousemove: onMouseMove,
        onMouseleave: onMouseLeave,
        onClick
      }, [
        renderSlot70(_ctx.$slots, "default", normalizeProps30(guardReactiveProps25({ value: visibleValue.value, onClick })), () => [
          createVNode35(unref77(VaIcon), {
            class: "va-rating-item__wrapper",
            tabindex: "-1",
            tag: "button",
            name: computedIconName.value,
            size: _ctx.$props.size,
            color: computedColor.value
          }, null, 8, ["name", "size", "color"])
        ])
      ], 40, _hoisted_151);
    };
  }
});

// node_modules/vuestic-ui/dist/es/src/components/va-rating/components/VaRatingItemNumberButton.vue_vue_type_script_setup_true_lang.js
import { defineComponent as defineComponent88, openBlock as openBlock86, createElementBlock as createElementBlock75, normalizeStyle as normalizeStyle45, unref as unref78, toDisplayString as toDisplayString32 } from "vue";
var _sfc_main89 = defineComponent88({
  ...{
    name: "VaRatingItemNumberButton"
  },
  __name: "VaRatingItemNumberButton",
  props: {
    ...useVaRatingColorsProps,
    ...useSizeProps,
    itemNumber: { type: Number, required: true },
    modelValue: { type: Number, required: true }
  },
  setup(__props) {
    const props = __props;
    const {
      textColorComputed,
      backgroundComputed
    } = useVaRatingColors(props);
    const {
      sizeComputed,
      fontSizeComputed,
      fontSizeInRem
    } = useSize(props, "VaRating");
    return (_ctx, _cache) => {
      return openBlock86(), createElementBlock75("button", {
        class: "va-rating__number-item",
        tabindex: "-1",
        "aria-hidden": "true",
        style: normalizeStyle45({
          background: unref78(backgroundComputed),
          color: unref78(textColorComputed),
          width: unref78(sizeComputed),
          height: unref78(sizeComputed),
          fontSize: unref78(fontSizeComputed),
          borderRadius: `${parseInt(unref78(fontSizeComputed)) * 0.125}rem`
        })
      }, toDisplayString32(__props.itemNumber), 5);
    };
  }
});

// node_modules/vuestic-ui/dist/es/src/components/va-rating/VaRating.vue_vue_type_script_setup_true_lang.js
import "D:/Desktop/forntend/Front_End_Web_Hotel_Nhom_2/my-nuxt-app/node_modules/vuestic-ui/dist/es/VaRating.css";
var _hoisted_152 = ["aria-label"];
var VaRatingItemPropsDeclarations = extractComponentProps(_sfc_main88, ["modelValue", "itemNumber"]);
var VaRatingItemNumberButtonPropsDeclarations = extractComponentProps(_sfc_main89, ["modelValue", "itemNumber"]);
var _sfc_main90 = defineComponent89({
  ...{
    name: "VaRating"
  },
  __name: "VaRating",
  props: {
    ...VaRatingItemNumberButtonPropsDeclarations,
    ...useRatingProps,
    ...useVaRatingColorsProps,
    ...useFormFieldProps,
    ...VaRatingItemPropsDeclarations,
    ...useComponentPresetProp,
    modelValue: { type: Number, default: 0 },
    numbers: { type: Boolean, default: false },
    halves: { type: Boolean, default: false },
    max: { type: [Number, String], default: 5 },
    texts: { type: Array, default: () => [] },
    ariaLabel: useTranslationProp("$t:currentRating"),
    ariaItemLabel: useTranslationProp("$t:voteRating")
  },
  emits: ["update:modelValue"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const { computedClasses: rootClass } = useFormField("va-rating", props);
    const {
      visibleValue,
      modelValue: vModel,
      hoveredValue,
      isHovered,
      onMouseEnter,
      onMouseLeave,
      onItemValueUpdate,
      onItemHoveredValueUpdate,
      getItemValue
    } = useRating(props);
    const isInteractionsEnabled = computed158(() => !props.disabled && !props.readonly);
    const onArrowKeyPress = (direction) => {
      const max = Number(props.max);
      const step = props.halves ? RatingValue.HALF : RatingValue.FULL;
      const nextStep = visibleValue.value + step * direction;
      const min = props.clearable ? 0 : step;
      if (nextStep >= min && nextStep <= max) {
        onItemValueUpdate(visibleValue.value, step * direction);
      } else if (nextStep < min) {
        onItemValueUpdate(min, 0);
      } else {
        onItemValueUpdate(max, direction === -1 ? step * direction : 0);
      }
    };
    const { tp, t } = useTranslation();
    const {
      computedColor,
      backgroundComputed,
      textColorComputed
    } = useVaRatingColors(props);
    const tabIndexComputed = computed158(() => isInteractionsEnabled.value ? 0 : void 0);
    const VaRatingItemProps = filterComponentProps(VaRatingItemPropsDeclarations);
    const VaRatingItemNumberButtonProps = filterComponentProps(VaRatingItemNumberButtonPropsDeclarations);
    return (_ctx, _cache) => {
      return openBlock87(), createElementBlock76("div", {
        class: normalizeClass44(["va-rating", unref79(rootClass)]),
        "aria-label": unref79(tp)(_ctx.$props.ariaLabel, { max: _ctx.$props.max, value: _ctx.$props.modelValue })
      }, [
        createElementVNode41("div", {
          class: "va-rating__item-wrapper",
          onKeyup: [
            _cache[0] || (_cache[0] = withKeys21(($event) => onArrowKeyPress(-1), ["left"])),
            _cache[1] || (_cache[1] = withKeys21(($event) => onArrowKeyPress(1), ["right"]))
          ],
          onMouseenter: _cache[2] || (_cache[2] = //@ts-ignore
          (...args) => unref79(onMouseEnter) && unref79(onMouseEnter)(...args)),
          onMouseleave: _cache[3] || (_cache[3] = //@ts-ignore
          (...args) => unref79(onMouseLeave) && unref79(onMouseLeave)(...args))
        }, [
          (openBlock87(true), createElementBlock76(Fragment25, null, renderList20(Number(_ctx.$props.max), (itemNumber) => {
            return openBlock87(), createBlock42(_sfc_main88, mergeProps41({
              key: itemNumber,
              class: "va-rating__item"
            }, unref79(VaRatingItemProps), {
              "aria-label": unref79(tp)(_ctx.$props.ariaItemLabel, { max: _ctx.$props.max, value: itemNumber }),
              "model-value": unref79(getItemValue)(itemNumber - 1),
              tabindex: tabIndexComputed.value,
              disabled: _ctx.$props.disabled,
              readonly: _ctx.$props.readonly,
              onHover: ($event) => isInteractionsEnabled.value && unref79(onItemHoveredValueUpdate)(itemNumber - 1, $event),
              "onUpdate:modelValue": ($event) => isInteractionsEnabled.value && unref79(onItemValueUpdate)(itemNumber - 1, $event)
            }), {
              default: withCtx47(({ value, onClick }) => [
                renderSlot71(_ctx.$slots, "item", normalizeProps31(guardReactiveProps26({ value, onClick, index: itemNumber })), () => [
                  _ctx.$props.numbers ? (openBlock87(), createBlock42(_sfc_main89, mergeProps41({ key: 0 }, unref79(VaRatingItemNumberButtonProps), {
                    "model-value": value,
                    "item-number": itemNumber
                  }), null, 16, ["model-value", "item-number"])) : createCommentVNode43("", true)
                ])
              ]),
              _: 2
            }, 1040, ["aria-label", "model-value", "tabindex", "disabled", "readonly", "onHover", "onUpdate:modelValue"]);
          }), 128))
        ], 32),
        _ctx.$props.texts && _ctx.$props.texts.length === _ctx.$props.max ? (openBlock87(), createElementBlock76("span", {
          key: 0,
          class: "va-rating__text-wrapper",
          style: normalizeStyle46({ color: unref79(computedColor) })
        }, toDisplayString33(_ctx.$props.texts[Math.round(unref79(visibleValue)) - 1]), 5)) : createCommentVNode43("", true)
      ], 10, _hoisted_152);
    };
  }
});

// node_modules/vuestic-ui/dist/es/src/components/va-rating/index.js
var VaRating = withConfigTransport$1(_sfc_main90);

// node_modules/vuestic-ui/dist/es/src/components/va-select/VaSelect.vue_vue_type_script_setup_true_lang.js
import { defineComponent as defineComponent93, shallowRef as shallowRef30, computed as computed165, watch as watch51, ref as ref65, nextTick as nextTick11, useSlots as useSlots12, openBlock as openBlock91, createBlock as createBlock46, unref as unref83, mergeProps as mergeProps44, withCtx as withCtx49, createVNode as createVNode37, createSlots as createSlots7, withModifiers as withModifiers20, withKeys as withKeys24, createCommentVNode as createCommentVNode47, renderList as renderList23, renderSlot as renderSlot75, normalizeProps as normalizeProps34, guardReactiveProps as guardReactiveProps29, normalizeStyle as normalizeStyle48, isRef as isRef9 } from "vue";

// node_modules/vuestic-ui/dist/es/src/components/va-select/components/VaSelectOptionList/VaSelectOptionList.vue_vue_type_script_setup_true_lang.js
import { defineComponent as defineComponent91, shallowRef as shallowRef29, computed as computed160, ref as ref62, watch as watch47, openBlock as openBlock89, createElementBlock as createElementBlock78, withKeys as withKeys22, withModifiers as withModifiers18, Fragment as Fragment26, renderList as renderList21, unref as unref81, toDisplayString as toDisplayString35, createCommentVNode as createCommentVNode45, createBlock as createBlock44, withCtx as withCtx48, renderSlot as renderSlot73, normalizeProps as normalizeProps32, guardReactiveProps as guardReactiveProps27, createVNode as createVNode36, mergeProps as mergeProps42 } from "vue";

// node_modules/vuestic-ui/dist/es/src/utils/scroll-to-element.js
var getTopCoordinate = (element) => element.offsetTop;
var getBottomCoordinate = (element) => element.offsetTop + element.offsetHeight;
var getCenterCoordinate = (element) => element.offsetTop + element.offsetHeight / 2;
var getScrollTop = (element, scrollTarget, verticalAlignment) => {
  const viewHeight = scrollTarget.offsetHeight;
  const currentPosition = scrollTarget.scrollTop;
  const top = getTopCoordinate(element) - scrollTarget.offsetTop;
  const center = getCenterCoordinate(element) - scrollTarget.offsetTop;
  const bottom = getBottomCoordinate(element) - scrollTarget.offsetTop;
  if (verticalAlignment === "start") {
    return top;
  }
  if (verticalAlignment === "end") {
    return bottom - viewHeight;
  }
  if (verticalAlignment === "center") {
    return center - viewHeight / 2;
  }
  if (verticalAlignment === "any") {
    if (top - currentPosition < 0) {
      return top;
    }
    if (bottom - currentPosition > viewHeight) {
      return bottom - viewHeight;
    }
  }
};
var scrollToElement = (element, options = {
  scrollTarget: element.parentElement,
  verticalAlignment: "any",
  smooth: false
}) => {
  const scrollTarget = options.scrollTarget || element.parentElement;
  const top = getScrollTop(element, scrollTarget, options.verticalAlignment);
  if (top === void 0) {
    return;
  }
  scrollTarget.scroll({
    top,
    behavior: options.smooth ? "smooth" : "auto"
  });
};

// node_modules/vuestic-ui/dist/es/src/components/va-select/components/VaSelectOption/VaSelectOption.vue_vue_type_script_setup_true_lang.js
import { defineComponent as defineComponent90, computed as computed159, openBlock as openBlock88, createElementBlock as createElementBlock77, normalizeClass as normalizeClass45, unref as unref80, normalizeStyle as normalizeStyle47, renderSlot as renderSlot72, createBlock as createBlock43, createCommentVNode as createCommentVNode44, createTextVNode as createTextVNode26, toDisplayString as toDisplayString34 } from "vue";
import "D:/Desktop/forntend/Front_End_Web_Hotel_Nhom_2/my-nuxt-app/node_modules/vuestic-ui/dist/es/VaSelectOption.css";
var _hoisted_153 = ["aria-selected"];
var _hoisted_225 = {
  key: 1,
  class: "va-select-option__highlighted"
};
var _sfc_main91 = defineComponent90({
  ...{
    name: "VaSelectOption"
  },
  __name: "VaSelectOption",
  props: {
    ...useColorProps,
    disabled: { type: Boolean, default: false },
    option: { type: [Number, String, Boolean, Object], default: () => ({}) },
    getText: { type: Function, required: true },
    getTrackBy: { type: Function, required: true },
    currentOption: { type: [String, Number, Boolean, Object], default: null },
    getSelectedState: { type: Function, required: true },
    search: { type: String, default: "" },
    highlightMatchedText: { type: Boolean, default: true },
    inputFocused: { type: Boolean, default: false },
    minSearchChars: { type: [Number, String], default: 0 }
  },
  setup(__props, { expose: __expose }) {
    const props = __props;
    const { getColor, getHoverColor: getHoverColor2 } = useColors();
    const minSearchCharsComputed = useNumericProp("minSearchChars");
    const optionIcon = computed159(() => isObject(props.option) ? props.option.icon : void 0);
    const optionIconColor = computed159(() => getColor(props.color));
    const optionText = computed159(() => props.getText(props.option));
    const optionTextSplitted = computed159(() => {
      const defaultSplit = { start: optionText.value, searchedSubString: "", end: "" };
      if (!optionText.value || !props.search || !props.highlightMatchedText || props.search.length < minSearchCharsComputed.value) {
        return defaultSplit;
      }
      const substringStartIndex = optionText.value.toLowerCase().indexOf(props.search.toLowerCase());
      if (substringStartIndex < 0) {
        return defaultSplit;
      }
      const start = optionText.value.slice(0, substringStartIndex);
      const searchedSubString = optionText.value.slice(substringStartIndex, substringStartIndex + props.search.length);
      const end = optionText.value.slice(substringStartIndex + props.search.length);
      return { start, searchedSubString, end };
    });
    const isSelected = computed159(() => props.getSelectedState(props.option));
    const isFocused = computed159(() => {
      if (typeof props.option === "string") {
        return props.option === props.currentOption;
      }
      return props.getTrackBy(props.currentOption) === props.getTrackBy(props.option);
    });
    const optionClass = useBem("va-select-option", () => ({
      selected: isSelected.value
    }));
    const optionStyle = computed159(() => ({
      color: isSelected.value ? getColor(props.color) : "inherit",
      backgroundColor: isFocused.value ? getHoverColor2(getColor(props.color)) : "transparent",
      cursor: props.disabled ? "default" : void 0,
      opacity: props.disabled ? "var(--va-select-option-list-option-disabled-opacity)" : void 0
    }));
    __expose({
      isFocused,
      isSelected
    });
    return (_ctx, _cache) => {
      return openBlock88(), createElementBlock77("div", {
        role: "option",
        class: normalizeClass45(["va-select-option", unref80(optionClass)]),
        style: normalizeStyle47(optionStyle.value),
        "aria-selected": isSelected.value
      }, [
        renderSlot72(_ctx.$slots, "option-content", {}, () => [
          optionIcon.value ? (openBlock88(), createBlock43(unref80(VaIcon), {
            key: 0,
            size: "small",
            class: "va-select-option__icon",
            name: optionIcon.value
          }, null, 8, ["name"])) : createCommentVNode44("", true),
          createTextVNode26(" " + toDisplayString34(optionTextSplitted.value.start) + " ", 1),
          optionTextSplitted.value.searchedSubString ? (openBlock88(), createElementBlock77("span", _hoisted_225, toDisplayString34(optionTextSplitted.value.searchedSubString), 1)) : createCommentVNode44("", true),
          createTextVNode26(" " + toDisplayString34(optionTextSplitted.value.end), 1)
        ]),
        isSelected.value ? (openBlock88(), createBlock43(unref80(VaIcon), {
          key: 0,
          class: "va-select-option__selected-icon",
          size: "small",
          name: "va-check",
          color: optionIconColor.value
        }, null, 8, ["color"])) : createCommentVNode44("", true)
      ], 14, _hoisted_153);
    };
  }
});

// node_modules/vuestic-ui/dist/es/src/components/va-select/components/VaSelectOption/index.js
var VaSelectOption = withConfigTransport$1(_sfc_main91);

// node_modules/vuestic-ui/dist/es/src/composables/useObjectRefs.js
import { shallowRef as shallowRef28, onBeforeUpdate as onBeforeUpdate2 } from "vue";
var useObjectRefs = () => {
  const itemRefs = shallowRef28({});
  const setItemRef = (key) => (el) => {
    if (!el) {
      return;
    }
    itemRefs.value[key] = el;
    return String(key);
  };
  onBeforeUpdate2(() => {
    itemRefs.value = {};
  });
  return { itemRefs, setItemRef };
};

// node_modules/vuestic-ui/dist/es/src/components/va-select/components/VaSelectOptionList/VaSelectOptionList.vue_vue_type_script_setup_true_lang.js
import "D:/Desktop/forntend/Front_End_Web_Hotel_Nhom_2/my-nuxt-app/node_modules/vuestic-ui/dist/es/VaSelectOptionList.css";
var _hoisted_154 = ["tabindex", "onKeydown", "aria-multiselectable"];
var _hoisted_226 = {
  key: 0,
  class: "va-select-option-list__group-name",
  role: "presentation"
};
var _hoisted_318 = {
  key: 0,
  class: "va-select-option-list--empty"
};
var _sfc_main92 = defineComponent91({
  ...{
    name: "VaSelectOptionList"
  },
  __name: "VaSelectOptionList",
  props: {
    ...useColorProps,
    ...useComponentPresetProp,
    ...useSelectableListProps,
    ...useThrottleProps,
    noOptionsText: { type: String, default: "Items not found" },
    getSelectedState: { type: Function, required: true },
    multiple: { type: Boolean, default: false },
    search: { type: String, default: "" },
    tabindex: { type: [String, Number], default: 0 },
    hoveredOption: { type: [String, Number, Boolean, Object], default: null },
    virtualScroller: { type: Boolean, default: true },
    highlightMatchedText: { type: Boolean, default: true },
    minSearchChars: { type: [Number, String], default: 0 },
    autoSelectFirstOption: { type: Boolean, default: false },
    selectedTopShown: { type: Boolean, default: false },
    doShowAllOptions: { type: Boolean, default: false },
    searchFn: { type: Function, default: void 0 }
  },
  emits: [
    "select-option",
    "update:hoveredOption",
    "no-previous-option-to-hover",
    "scroll-bottom"
  ],
  setup(__props, { expose: __expose, emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const root = shallowRef29();
    const focus = () => {
      var _a2;
      (_a2 = root.value) == null ? void 0 : _a2.focus({ preventScroll: true });
    };
    const rootHeight = computed160(() => {
      var _a2;
      return ((_a2 = root.value) == null ? void 0 : _a2.clientHeight) ?? 200;
    });
    const handleScrollToBottom = () => emit("scroll-bottom");
    const onScroll = (event) => {
      const target = event.target;
      if (!target) {
        return;
      }
      if (target.scrollTop + target.clientHeight === target.scrollHeight) {
        handleScrollToBottom();
      }
    };
    const lastInteractionSource = ref62("");
    const currentOptionComputed = computed160(() => props.hoveredOption ?? null);
    const updateCurrentOption = (option, source) => {
      emit("update:hoveredOption", option);
      lastInteractionSource.value = source;
    };
    const { getText, getGroupBy, getTrackBy, getDisabled } = useSelectableList(props);
    const minSearchCharsComputed = useNumericProp("minSearchChars");
    const currentSelectedOptionText = computed160(() => {
      var _a2;
      const getSelectedState = props.getSelectedState;
      const selected = (_a2 = props.options) == null ? void 0 : _a2.find((option) => getSelectedState(option));
      return selected ? getText(selected) : "";
    });
    const isSearchedOptionSelected = computed160(() => {
      var _a2;
      return currentSelectedOptionText.value.toLowerCase() === ((_a2 = props.search) == null ? void 0 : _a2.toLowerCase());
    });
    const filteredOptions = computed160(() => {
      if (props.doShowAllOptions && isSearchedOptionSelected.value) {
        return props.options;
      }
      if (!props.search || props.search.length < minSearchCharsComputed.value) {
        return props.options;
      }
      if (props.searchFn) {
        return props.options.filter((o) => props.searchFn(props.search, o));
      }
      const search = props.search.toUpperCase().trim();
      return props.options.filter((option) => {
        const optionText = getText(option).toUpperCase();
        return optionText.includes(search);
      });
    });
    const optionGroups = computed160(() => {
      if (!props.groupBy) {
        return { _noGroup: filteredOptions.value };
      }
      return filteredOptions.value.reduce((groups, option) => {
        const groupBy = getGroupBy(option);
        if (!groupBy) {
          groups._noGroup.push(option);
        } else {
          if (!groups[groupBy]) {
            groups[groupBy] = [];
          }
          groups[groupBy].push(option);
        }
        return groups;
      }, { _noGroup: [] });
    });
    const optionGroupsThrottled = useThrottleValue(optionGroups, props);
    const isValueExists = (value) => !isNilValue(value);
    const updateHoveredOption = (option) => {
      if (option === currentOptionComputed.value || isValueExists(option) && getDisabled(option)) {
        return;
      }
      updateCurrentOption(option ?? null, "mouse");
    };
    const updateFocusedOption = (option) => {
      updateCurrentOption(option ?? null, "keyboard");
    };
    const selectHoveredOption = () => {
      const previousOption = previousOptionComputed.value && typeof previousOptionComputed.value === "object" ? { ...previousOptionComputed.value } : previousOptionComputed.value;
      emit("select-option");
      if (props.selectedTopShown) {
        updateHoveredOption(previousOption);
      }
    };
    const groupedOptions = computed160(() => Object.values(optionGroupsThrottled.value).flat());
    const currentOptions = computed160(() => filteredOptions.value.some((el) => getGroupBy(el)) ? groupedOptions.value : filteredOptions.value);
    const currentOptionIndex = computed160(() => currentOptions.value.findIndex((option) => {
      return isValueExists(currentOptionComputed.value) && getTrackBy(option) === getTrackBy(currentOptionComputed.value);
    }));
    const selectOptionProps = computed160(() => ({
      ...pick(props, ["getSelectedState", "color", "search", "highlightMatchedText"]),
      minSearchChars: minSearchCharsComputed.value,
      getText,
      getTrackBy
    }));
    const findNextActiveOption = (startSearchIndex, reversedSearch = false) => {
      const searchBase = [...currentOptions.value || []];
      const searchBaseOrdered = reversedSearch ? searchBase.reverse() : searchBase;
      const startIndex = reversedSearch ? startSearchIndex * -1 - 1 : startSearchIndex;
      return searchBaseOrdered.slice(startIndex).find((option) => !getDisabled(option));
    };
    const previousOptionComputed = computed160(() => {
      const previousOptionIndex = currentOptionIndex.value - 1;
      const previousOption = currentOptions.value[previousOptionIndex];
      const previousOptionCheck = isValueExists(previousOption) && !(previousOptionIndex === 0 && getDisabled(previousOption));
      if (previousOptionCheck) {
        return findNextActiveOption(currentOptionIndex.value - 1, true);
      }
      return void 0;
    });
    const selectOption = (option) => {
      updateHoveredOption(option);
      emit("select-option");
    };
    const handleMouseMove = (option) => {
      if (!props.selectedTopShown) {
        updateHoveredOption(option);
      }
    };
    const handleMouseEnter = (option) => {
      if (props.selectedTopShown) {
        updateHoveredOption(option);
      }
    };
    const focusPreviousOption = () => {
      if (!isValueExists(currentOptionComputed.value)) {
        updateFocusedOption(findNextActiveOption(0, true));
        return;
      }
      if (isValueExists(previousOptionComputed.value)) {
        updateFocusedOption(previousOptionComputed.value);
      } else {
        emit("no-previous-option-to-hover");
      }
    };
    const focusNextOption = () => {
      if (!isValueExists(currentOptionComputed.value)) {
        focusFirstOption();
        return;
      }
      const nextOptionIndex = currentOptionIndex.value + 1;
      const nextOption = currentOptions.value[nextOptionIndex];
      const nextOptionCheck = isValueExists(nextOption) && !(nextOptionIndex === currentOptions.value.length - 1 && getDisabled(nextOption));
      if (nextOptionCheck) {
        updateFocusedOption(findNextActiveOption(currentOptionIndex.value + 1));
      }
    };
    const focusFirstOption = () => updateFocusedOption(findNextActiveOption(0));
    const { itemRefs, setItemRef } = useObjectRefs();
    const virtualScrollerRef = shallowRef29();
    const scrollToOption = (option) => {
      var _a2;
      if (!isValueExists(option)) {
        return;
      }
      const element = unwrapEl(itemRefs.value[getTrackBy(option)]);
      if (element) {
        scrollToElement(element);
      }
      const virtualScroller = (_a2 = virtualScrollerRef.value) == null ? void 0 : _a2[0];
      if (props.virtualScroller) {
        virtualScroller.virtualScrollTo(currentOptionIndex.value);
      }
    };
    watch47(() => props.hoveredOption, (newOption) => {
      (!lastInteractionSource.value || lastInteractionSource.value === "keyboard") && isValueExists(newOption) && scrollToOption(newOption);
    });
    watch47(filteredOptions, () => {
      if (!props.autoSelectFirstOption) {
        return;
      }
      focusFirstOption();
    }, { immediate: true });
    __expose({
      focusPreviousOption,
      focusNextOption,
      focusFirstOption,
      scrollToOption,
      focus
    });
    return (_ctx, _cache) => {
      return openBlock89(), createElementBlock78("div", {
        ref_key: "root",
        ref: root,
        class: "va-select-option-list",
        tabindex: __props.tabindex,
        onKeydown: [
          withKeys22(withModifiers18(focusPreviousOption, ["stop", "prevent"]), ["up"]),
          withKeys22(withModifiers18(focusPreviousOption, ["stop", "prevent"]), ["left"]),
          withKeys22(withModifiers18(focusNextOption, ["stop", "prevent"]), ["down"]),
          withKeys22(withModifiers18(focusNextOption, ["stop", "prevent"]), ["right"]),
          withKeys22(withModifiers18(selectHoveredOption, ["stop", "prevent"]), ["enter"]),
          withKeys22(withModifiers18(selectHoveredOption, ["stop", "prevent"]), ["space"])
        ],
        onScrollPassive: onScroll,
        role: "listbox",
        "aria-multiselectable": _ctx.$props.multiple
      }, [
        (openBlock89(true), createElementBlock78(Fragment26, null, renderList21(unref81(optionGroupsThrottled), (options, groupName) => {
          return openBlock89(), createElementBlock78(Fragment26, { key: groupName }, [
            groupName !== "_noGroup" ? (openBlock89(), createElementBlock78("span", _hoisted_226, toDisplayString35(groupName), 1)) : createCommentVNode45("", true),
            _ctx.$props.virtualScroller ? (openBlock89(), createBlock44(unref81(VaVirtualScroller), {
              key: 1,
              ref_for: true,
              ref_key: "virtualScrollerRef",
              ref: virtualScrollerRef,
              items: options,
              "track-by": unref81(getTrackBy),
              "wrapper-size": rootHeight.value,
              "onScroll:bottom": handleScrollToBottom
            }, {
              default: withCtx48(({ item: option, index }) => [
                renderSlot73(_ctx.$slots, "default", normalizeProps32(guardReactiveProps27({ option, index, selectOption: (o = option) => selectOption(o) })), () => [
                  createVNode36(unref81(VaSelectOption), mergeProps42({
                    option,
                    "current-option": currentOptionComputed.value,
                    disabled: unref81(getDisabled)(option)
                  }, selectOptionProps.value, {
                    onClick: withModifiers18(selectHoveredOption, ["stop"]),
                    onMouseenter: ($event) => handleMouseEnter(option),
                    onMousemove: ($event) => handleMouseMove(option)
                  }), null, 16, ["option", "current-option", "disabled", "onMouseenter", "onMousemove"])
                ])
              ]),
              _: 2
            }, 1032, ["items", "track-by", "wrapper-size"])) : (openBlock89(true), createElementBlock78(Fragment26, { key: 2 }, renderList21(options, (option, index) => {
              return renderSlot73(_ctx.$slots, "default", normalizeProps32(mergeProps42({
                key: unref81(getTrackBy)(option)
              }, { option, index, selectOption })), () => [
                createVNode36(unref81(VaSelectOption), mergeProps42({
                  ref_for: true,
                  ref: unref81(setItemRef)(unref81(getTrackBy)(option)),
                  "current-option": currentOptionComputed.value,
                  option,
                  disabled: unref81(getDisabled)(option)
                }, selectOptionProps.value, {
                  onClick: withModifiers18(selectHoveredOption, ["stop"]),
                  onMouseenter: ($event) => handleMouseEnter(option),
                  onMousemove: ($event) => handleMouseMove(option)
                }), {
                  "option-content": withCtx48(() => [
                    renderSlot73(_ctx.$slots, "option-content", normalizeProps32(guardReactiveProps27({ option, index })))
                  ]),
                  _: 2
                }, 1040, ["current-option", "option", "disabled", "onMouseenter", "onMousemove"])
              ]);
            }), 128))
          ], 64);
        }), 128)),
        !filteredOptions.value.length ? (openBlock89(), createElementBlock78("div", _hoisted_318, toDisplayString35(__props.noOptionsText), 1)) : createCommentVNode45("", true)
      ], 40, _hoisted_154);
    };
  }
});

// node_modules/vuestic-ui/dist/es/src/components/va-select/components/VaSelectOptionList/index.js
var VaSelectOptionList = withConfigTransport$1(_sfc_main92);

// node_modules/vuestic-ui/dist/es/src/components/va-select/components/VaSelectContent/VaSelectContent.vue_vue_type_script_setup_true_lang.js
import { defineComponent as defineComponent92, ref as ref63, computed as computed161, toRefs as toRefs9, onMounted as onMounted28, watch as watch48, openBlock as openBlock90, createElementBlock as createElementBlock79, createElementVNode as createElementVNode42, mergeProps as mergeProps43, renderSlot as renderSlot74, normalizeProps as normalizeProps33, Fragment as Fragment27, renderList as renderList22, guardReactiveProps as guardReactiveProps28, createBlock as createBlock45, unref as unref82, createCommentVNode as createCommentVNode46, createTextVNode as createTextVNode27, toDisplayString as toDisplayString36, withDirectives as withDirectives7, withKeys as withKeys23, withModifiers as withModifiers19, vModelDynamic as vModelDynamic4 } from "vue";
import "D:/Desktop/forntend/Front_End_Web_Hotel_Nhom_2/my-nuxt-app/node_modules/vuestic-ui/dist/es/VaSelectContent.css";
var _hoisted_155 = {
  key: 0,
  class: "va-select-content__placeholder"
};
var _hoisted_227 = ["placeholder"];
var _hoisted_319 = {
  key: 0,
  class: "va-select-content__option"
};
var _hoisted_410 = {
  key: 1,
  class: "va-select-content__separator"
};
var _hoisted_58 = ["placeholder", "disabled", "readonly"];
var _sfc_main93 = defineComponent92({
  ...{
    name: "VaSelectContent"
  },
  __name: "VaSelectContent",
  props: {
    ...useFormFieldProps,
    ariaAttributes: { type: Object },
    value: { type: Array, required: true },
    valueString: { type: String },
    separator: { type: String, default: ", " },
    placeholder: { type: String, default: "" },
    tabindex: { type: [String, Number], default: 0 },
    hiddenSelectedOptionsAmount: { type: [Number, String], default: 0 },
    isAllOptionsShown: { type: Boolean, default: false },
    autocomplete: { type: Boolean, default: false },
    focused: { type: Boolean, default: false },
    multiple: { type: Boolean, default: false },
    getText: { type: Function, required: true },
    autocompleteInputValue: { type: String, default: "" }
  },
  emits: ["toggle-hidden", "autocomplete-input", "focus-prev", "focus-next", "select-option", "delete-last-selected"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const autocompleteInput = ref63();
    const isPlaceholder = computed161(() => props.placeholder && !props.valueString);
    const toggleHiddenOptionsState = () => emit("toggle-hidden");
    const { value, focused } = toRefs9(props);
    const autocompleteInputValueComputed = computed161({
      get: () => props.autocompleteInputValue,
      set: (v) => emit("autocomplete-input", v)
    });
    const hiddenSelectedOptionsAmountComputed = useNumericProp("hiddenSelectedOptionsAmount");
    onMounted28(() => {
      if (props.multiple) {
        return;
      }
      if (!props.autocomplete) {
        return;
      }
      autocompleteInputValueComputed.value = props.valueString;
    });
    watch48(focused, (newValue) => {
      var _a2, _b;
      if (!props.autocomplete || !newValue) {
        return;
      }
      if (autocompleteInputValueComputed.value) {
        (_a2 = autocompleteInput.value) == null ? void 0 : _a2.setSelectionRange(0, autocompleteInputValueComputed.value.length);
      } else {
        (_b = autocompleteInput.value) == null ? void 0 : _b.focus();
      }
    });
    const handleBackspace = (e) => {
      if (props.multiple && value.value.length && e.key === "Backspace" && !autocompleteInputValueComputed.value) {
        emit("delete-last-selected");
      }
    };
    const handleClick = (e) => {
      var _a2;
      if (props.autocomplete) {
        (_a2 = autocompleteInput.value) == null ? void 0 : _a2.focus();
        e.stopPropagation();
      }
    };
    const getIcon = (option) => isObject(option) ? option.icon : void 0;
    const slotValue = computed161(() => {
      if (props.multiple) {
        return value.value;
      }
      return value.value[0];
    });
    return (_ctx, _cache) => {
      return openBlock90(), createElementBlock79("div", {
        class: "va-select-content",
        onClick: handleClick
      }, [
        isPlaceholder.value && !_ctx.$props.autocomplete ? (openBlock90(), createElementBlock79("span", _hoisted_155, [
          createElementVNode42("input", mergeProps43(__props.ariaAttributes, {
            placeholder: _ctx.$props.placeholder,
            readonly: ""
          }), null, 16, _hoisted_227)
        ])) : !(props.autocomplete && !props.multiple) ? renderSlot74(_ctx.$slots, "content", normalizeProps33(mergeProps43({ key: 1 }, {
          value: slotValue.value,
          valueString: _ctx.$props.valueString,
          valueArray: _ctx.$props.value,
          tabindex: _ctx.$props.tabindex,
          ariaAttributes: __props.ariaAttributes
        })), () => [
          (openBlock90(true), createElementBlock79(Fragment27, null, renderList22(_ctx.$props.value, (option, index) => {
            return openBlock90(), createElementBlock79(Fragment27, { key: index }, [
              option !== "" ? (openBlock90(), createElementBlock79("span", _hoisted_319, [
                renderSlot74(_ctx.$slots, "option-content", normalizeProps33(guardReactiveProps28({ option, index, selectOption: () => void 0 })), () => [
                  getIcon(option) ? (openBlock90(), createBlock45(unref82(VaIcon), {
                    key: 0,
                    size: "small",
                    class: "va-select-option__icon",
                    name: getIcon(option)
                  }, null, 8, ["name"])) : createCommentVNode46("", true),
                  createTextVNode27(" " + toDisplayString36(__props.getText(option)), 1)
                ])
              ])) : createCommentVNode46("", true),
              index < _ctx.$props.value.length - 1 ? (openBlock90(), createElementBlock79("span", _hoisted_410, toDisplayString36(_ctx.$props.separator), 1)) : createCommentVNode46("", true)
            ], 64);
          }), 128))
        ]) : createCommentVNode46("", true),
        _ctx.$props.autocomplete ? withDirectives7((openBlock90(), createElementBlock79("input", mergeProps43({ key: 2 }, __props.ariaAttributes, {
          "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => autocompleteInputValueComputed.value = $event),
          class: "va-select-content__autocomplete",
          ref_key: "autocompleteInput",
          ref: autocompleteInput,
          autocomplete: "off",
          "aria-autocomplete": "list",
          placeholder: _ctx.$props.placeholder,
          disabled: _ctx.$props.disabled,
          readonly: _ctx.$props.readonly,
          onKeydown: [
            _cache[1] || (_cache[1] = withKeys23(withModifiers19(($event) => _ctx.$emit("focus-prev"), ["stop", "prevent"]), ["up"])),
            _cache[2] || (_cache[2] = withKeys23(withModifiers19(($event) => _ctx.$emit("focus-next"), ["stop", "prevent"]), ["down"])),
            _cache[3] || (_cache[3] = withKeys23(withModifiers19(($event) => _ctx.$emit("select-option"), ["stop", "prevent"]), ["enter"])),
            handleBackspace
          ]
        }), null, 16, _hoisted_58)), [
          [vModelDynamic4, autocompleteInputValueComputed.value]
        ]) : createCommentVNode46("", true),
        renderSlot74(_ctx.$slots, "hiddenOptionsBadge", normalizeProps33(guardReactiveProps28({
          amount: __props.hiddenSelectedOptionsAmount,
          isShown: _ctx.$props.isAllOptionsShown,
          toggle: toggleHiddenOptionsState
        })), () => [
          unref82(hiddenSelectedOptionsAmountComputed) && !_ctx.$props.isAllOptionsShown ? (openBlock90(), createBlock45(unref82(VaBadge), {
            key: 0,
            class: "va-select-content__state-icon",
            color: "info",
            text: `+${unref82(hiddenSelectedOptionsAmountComputed)}`,
            tabindex: _ctx.$props.tabindex,
            onClick: withModifiers19(toggleHiddenOptionsState, ["stop"])
          }, null, 8, ["text", "tabindex"])) : createCommentVNode46("", true)
        ]),
        renderSlot74(_ctx.$slots, "hideOptionsButton", normalizeProps33(guardReactiveProps28({
          isShown: _ctx.$props.isAllOptionsShown,
          toggle: toggleHiddenOptionsState
        })), () => [
          _ctx.$props.isAllOptionsShown ? (openBlock90(), createBlock45(unref82(VaIcon), {
            key: 0,
            role: "button",
            class: "va-select-content__state-icon",
            size: "small",
            name: "reply",
            tabindex: _ctx.$props.tabindex,
            onClick: withModifiers19(toggleHiddenOptionsState, ["stop"])
          }, null, 8, ["tabindex"])) : createCommentVNode46("", true)
        ])
      ]);
    };
  }
});

// node_modules/vuestic-ui/dist/es/src/components/va-select/components/VaSelectContent/index.js
var VaSelectContent = withConfigTransport$1(_sfc_main93);

// node_modules/vuestic-ui/dist/es/src/components/va-select/hooks/useMaxVisibleOptions.js
import { toRef as toRef12, ref as ref64, computed as computed162, watch as watch49 } from "vue";
var useMaxVisibleOptionsProps = {
  maxVisibleOptions: { type: Number || String, default: 0 }
};
var useMaxVisibleOptions = (props, getOptionByValue) => {
  const modelValue = toRef12(props, "modelValue");
  const isAllOptionsShown = ref64(false);
  const belowLimitSelectedOptions = ref64([]);
  const hiddenSelectedOptions = ref64([]);
  const hiddenSelectedOptionsAmount = computed162(() => hiddenSelectedOptions.value.length);
  const allSelectedOptions = computed162(() => [...belowLimitSelectedOptions.value, ...hiddenSelectedOptions.value]);
  const visibleSelectedOptions = computed162(() => {
    if (!props.maxVisibleOptions || isAllOptionsShown.value) {
      return allSelectedOptions.value;
    }
    return belowLimitSelectedOptions.value;
  });
  watch49(modelValue, () => {
    if (!Array.isArray(modelValue.value)) {
      belowLimitSelectedOptions.value = [getOptionByValue(modelValue.value)];
      hiddenSelectedOptions.value = [];
      return;
    }
    const value = modelValue.value.filter((v) => !isNilValue(v)).map(getOptionByValue);
    if (props.maxVisibleOptions) {
      belowLimitSelectedOptions.value = value.slice(0, props.maxVisibleOptions);
      hiddenSelectedOptions.value = value.slice(props.maxVisibleOptions);
    } else {
      belowLimitSelectedOptions.value = [...value];
      hiddenSelectedOptions.value = [];
    }
  }, { immediate: true });
  const toggleHiddenOptionsState = () => isAllOptionsShown.value = !isAllOptionsShown.value;
  return {
    toggleHiddenOptionsState,
    isAllOptionsShown,
    visibleSelectedOptions,
    hiddenSelectedOptionsAmount,
    allSelectedOptions
  };
};

// node_modules/vuestic-ui/dist/es/src/components/va-select/hooks/useToggleIcon.js
import { computed as computed163 } from "vue";
var useToggleIconProps = {
  dropdownIcon: {
    type: [String, Object],
    default: () => ({
      open: "va-arrow-down",
      close: "va-arrow-up"
    }),
    validator: (value) => {
      if (typeof value === "string") {
        return true;
      }
      return Object.entries(value).every(([prop, propValue]) => ["open", "close"].includes(prop) && typeof propValue === "string");
    }
  }
};
var useToggleIcon = (props, showDropdownContent) => {
  const toggleIcon = computed163(() => {
    if (!props.dropdownIcon) {
      return "";
    }
    if (typeof props.dropdownIcon === "string") {
      return props.dropdownIcon;
    }
    return showDropdownContent.value ? props.dropdownIcon.close : props.dropdownIcon.open;
  });
  const { getHoverColor: getHoverColor2, getColor } = useColors();
  const colorComputed = computed163(() => getColor("secondary"));
  const toggleIconColor = computed163(() => props.readonly ? getHoverColor2(colorComputed.value) : colorComputed.value);
  return { toggleIcon, toggleIconColor };
};

// node_modules/vuestic-ui/dist/es/src/components/va-select/hooks/useStringValue.js
import { computed as computed164 } from "vue";
var useStringValueProps = {
  separator: { type: String, default: ", " }
};
var useStringValue = (props, visibleSelectedOptions, getText) => {
  return computed164(() => {
    var _a2;
    if (!((_a2 = visibleSelectedOptions.value) == null ? void 0 : _a2.length)) {
      return "";
    }
    return visibleSelectedOptions.value.map(getText).join(props.separator) ?? "";
  });
};

// node_modules/vuestic-ui/dist/es/src/components/va-select/hooks/useAutocomplete.js
import { watch as watch50 } from "vue";
var useAutocompleteProps = {
  autocomplete: { type: Boolean, default: false }
};
var useAutocomplete = (autocompleteValue, props, value, dropdownShown, getText) => {
  const getLastOptionText = (v) => (v == null ? void 0 : v.length) ? getText(v.at(-1)) : "";
  if (props.autocomplete && !props.multiple) {
    autocompleteValue.value = getLastOptionText(value.value);
  }
  watch50(value, (newValue, oldValue) => {
    if (!props.autocomplete) {
      return;
    }
    const newValueStringConverted = getLastOptionText(newValue);
    const oldValueStringConverted = getLastOptionText(oldValue);
    if (newValueStringConverted !== oldValueStringConverted) {
      autocompleteValue.value = props.multiple ? "" : newValueStringConverted;
      if (!props.multiple) {
        dropdownShown.value = false;
      }
    }
  });
  watch50(autocompleteValue, (newValue) => {
    if (!props.autocomplete) {
      return;
    }
    if (newValue && newValue !== getLastOptionText(value.value)) {
      dropdownShown.value = true;
    }
  });
  const onDropdownClosed = () => {
    autocompleteValue.value = props.multiple ? "" : getLastOptionText(value.value);
  };
  watch50(dropdownShown, (newValue, oldValue) => {
    if (!props.autocomplete) {
      return;
    }
    if (!newValue || oldValue) {
      onDropdownClosed();
    }
  });
  return autocompleteValue;
};

// node_modules/vuestic-ui/dist/es/src/components/va-select/hooks/useSelectAria.js
var useSelectAria = () => {
  const id = useComponentUuid();
  const popupId = `combobox-controls-${id}`;
  return {
    popupId
  };
};

// node_modules/vuestic-ui/dist/es/src/composables/useMaxSelections.js
var useMaxSelectionsProps = {
  maxSelections: {
    type: [Number, String],
    default: void 0
  }
};
function useMaxSelections(selections, maxSelections) {
  const exceedsMaxSelections = () => {
    if (maxSelections.value === void 0 || isNaN(+maxSelections.value)) {
      return false;
    }
    return selections.value.length >= Number(maxSelections.value);
  };
  const addOption = (optionToAdd) => {
    return [...selections.value, optionToAdd];
  };
  return {
    exceedsMaxSelections,
    addOption
  };
}

// node_modules/vuestic-ui/dist/es/src/components/va-select/VaSelect.vue_vue_type_script_setup_true_lang.js
import "D:/Desktop/forntend/Front_End_Web_Hotel_Nhom_2/my-nuxt-app/node_modules/vuestic-ui/dist/es/VaSelect.css";
var VaInputWrapperProps3 = extractComponentProps(VaInputWrapper);
var _sfc_main94 = defineComponent93({
  ...{
    name: "VaSelect"
  },
  __name: "VaSelect",
  props: {
    ...VaInputWrapperProps3,
    ...useComponentPresetProp,
    ...useSelectableListProps,
    ...useValidationProps,
    ...useLoadingProps,
    ...useMaxSelectionsProps,
    ...useClearableProps,
    ...useFormFieldProps,
    ...useMaxVisibleOptionsProps,
    ...useToggleIconProps,
    ...useThrottleProps,
    ...useStringValueProps,
    ...useAutocompleteProps,
    ...useDropdownableProps,
    modelValue: {
      type: [String, Number, Array, Object, Boolean],
      default: void 0
    },
    // Dropdown placement
    placement: { ...useDropdownableProps.placement, default: "bottom" },
    keepAnchorWidth: { ...useDropdownableProps.keepAnchorWidth, default: true },
    offset: { ...useDropdownableProps.offset, default: [1, 0] },
    closeOnContentClick: { ...useDropdownableProps.closeOnContentClick, default: false },
    trigger: { ...useDropdownableProps.trigger, default: () => ["click", "right-click", "space", "enter"] },
    // Select options
    allowCreate: {
      type: [Boolean, String],
      default: false,
      validator: (mode) => [true, false, "unique"].includes(mode)
    },
    color: { type: String, default: "primary" },
    multiple: { type: Boolean, default: false },
    searchable: { type: Boolean, default: false },
    width: { type: String, default: "100%" },
    maxHeight: { type: String, default: "256px" },
    noOptionsText: useTranslationProp("$t:noOptions"),
    hideSelected: { type: Boolean, default: false },
    tabindex: { type: [String, Number], default: 0 },
    virtualScroller: { type: Boolean, default: false },
    selectedTopShown: { type: Boolean, default: false },
    highlightMatchedText: { type: Boolean, default: true },
    minSearchChars: { type: [Number, String], default: 0 },
    autoSelectFirstOption: { type: Boolean, default: false },
    // Input style
    placeholder: { type: String, default: "" },
    searchPlaceholderText: useTranslationProp("$t:search"),
    ariaLabel: useTranslationProp("$t:select"),
    ariaSearchLabel: useTranslationProp("$t:optionsFilter"),
    ariaClearLabel: useTranslationProp("$t:reset"),
    search: { type: String, default: void 0 },
    searchFn: { type: Function, default: void 0 },
    // useClearableProps override
    clearValue: { type: [String, Number, Array, Object, Boolean], default: "" }
  },
  emits: [
    "update:modelValue",
    "update-search",
    "create-new",
    "scroll-bottom",
    "update:search",
    ...useDropdownableEmits,
    ...useValidationEmits,
    ...useClearableEmits
  ],
  setup(__props, { expose: __expose, emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const { tp, t } = useTranslation();
    const optionList = shallowRef30();
    const input = shallowRef30();
    const searchBar = shallowRef30();
    const isInputFocused = useFocusDeep(input);
    const { getValue, getText, getTrackBy, tryResolveByValue } = useSelectableList(props);
    const getValueText = (option) => getText(tryResolveByValue(option));
    const onScrollBottom = () => emit("scroll-bottom");
    const [searchVModel] = useSyncProp("search", props, emit, "");
    const showSearchInput = computed165(() => props.searchable || props.allowCreate && !props.autocomplete);
    watch51(searchVModel, (value) => {
      emit("update-search", value);
      if (!props.autocomplete) {
        hoveredOption.value = null;
      }
    });
    const getOptionByValue = (value) => {
      if (isNilValue(value) || typeof value === "object") {
        return value;
      }
      const optionByValue = props.options.find((option) => value === getValue(option));
      if (optionByValue === void 0) {
        warn(`[VaSelect]: can not find option in options list (${JSON.stringify(props.options)}) by provided value (${JSON.stringify(value)})!`);
        return value;
      }
      return optionByValue;
    };
    const {
      toggleHiddenOptionsState,
      isAllOptionsShown,
      visibleSelectedOptions,
      hiddenSelectedOptionsAmount,
      allSelectedOptions
    } = useMaxVisibleOptions(props, getOptionByValue);
    const valueComputed = computed165({
      get() {
        if (props.multiple) {
          return allSelectedOptions.value;
        }
        const value = getOptionByValue(props.modelValue);
        if (Array.isArray(value)) {
          warn("Model value should be a string, number, boolean or an object for a single Select.");
          if (value.length) {
            return value.at(-1);
          }
        }
        return value;
      },
      set(option) {
        if (Array.isArray(option)) {
          emit("update:modelValue", option.map(getValue));
        } else {
          emit("update:modelValue", getValue(option));
        }
      }
    });
    const valueString = useStringValue(props, visibleSelectedOptions, getValueText);
    const {
      canBeCleared,
      clearIconProps,
      onFocus,
      onBlur
    } = useClearable(props, valueComputed);
    const showClearIcon = computed165(() => {
      if (!canBeCleared.value) {
        return false;
      }
      if (props.multiple && Array.isArray(valueComputed.value)) {
        return !!valueComputed.value.length;
      }
      return true;
    });
    const filteredOptions = computed165(() => {
      if (!props.options) {
        return [];
      }
      if (props.selectedTopShown) {
        return props.options.slice().sort((a, b) => {
          const isASelected = checkIsOptionSelected(a);
          const isBSelected = checkIsOptionSelected(b);
          if (isASelected && isBSelected) {
            return 0;
          }
          if (isASelected && !isBSelected) {
            return -1;
          }
          return 1;
        });
      }
      if (props.hideSelected) {
        return props.options.filter((option) => !checkIsOptionSelected(option));
      }
      return props.options;
    });
    const normalizedOptionValue = computed165(() => {
      if (Array.isArray(valueComputed.value)) {
        return valueComputed.value.map((value) => tryResolveByValue(value));
      }
      return tryResolveByValue(valueComputed.value);
    });
    const checkIsOptionSelected = (option) => {
      if (Array.isArray(normalizedOptionValue.value)) {
        return !isNilValue(normalizedOptionValue.value.find((valueItem) => compareOptions(valueItem, option)));
      }
      return compareOptions(normalizedOptionValue.value, option);
    };
    const compareOptions = (option1, option2) => {
      const one = getValue(option1);
      const two = getValue(option2);
      if (one === two) {
        return true;
      }
      if (typeof one === "string" && typeof two === "string") {
        return one === two;
      }
      if (one === null || two === null) {
        return false;
      }
      if (typeof one === "object" && typeof two === "object") {
        return getTrackBy(one) === getTrackBy(two);
      }
      return false;
    };
    const isValueComputedArray = (v) => Array.isArray(v.value);
    const selectOption = (option) => {
      if (hoveredOption.value === null) {
        hideAndFocus();
        return;
      }
      if (showSearchInput.value) {
        searchVModel.value = "";
      }
      if (props.multiple && isValueComputedArray(valueComputed)) {
        const { exceedsMaxSelections, addOption } = useMaxSelections(valueComputed, ref65(props.maxSelections));
        const isSelected = checkIsOptionSelected(option);
        if (isSelected) {
          valueComputed.value = valueComputed.value.filter((optionSelected) => !compareOptions(option, optionSelected));
        } else {
          if (exceedsMaxSelections()) {
            return;
          }
          valueComputed.value = addOption(option);
        }
      } else {
        valueComputed.value = option;
        hideAndFocus();
      }
      focusAutocompleteInput();
    };
    const addNewOption = () => {
      var _a2;
      const hasAddedOption = (_a2 = props.options) == null ? void 0 : _a2.some((option) => [searchVModel.value, autocompleteValue.value].includes(getText(option)));
      const allowedToCreateCheck = !((props.allowCreate === "unique" || props.autocomplete) && hasAddedOption);
      if (allowedToCreateCheck) {
        emit("create-new", searchVModel.value || autocompleteValue.value);
        searchVModel.value = "";
        autocompleteValue.value = "";
      }
    };
    const hoveredOption = ref65(null);
    const selectHoveredOption = () => {
      if (!isOpenSync.value) {
        handleDropdownOpen();
        return;
      }
      selectOption(hoveredOption.value);
    };
    const selectOrAddOption = () => {
      const allowedToCreate = !!props.allowCreate && (searchVModel.value || autocompleteValue.value);
      if (hoveredOption.value !== null) {
        selectHoveredOption();
      } else if (allowedToCreate) {
        addNewOption();
      }
    };
    const focusPreviousOption = () => {
      var _a2;
      return (_a2 = optionList.value) == null ? void 0 : _a2.focusPreviousOption();
    };
    const focusNextOption = () => {
      var _a2;
      return (_a2 = optionList.value) == null ? void 0 : _a2.focusNextOption();
    };
    const { isOpenSync, dropdownProps } = useDropdownable(props, emit, {
      defaultCloseOnValueUpdate: computed165(() => !props.multiple)
    });
    const dropdownPropsComputed = computed165(() => ({
      ...dropdownProps.value,
      stateful: false,
      innerAnchorSelector: ".va-input-wrapper__field"
    }));
    const showDropdownContentComputed = computed165({
      get: () => isOpenSync.value,
      set: (show) => {
        show ? handleDropdownOpen() : handleDropdownClose();
      }
    });
    const handleDropdownOpen = () => {
      if (props.disabled || props.readonly) {
        return;
      }
      isOpenSync.value = true;
      scrollToSelected();
      focusSearchOrOptions();
    };
    const handleDropdownClose = () => {
      isOpenSync.value = false;
      if (!props.autocomplete) {
        searchVModel.value = "";
      }
      nextTick11(() => {
        validate();
        isInputFocused.focusIfNothingIfFocused();
      });
    };
    const hideAndFocus = () => {
      handleDropdownClose();
      isInputFocused.value = true;
    };
    const focusSearchBar = () => {
      var _a2;
      (_a2 = searchBar.value) == null ? void 0 : _a2.focus();
    };
    const focusOptionList = () => {
      var _a2, _b;
      (_a2 = optionList.value) == null ? void 0 : _a2.focus();
      !props.modelValue && ((_b = optionList.value) == null ? void 0 : _b.focusFirstOption());
    };
    const focusSearchOrOptions = async () => {
      await nextTick11();
      if (showSearchInput.value) {
        focusSearchBar();
      } else {
        focusOptionList();
      }
    };
    const onInputBlur = () => {
      if (showDropdownContentComputed.value) {
        return;
      }
      onBlur();
      validationListeners.onBlur();
      isInputFocused.value ? isInputFocused.value = false : validate();
    };
    const tabIndexComputed = computed165(() => props.disabled ? -1 : props.tabindex);
    const openSelectButtonTabIndexComputed = computed165(() => props.disabled || props.autocomplete ? -1 : 0);
    const scrollToSelected = () => {
      const selected = valueComputed.value;
      const nothingSelected = typeof selected !== "object" && Array.isArray(selected) && !selected.length;
      if (nothingSelected) {
        return;
      }
      const scrollTo = Array.isArray(selected) ? selected[selected.length - 1] : selected;
      hoveredOption.value = scrollTo;
      nextTick11(() => {
        var _a2;
        return (_a2 = optionList.value) == null ? void 0 : _a2.scrollToOption(scrollTo);
      });
    };
    let hintedSearchQuery = "";
    let hintedSearchQueryTimeoutIndex;
    const navigationKeys = ["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight", "Enter", " "];
    const onHintedSearch = (event) => {
      if (navigationKeys.some((key) => key === event.key)) {
        return;
      }
      const isLetter = event.key.length === 1;
      const isDeleteKey = event.key === "Backspace" || event.key === "Delete";
      clearTimeout(hintedSearchQueryTimeoutIndex);
      if (isDeleteKey) {
        hintedSearchQuery = hintedSearchQuery ? hintedSearchQuery.slice(0, -1) : "";
      } else if (isLetter) {
        hintedSearchQuery += event.key;
      }
      if (showSearchInput.value) {
        searchVModel.value = hintedSearchQuery;
        return;
      }
      if (hintedSearchQuery) {
        const appropriateOption = props.options.find((option) => getText(option).toLowerCase().startsWith(hintedSearchQuery.toLowerCase()));
        if (appropriateOption) {
          hoveredOption.value = appropriateOption;
        }
      }
      hintedSearchQueryTimeoutIndex = setTimeout(() => {
        hintedSearchQuery = "";
      }, 1e3);
    };
    const minSearchCharsComputed = useNumericProp("minSearchChars");
    const optionsListPropsComputed = computed165(() => ({
      ...pick(props, ["textBy", "trackBy", "groupBy", "valueBy", "disabledBy", "color", "virtualScroller", "highlightMatchedText", "delay", "selectedTopShown"]),
      autoSelectFirstOption: props.autoSelectFirstOption || props.autocomplete,
      search: searchVModel.value || autocompleteValue.value,
      tabindex: tabIndexComputed.value,
      selectedValue: valueComputed.value,
      options: filteredOptions.value,
      getSelectedState: checkIsOptionSelected,
      noOptionsText: tp(props.noOptionsText),
      doShowAllOptions: doShowAllOptions.value,
      minSearchChars: minSearchCharsComputed.value
    }));
    const { toggleIcon, toggleIconColor } = useToggleIcon(props, isOpenSync);
    const isFocused = computed165(() => isInputFocused.value || isOpenSync.value);
    const slots = useSlots12();
    const inputWrapperClassComputed = useBem("va-select-anchor", () => ({
      nowrap: !!(props.maxVisibleOptions && !slots.content)
    }));
    const vaInputWrapperProps = filterComponentProps(VaInputWrapperProps3);
    const inputWrapperPropsComputed = computed165(() => ({
      ...vaInputWrapperProps.value,
      error: computedError.value,
      errorMessages: computedErrorMessages.value,
      focused: isFocused.value,
      "aria-label": props.ariaLabel || (props.modelValue ? `${t("selectedOption")}: ${props.modelValue}` : t("noSelectedOption"))
    }));
    const selectContentPropsComputed = computed165(() => ({
      ...pick(props, ["placeholder", "autocomplete", "multiple", "disabled", "readonly"]),
      tabindex: tabIndexComputed.value,
      value: visibleSelectedOptions.value,
      valueString: valueString.value,
      hiddenSelectedOptionsAmount: hiddenSelectedOptionsAmount.value,
      isAllOptionsShown: isAllOptionsShown.value,
      focused: isInputFocused.value,
      autocompleteInputValue: autocompleteValue.value,
      getText: getValueText
    }));
    const autocompleteValue = useAutocomplete(searchVModel, props, visibleSelectedOptions, isOpenSync, getText);
    const setAutocompleteValue = (v) => autocompleteValue.value = v;
    const doShowAllOptions = ref65(true);
    watch51(showDropdownContentComputed, () => {
      doShowAllOptions.value = true;
    });
    watch51(searchVModel, () => {
      doShowAllOptions.value = false;
    });
    const focus = () => {
      if (props.disabled) {
        return;
      }
      focusElement(unwrapEl(input.value));
    };
    const blur = () => {
      if (showDropdownContentComputed.value) {
        showDropdownContentComputed.value = false;
      }
      nextTick11(() => {
        if (props.disabled) {
          return;
        }
        blurElement(unwrapEl(input.value));
      });
    };
    const reset = () => withoutValidation(() => {
      if (props.multiple) {
        valueComputed.value = Array.isArray(props.clearValue) ? props.clearValue : [];
      } else {
        valueComputed.value = props.clearValue;
      }
      searchVModel.value = "";
      emit("clear");
      resetValidation();
      nextTick11(() => {
        isInputFocused.value = true;
      });
    });
    const focusAutocompleteInput = (e) => {
      if (props.autocomplete && !props.disabled && !props.readonly) {
        e == null ? void 0 : e.stopImmediatePropagation();
        isInputFocused.value = true;
        isOpenSync.value = true;
      }
    };
    const toggleDropdown = (e) => {
      if (props.disabled || props.readonly) {
        return;
      }
      const isInInput = e.target && "tagName" in e.target && e.target.tagName === "INPUT";
      if (e.code === "Space" && isInInput) {
        return;
      }
      e.preventDefault();
      showDropdownContentComputed.value = !showDropdownContentComputed.value;
    };
    const deleteLastSelected = () => {
      if (!Array.isArray(valueComputed.value)) {
        return;
      }
      valueComputed.value = valueComputed.value.slice(0, -1);
    };
    const {
      validate,
      computedError,
      computedErrorMessages,
      withoutValidation,
      resetValidation,
      validationAriaAttributes,
      listeners: validationListeners,
      isTouched
    } = useValidation(props, emit, { reset, focus, value: valueComputed });
    watch51(isOpenSync, (isOpen) => {
      if (!isOpen) {
        isTouched.value = true;
      }
    });
    const { popupId } = useSelectAria();
    const searchInput = searchVModel;
    const onInputFocus = onFocus;
    __expose({
      focus,
      blur,
      reset
    });
    return (_ctx, _cache) => {
      return openBlock91(), createBlock46(unref83(VaDropdown), mergeProps44({
        ref: "dropdown",
        modelValue: showDropdownContentComputed.value,
        "onUpdate:modelValue": _cache[4] || (_cache[4] = ($event) => showDropdownContentComputed.value = $event),
        class: "va-select va-select__dropdown va-select-dropdown"
      }, dropdownPropsComputed.value, {
        role: "combobox",
        "inner-anchor-selector": ".va-input-wrapper__field",
        "keyboard-navigation": false
      }), {
        anchor: withCtx49(() => [
          createVNode37(unref83(VaInputWrapper), mergeProps44(inputWrapperPropsComputed.value, {
            ref_key: "input",
            ref: input,
            class: ["va-select__anchor va-select-anchor__input", unref83(inputWrapperClassComputed)],
            "aria-haspopup": "listbox",
            "model-value": unref83(valueString),
            readonly: true,
            "aria-label": _ctx.$props.ariaLabel,
            "aria-controls": unref83(popupId),
            "aria-owns": unref83(popupId),
            onFocus: unref83(onInputFocus),
            onBlur: onInputBlur
          }), createSlots7({
            icon: withCtx49(() => [
              showClearIcon.value ? (openBlock91(), createBlock46(unref83(VaIcon), mergeProps44({
                key: 0,
                role: "button",
                "aria-label": unref83(tp)(_ctx.$props.ariaClearLabel)
              }, unref83(clearIconProps), {
                onClick: withModifiers20(reset, ["stop"]),
                onKeydown: [
                  withKeys24(withModifiers20(reset, ["stop"]), ["enter"]),
                  withKeys24(withModifiers20(reset, ["stop"]), ["space"])
                ]
              }), null, 16, ["aria-label", "onKeydown"])) : createCommentVNode47("", true)
            ]),
            appendInner: withCtx49(() => [
              createVNode37(unref83(VaIcon), {
                color: unref83(toggleIconColor),
                name: unref83(toggleIcon),
                class: "va-select__toggle-icon",
                role: "button",
                tabindex: openSelectButtonTabIndexComputed.value,
                "aria-expanded": showDropdownContentComputed.value,
                onKeydown: withKeys24(toggleDropdown, ["enter"])
              }, null, 8, ["color", "name", "tabindex", "aria-expanded"])
            ]),
            default: withCtx49(({ ariaAttributes }) => [
              createVNode37(unref83(VaSelectContent), mergeProps44(selectContentPropsComputed.value, {
                ariaAttributes,
                separator: _ctx.$props.separator,
                onToggleHidden: unref83(toggleHiddenOptionsState),
                onAutocompleteInput: setAutocompleteValue,
                onFocusPrev: focusPreviousOption,
                onFocusNext: focusNextOption,
                onSelectOption: selectOrAddOption,
                onDeleteLastSelected: deleteLastSelected
              }), createSlots7({ _: 2 }, [
                renderList23(_ctx.$slots, (_, name) => {
                  return {
                    name,
                    fn: withCtx49((slotScope) => [
                      renderSlot75(_ctx.$slots, name, normalizeProps34(guardReactiveProps29(slotScope)))
                    ])
                  };
                })
              ]), 1040, ["ariaAttributes", "separator", "onToggleHidden"])
            ]),
            _: 2
          }, [
            renderList23(_ctx.$slots, (_, name) => {
              return {
                name,
                fn: withCtx49((slotScope) => [
                  renderSlot75(_ctx.$slots, name, normalizeProps34(guardReactiveProps29(slotScope)))
                ])
              };
            })
          ]), 1040, ["class", "model-value", "aria-label", "aria-controls", "aria-owns", "onFocus"])
        ]),
        default: withCtx49(() => [
          createVNode37(unref83(VaDropdownContent), {
            class: "va-select-dropdown__content",
            style: normalizeStyle48({ width: _ctx.$props.width }),
            onKeydown: withKeys24(hideAndFocus, ["esc"]),
            role: "dialog"
          }, {
            default: withCtx49(() => [
              showSearchInput.value ? (openBlock91(), createBlock46(unref83(VaInputWrapper), {
                key: 0,
                ref_key: "searchBar",
                ref: searchBar,
                class: "va-select-dropdown__content-search-input",
                modelValue: unref83(searchInput),
                "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => isRef9(searchInput) ? searchInput.value = $event : null),
                "aria-label": unref83(tp)(_ctx.$props.ariaSearchLabel),
                tabindex: tabIndexComputed.value,
                placeholder: unref83(tp)(_ctx.$props.searchPlaceholderText),
                preset: "bordered",
                onKeydown: [
                  withKeys24(withModifiers20(focusPreviousOption, ["stop", "prevent"]), ["up"]),
                  withKeys24(withModifiers20(focusPreviousOption, ["stop", "prevent"]), ["left"]),
                  withKeys24(withModifiers20(focusNextOption, ["stop", "prevent"]), ["down"]),
                  withKeys24(withModifiers20(focusNextOption, ["stop", "prevent"]), ["right"]),
                  withKeys24(withModifiers20(selectOrAddOption, ["prevent"]), ["enter"])
                ],
                onFocus: _cache[1] || (_cache[1] = ($event) => hoveredOption.value = null)
              }, null, 8, ["modelValue", "aria-label", "tabindex", "placeholder", "onKeydown"])) : createCommentVNode47("", true),
              createVNode37(unref83(VaSelectOptionList), mergeProps44({
                ref_key: "optionList",
                ref: optionList,
                class: "va-select-dropdown__options-wrapper",
                hoveredOption: hoveredOption.value,
                "onUpdate:hoveredOption": _cache[2] || (_cache[2] = ($event) => hoveredOption.value = $event),
                style: { maxHeight: _ctx.$props.maxHeight },
                id: unref83(popupId),
                "search-fn": _ctx.$props.searchFn
              }, optionsListPropsComputed.value, {
                onSelectOption: selectHoveredOption,
                onNoPreviousOptionToHover: focusSearchBar,
                onKeydown: [
                  _cache[3] || (_cache[3] = withKeys24(withModifiers20(($event) => searchBar.value && searchBar.value.focus(), ["stop", "prevent"]), ["tab"])),
                  onHintedSearch
                ],
                onScrollBottom
              }), {
                default: withCtx49((slotData) => [
                  renderSlot75(_ctx.$slots, "option", normalizeProps34(guardReactiveProps29(slotData)))
                ]),
                "option-content": withCtx49((slotData) => [
                  renderSlot75(_ctx.$slots, "option-content", normalizeProps34(guardReactiveProps29(slotData)))
                ]),
                _: 3
              }, 16, ["hoveredOption", "style", "id", "search-fn"])
            ]),
            _: 3
          }, 8, ["style"])
        ]),
        _: 3
      }, 16, ["modelValue"]);
    };
  }
});

// node_modules/vuestic-ui/dist/es/src/components/va-select/index.js
var VaSelect = withConfigTransport$1(_sfc_main94);

// node_modules/vuestic-ui/dist/es/src/components/va-skeleton/VaSkeleton.vue_vue_type_script_setup_true_lang.js
import { defineComponent as defineComponent94, ref as ref66, onMounted as onMounted29, onBeforeUnmount as onBeforeUnmount21, computed as computed166, useAttrs as useAttrs6, openBlock as openBlock92, createBlock as createBlock47, resolveDynamicComponent as resolveDynamicComponent9, normalizeClass as normalizeClass46, unref as unref84, normalizeStyle as normalizeStyle49, withCtx as withCtx50, renderSlot as renderSlot76, createElementBlock as createElementBlock80, createCommentVNode as createCommentVNode48 } from "vue";
import "D:/Desktop/forntend/Front_End_Web_Hotel_Nhom_2/my-nuxt-app/node_modules/vuestic-ui/dist/es/VaSkeleton.css";
var _hoisted_156 = {
  key: 0,
  class: "va-skeleton__wave"
};
var _sfc_main95 = defineComponent94({
  ...{
    name: "VaSkeleton"
  },
  __name: "VaSkeleton",
  props: {
    color: { type: String, default: "backgroundElement" },
    delay: { type: [Number, String], default: 100 },
    tag: { type: String, default: "div" },
    animation: { type: String, default: "pulse" },
    lines: { type: [String, Number], default: 1 },
    height: { type: [String], default: "5em" },
    width: { type: [String], default: "100%" },
    lineGap: { type: String, default: "8px" },
    lastLineWidth: { type: [String], default: "75%" },
    variant: { type: String, default: "squared" },
    ariaLabel: useTranslationProp("$t:loading")
  },
  setup(__props) {
    const props = __props;
    const doShow = ref66(false);
    const delayComputed = useNumericProp("delay");
    let timeoutId;
    onMounted29(() => {
      clearTimeout(timeoutId);
      setTimeout(() => {
        doShow.value = true;
      }, delayComputed.value);
    });
    onBeforeUnmount21(() => {
      clearTimeout(timeoutId);
    });
    const heightComputed = computed166(() => {
      if (props.variant === "text") {
        return `${props.lines}em`;
      }
      return props.height;
    });
    const widthComputed = computed166(() => {
      if (props.variant === "circle") {
        return heightComputed.value;
      }
      return props.width;
    });
    const { getColor } = useColors();
    const colorComputed = computed166(() => getColor(props.color));
    computed166(() => `-${props.lineGap}`);
    const bem = useBem("va-skeleton", () => ({
      lines: Number(props.lines) > 1,
      text: props.variant === "text",
      circle: props.variant === "circle",
      hidden: !doShow.value,
      pulse: props.animation === "pulse",
      wave: props.animation === "wave"
    }));
    const borderRadius = computed166(() => {
      if (props.variant === "circle") {
        return "50%";
      }
      if (props.variant === "rounded") {
        return `var(--va-skeleton-border-radius, calc(${heightComputed.value} / 5))`;
      }
      return "0px";
    });
    const { tp } = useTranslation();
    const attrs = useAttrs6();
    const classes = computed166(() => [
      ...Object.keys(bem),
      attrs.class
    ]);
    return (_ctx, _cache) => {
      return openBlock92(), createBlock47(resolveDynamicComponent9(__props.tag), {
        class: normalizeClass46(["va-skeleton", classes.value]),
        role: "status",
        "aria-live": "polite",
        "aria-label": unref84(tp)(_ctx.$props.ariaLabel),
        "aria-atomic": "true",
        style: normalizeStyle49(`--va-color-computed: ${String(colorComputed.value)};--va-height-computed: ${String(heightComputed.value)};--va-width-computed: ${String(widthComputed.value)};--va-border-radius: ${String(borderRadius.value)};--va-line-gap: ${String(__props.lineGap)};--va-last-line-width: ${String(__props.lastLineWidth)}`)
      }, {
        default: withCtx50(() => [
          renderSlot76(_ctx.$slots, "default"),
          __props.animation === "wave" ? (openBlock92(), createElementBlock80("div", _hoisted_156)) : createCommentVNode48("", true)
        ]),
        _: 3
      }, 8, ["aria-label", "class", "style"]);
    };
  }
});

// node_modules/vuestic-ui/dist/es/src/components/va-skeleton/components/VaSkeletonGroup.vue_vue_type_script_setup_true_lang.js
import { defineComponent as defineComponent95, ref as ref67, onMounted as onMounted30, onBeforeMount as onBeforeMount2, computed as computed167, openBlock as openBlock93, createBlock as createBlock48, unref as unref85, withCtx as withCtx51, createElementVNode as createElementVNode43, mergeProps as mergeProps45, renderSlot as renderSlot77 } from "vue";
import "D:/Desktop/forntend/Front_End_Web_Hotel_Nhom_2/my-nuxt-app/node_modules/vuestic-ui/dist/es/VaSkeletonGroup.css";
var _sfc_main96 = defineComponent95({
  ...{
    name: "VaSkeletonGroup"
  },
  __name: "VaSkeletonGroup",
  props: {
    color: { type: String, default: "backgroundElement" },
    delay: { type: [Number, String], default: 100 },
    animation: { type: String, default: "pulse" },
    lines: { type: [Number, String], default: 1 },
    lineGap: { type: String, default: "8px" },
    lastLineWidth: { type: [String], default: "75%" }
  },
  setup(__props) {
    const props = __props;
    const doShow = ref67(false);
    const delayComputed = useNumericProp("delay");
    let timeoutId;
    onMounted30(() => {
      timeoutId = setTimeout(() => {
        doShow.value = true;
      }, delayComputed.value);
    });
    onBeforeMount2(() => {
      clearTimeout(timeoutId);
    });
    const bem = useBem("va-skeleton-group", () => ({
      hidden: doShow.value === false
    }));
    const config = computed167(() => ({ ...props, delay: 0 }));
    return (_ctx, _cache) => {
      return openBlock93(), createBlock48(unref85(_sfc_main4), {
        components: { VaSkeleton: config.value }
      }, {
        default: withCtx51(() => [
          createElementVNode43("div", mergeProps45({
            class: ["va-skeleton-group", unref85(bem)]
          }, _ctx.$attrs), [
            renderSlot77(_ctx.$slots, "default", {}, void 0, true)
          ], 16)
        ]),
        _: 3
      }, 8, ["components"]);
    };
  }
});

// node_modules/vuestic-ui/dist/es/src/components/va-skeleton/components/VaSkeletonGroup.js
import "D:/Desktop/forntend/Front_End_Web_Hotel_Nhom_2/my-nuxt-app/node_modules/vuestic-ui/dist/es/VaSkeletonGroup.css";
var _VaSkeletonGroup = _export_sfc(_sfc_main96, [["__scopeId", "data-v-597bab9a"]]);

// node_modules/vuestic-ui/dist/es/src/components/va-skeleton/index.js
var VaSkeleton = withConfigTransport$1(_sfc_main95);
var VaSkeletonGroup = withConfigTransport$1(_VaSkeletonGroup);

// node_modules/vuestic-ui/dist/es/src/components/va-sidebar/VaSidebar.vue_vue_type_script_setup_true_lang.js
import { defineComponent as defineComponent96, ref as ref69, computed as computed168, watchEffect as watchEffect10, shallowRef as shallowRef31, openBlock as openBlock94, createElementBlock as createElementBlock81, normalizeClass as normalizeClass47, unref as unref86, normalizeStyle as normalizeStyle50, withDirectives as withDirectives8, createElementVNode as createElementVNode44, createVNode as createVNode38, withCtx as withCtx52, renderSlot as renderSlot78, vShow as vShow3 } from "vue";

// node_modules/vuestic-ui/dist/es/src/components/va-sidebar/hooks/useSidebar.js
import { provide as provide8, inject as inject9 } from "vue";
var VaSidebarKey = Symbol("VaSidebar");
var useSidebar = (props) => {
  provide8(VaSidebarKey, props);
};
var useSidebarItem = () => {
  return inject9(VaSidebarKey, {
    color: "background-element"
    // activeColor: 'primary',
  });
};

// node_modules/vuestic-ui/dist/es/src/composables/useElementWidth.js
import { ref as ref68, watchEffect as watchEffect9 } from "vue";
var useElementWidth = (el) => {
  const width = ref68(null);
  useResizeObserver([el], () => {
    var _a2;
    width.value = ((_a2 = el.value) == null ? void 0 : _a2.clientWidth) ?? null;
  });
  watchEffect9(() => {
    var _a2;
    width.value = ((_a2 = el.value) == null ? void 0 : _a2.clientWidth) ?? null;
  });
  return width;
};

// node_modules/vuestic-ui/dist/es/src/components/va-sidebar/VaSidebar.vue_vue_type_script_setup_true_lang.js
import "D:/Desktop/forntend/Front_End_Web_Hotel_Nhom_2/my-nuxt-app/node_modules/vuestic-ui/dist/es/VaSidebar.css";
var _sfc_main97 = defineComponent96({
  ...{
    name: "VaSidebar"
  },
  __name: "VaSidebar",
  props: {
    ...useComponentPresetProp,
    activeColor: { type: String, default: "primary" },
    hoverColor: { type: String, default: void 0 },
    hoverOpacity: {
      type: [Number, String],
      default: 0.2,
      validator: (v) => Number(v) >= 0 && Number(v) <= 1
    },
    borderColor: { type: String, default: void 0 },
    color: { type: String, default: "background-element" },
    textColor: { type: String },
    gradient: { type: Boolean, default: false },
    minimized: { type: Boolean, default: false },
    hoverable: { type: Boolean, default: false },
    width: { type: String, default: "16rem" },
    minimizedWidth: { type: String, default: "4rem" },
    modelValue: { type: Boolean, default: true },
    animated: { type: [Boolean, String], default: true },
    closeOnClickOutside: { type: Boolean, default: false }
  },
  emits: ["update:modelValue"],
  setup(__props, { expose: __expose, emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const { getColor } = useColors();
    useSidebar(props);
    const isHovered = ref69(false);
    const isMinimized = computed168(() => props.minimized || props.hoverable && !isHovered.value);
    const menu = ref69();
    const currentMenuWidth = useElementWidth(menu);
    const doShowMenu = computed168(() => {
      if (props.modelValue === true) {
        return true;
      }
      if (currentMenuWidth.value === null) {
        return true;
      }
      return currentMenuWidth.value > 0;
    });
    const sidebarWidth = ref69();
    const getSidebarWidth = () => {
      if (!props.modelValue) {
        return 0;
      }
      return isMinimized.value ? props.minimizedWidth : props.width;
    };
    const menuWidth = computed168(() => isMinimized.value ? props.minimizedWidth : props.width);
    watchEffect10(() => {
      const width = getSidebarWidth();
      setTimeout(() => {
        sidebarWidth.value = width;
      });
    });
    const backgroundColorComputed = computed168(() => getColor(props.color));
    const { textColorComputed } = useTextColor(backgroundColorComputed);
    const computedStyle = computed168(() => {
      const backgroundColor = getColor(backgroundColorComputed.value);
      const color = textColorComputed.value;
      return {
        color,
        backgroundColor,
        backgroundImage: props.gradient ? getGradientBackground(backgroundColor) : void 0,
        overflowX: currentMenuWidth.value === sidebarWidth.value ? void 0 : "hidden",
        width: sidebarWidth.value,
        minWidth: sidebarWidth.value
      };
    });
    const computedClass = useBem("va-sidebar", () => ({
      minimized: isMinimized.value,
      animated: Boolean(props.animated),
      "animated-right": props.animated === "right",
      "animated-left": props.animated === "left" || props.animated === true
    }));
    const updateHoverState = (newHoverState) => {
      isHovered.value = props.hoverable && newHoverState;
    };
    const rootElement = shallowRef31();
    useClickOutside([rootElement], () => {
      if (props.closeOnClickOutside && props.modelValue) {
        setTimeout(() => {
          emit("update:modelValue", false);
        }, 0);
      }
    });
    const vaSidebarItemProps = computed168(() => ({
      textColor: props.textColor,
      activeColor: props.activeColor,
      hoverColor: props.hoverColor,
      borderColor: props.borderColor,
      hoverOpacity: props.hoverOpacity
    }));
    __expose({
      isMinimized,
      isHovered,
      updateHoverState,
      rootElement,
      menu,
      doShowMenu,
      menuWidth,
      sidebarWidth
    });
    return (_ctx, _cache) => {
      return openBlock94(), createElementBlock81("aside", {
        ref_key: "rootElement",
        ref: rootElement,
        class: normalizeClass47(["va-sidebar", unref86(computedClass)]),
        style: normalizeStyle50(computedStyle.value),
        onMouseenter: _cache[0] || (_cache[0] = ($event) => updateHoverState(true)),
        onMouseleave: _cache[1] || (_cache[1] = ($event) => updateHoverState(false))
      }, [
        withDirectives8(createElementVNode44("div", {
          class: "va-sidebar__menu",
          ref_key: "menu",
          ref: menu,
          style: normalizeStyle50({
            width: menuWidth.value,
            minWidth: menuWidth.value
          })
        }, [
          createVNode38(unref86(_sfc_main4), {
            components: { VaSidebarItem: vaSidebarItemProps.value }
          }, {
            default: withCtx52(() => [
              renderSlot78(_ctx.$slots, "default")
            ]),
            _: 3
          }, 8, ["components"])
        ], 4), [
          [vShow3, doShowMenu.value]
        ])
      ], 38);
    };
  }
});

// node_modules/vuestic-ui/dist/es/src/components/va-sidebar/index.js
var VaSidebar = withConfigTransport$1(_sfc_main97);

// node_modules/vuestic-ui/dist/es/src/components/va-sidebar/VaSidebarItem/VaSidebarItem.vue_vue_type_script_setup_true_lang.js
import { defineComponent as defineComponent97, toRef as toRef13, computed as computed169, openBlock as openBlock95, createBlock as createBlock49, resolveDynamicComponent as resolveDynamicComponent10, unref as unref87, mergeProps as mergeProps46, toHandlers as toHandlers7, withCtx as withCtx53, renderSlot as renderSlot79 } from "vue";
import "D:/Desktop/forntend/Front_End_Web_Hotel_Nhom_2/my-nuxt-app/node_modules/vuestic-ui/dist/es/VaSidebarItem.css";
var _sfc_main98 = defineComponent97({
  ...{
    name: "VaSidebarItem"
  },
  __name: "VaSidebarItem",
  props: {
    ...useRouterLinkProps,
    ...useComponentPresetProp,
    active: { type: Boolean, default: false },
    textColor: { type: String, default: void 0 },
    activeColor: { type: String, default: "primary" },
    hoverColor: { type: String, default: void 0 },
    hoverOpacity: { type: [Number, String], default: 0.2 },
    borderColor: { type: String, default: void 0 },
    disabled: { type: Boolean, default: false }
  },
  setup(__props) {
    const props = __props;
    const rootElement = useElementRef();
    const sidebar = useSidebarItem();
    const { isHovered } = useHover(rootElement, toRef13(props, "disabled"));
    const { getColor, getHoverColor: getHoverColor2, getFocusColor: getFocusColor2 } = useColors();
    const { hasKeyboardFocus, keyboardFocusListeners } = useKeyboardOnlyFocus();
    const backgroundColorComputed = computed169(() => {
      if (props.active && !isHovered.value && !hasKeyboardFocus.value) {
        return getColor(props.activeColor);
      }
      if (hasKeyboardFocus.value) {
        return getFocusColor2(getColor(props.hoverColor || props.activeColor));
      }
      return "#ffffff00";
    });
    const textBackground = computed169(() => applyColors(getColor(sidebar == null ? void 0 : sidebar.color), backgroundColorComputed.value));
    const { textColorComputed } = useTextColor(textBackground);
    const computedStyle = computed169(() => {
      const style = { color: textColorComputed.value };
      if (props.disabled) {
        return style;
      }
      if (isHovered.value || props.active || hasKeyboardFocus.value) {
        style.backgroundColor = backgroundColorComputed.value;
      }
      if (props.active) {
        const mergedProps = { ...sidebar, ...props };
        style.borderColor = getColor(mergedProps.borderColor || mergedProps.activeColor);
      }
      if (hasKeyboardFocus.value) {
        style.backgroundColor = getFocusColor2(getColor(props.hoverColor || props.activeColor));
      }
      if (isHovered.value) {
        style.backgroundColor = getHoverColor2(
          getColor(props.hoverColor || props.activeColor),
          Number(props.hoverOpacity)
        );
      }
      return style;
    });
    const { tagComputed, linkAttributesComputed } = useRouterLink(props);
    return (_ctx, _cache) => {
      return openBlock95(), createBlock49(resolveDynamicComponent10(unref87(tagComputed)), mergeProps46({
        ref_key: "rootElement",
        ref: rootElement,
        class: ["va-sidebar__item va-sidebar-item", {
          "va-sidebar-item--active": _ctx.$props.active,
          "va-sidebar-item--disabled": _ctx.$props.disabled
        }],
        tabindex: _ctx.$props.disabled ? -1 : 0,
        style: computedStyle.value
      }, unref87(linkAttributesComputed), toHandlers7(unref87(keyboardFocusListeners))), {
        default: withCtx53(() => [
          renderSlot79(_ctx.$slots, "default")
        ]),
        _: 3
      }, 16, ["tabindex", "class", "style"]);
    };
  }
});

// node_modules/vuestic-ui/dist/es/src/components/va-sidebar/VaSidebarItem/VaSidebarItemContent.vue_vue_type_script_setup_true_lang.js
import { defineComponent as defineComponent98, openBlock as openBlock96, createElementBlock as createElementBlock82, renderSlot as renderSlot80 } from "vue";
import "D:/Desktop/forntend/Front_End_Web_Hotel_Nhom_2/my-nuxt-app/node_modules/vuestic-ui/dist/es/VaSidebarItemContent.css";
var _hoisted_157 = { class: "va-sidebar__item__content va-sidebar-item-content" };
var _sfc_main99 = defineComponent98({
  ...{
    name: "VaSidebarItemContent"
  },
  __name: "VaSidebarItemContent",
  setup(__props) {
    return (_ctx, _cache) => {
      return openBlock96(), createElementBlock82("div", _hoisted_157, [
        renderSlot80(_ctx.$slots, "default")
      ]);
    };
  }
});

// node_modules/vuestic-ui/dist/es/src/components/va-sidebar/VaSidebarItem/VaSidebarItemTitle.vue_vue_type_script_setup_true_lang.js
import { defineComponent as defineComponent99, openBlock as openBlock97, createElementBlock as createElementBlock83, renderSlot as renderSlot81 } from "vue";
import "D:/Desktop/forntend/Front_End_Web_Hotel_Nhom_2/my-nuxt-app/node_modules/vuestic-ui/dist/es/VaSidebarItemTitle.css";
var _hoisted_158 = { class: "va-sidebar__title va-sidebar-item-title" };
var _sfc_main100 = defineComponent99({
  ...{
    name: "VaSidebarItemTitle"
  },
  __name: "VaSidebarItemTitle",
  setup(__props) {
    return (_ctx, _cache) => {
      return openBlock97(), createElementBlock83("div", _hoisted_158, [
        renderSlot81(_ctx.$slots, "default")
      ]);
    };
  }
});

// node_modules/vuestic-ui/dist/es/src/components/va-sidebar/VaSidebarItem/index.js
var VaSidebarItemContent = withConfigTransport$1(_sfc_main99);
var VaSidebarItemTitle = withConfigTransport$1(_sfc_main100);
var VaSidebarItem = withConfigTransport$1(_sfc_main98);

// node_modules/vuestic-ui/dist/es/src/components/va-slider/VaSlider.vue_vue_type_script_setup_true_lang.js
import { defineComponent as defineComponent100, shallowRef as shallowRef32, ref as ref70, computed as computed170, useSlots as useSlots13, onMounted as onMounted31, onBeforeUnmount as onBeforeUnmount22, watch as watch52, openBlock as openBlock98, createElementBlock as createElementBlock84, mergeProps as mergeProps47, unref as unref88, renderSlot as renderSlot82, createCommentVNode as createCommentVNode49, normalizeStyle as normalizeStyle51, createTextVNode as createTextVNode28, toDisplayString as toDisplayString37, createVNode as createVNode39, createElementVNode as createElementVNode45, Fragment as Fragment28, renderList as renderList24, normalizeClass as normalizeClass48, normalizeProps as normalizeProps35, guardReactiveProps as guardReactiveProps30 } from "vue";

// node_modules/vuestic-ui/dist/es/src/components/va-slider/validateSlider.js
var validateSlider = (value, step, min, max, range) => {
  if (Array.isArray(value) && !range || !Array.isArray(value) && range) {
    warn(`The type "${Array.isArray(value) ? "array" : typeof value}" of prop "model-value" does not match prop "range = ${range}".`);
  }
  if (max < min) {
    warn(`The maximum value (${max}) can not be less than the minimum value (${min}).`);
  }
  if (!isDividable(max - min, step)) {
    warn(`Step ${step} is illegal. Slider is non-divisible (Min:Max ${min}:${max}).`);
  }
  const inRange = (v) => {
    if (v < min) {
      warn(`The value of the slider is ${v}, the minimum value is ${min}, the value of this slider can not be less than the minimum value`);
    } else if (v > max) {
      warn(`The value of the slider is ${v}, the maximum value is ${max}, the value of this slider can not be greater than the maximum value`);
    }
  };
  if (Array.isArray(value)) {
    value.map(inRange);
  } else {
    inRange(value);
  }
  return true;
};

// node_modules/vuestic-ui/dist/es/src/components/va-slider/VaSlider.vue_vue_type_script_setup_true_lang.js
import "D:/Desktop/forntend/Front_End_Web_Hotel_Nhom_2/my-nuxt-app/node_modules/vuestic-ui/dist/es/VaSlider.css";
var _hoisted_159 = {
  key: 0,
  class: "va-slider__input-wrapper",
  "aria-hidden": "true"
};
var _hoisted_228 = ["id"];
var _hoisted_320 = {
  key: 2,
  class: "va-input__label",
  "aria-hidden": "true"
};
var _hoisted_411 = ["tabindex", "onFocus"];
var _hoisted_59 = ["tabindex"];
var _hoisted_66 = {
  key: 3,
  class: "va-input__label--inverse",
  "aria-hidden": "true"
};
var _hoisted_74 = ["id"];
var _hoisted_82 = {
  key: 5,
  class: "va-slider__input-wrapper"
};
var _sfc_main101 = defineComponent100({
  ...{
    name: "VaSlider"
  },
  __name: "VaSlider",
  props: {
    ...useStatefulProps,
    ...useComponentPresetProp,
    range: { type: Boolean, default: false },
    modelValue: { type: [Number, Array], default: 0 },
    trackLabel: { type: [Function, String] },
    color: { type: String, default: "primary" },
    trackColor: { type: String, default: "" },
    labelColor: { type: String, default: "" },
    trackLabelVisible: { type: Boolean, default: false },
    min: { type: [Number, String], default: 0 },
    max: { type: [Number, String], default: 100 },
    step: { type: [Number, String], default: 1 },
    label: { type: String, default: "" },
    invertLabel: { type: Boolean, default: false },
    disabled: { type: Boolean, default: false },
    readonly: { type: Boolean, default: false },
    pins: { type: Boolean, default: false },
    iconPrepend: { type: String, default: "" },
    iconAppend: { type: String, default: "" },
    vertical: { type: Boolean, default: false },
    showTrack: { type: Boolean, default: true },
    ariaLabel: useTranslationProp("$t:sliderValue")
  },
  emits: ["drag-start", "drag-end", "change", "update:modelValue"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const { getColor, getHoverColor: getHoverColor2 } = useColors();
    const sliderContainer = shallowRef32();
    const dot = shallowRef32();
    const { setItemRefByIndex, itemRefs: dots } = useArrayRefs();
    const isFocused = ref70(false);
    const flag = ref70(false);
    const offset2 = ref70(0);
    const size2 = ref70(0);
    const defaultValue = props.range ? [0, 100] : 0;
    const { valueComputed } = useStateful(props, emit, "modelValue", { defaultValue });
    const currentSliderDotIndex = ref70(0);
    const hasMouseDown = ref70(false);
    const minComputed = useNumericProp("min");
    const maxComputed = useNumericProp("max");
    const stepComputed = useNumericProp("step");
    const orders = computed170(() => props.vertical ? [1, 0] : [0, 1]);
    const pinPositionStyle = computed170(() => props.vertical ? "bottom" : "left");
    const trackSizeStyle = computed170(() => props.vertical ? "height" : "width");
    const moreToLess = computed170(() => Array.isArray(val.value) && val.value[1] - stepComputed.value < val.value[0]);
    const lessToMore = computed170(() => Array.isArray(val.value) && val.value[0] + stepComputed.value > val.value[1]);
    const sliderClass = useBem("va-slider", () => ({
      ...pick(props, ["disabled", "readonly", "vertical"]),
      active: isFocused.value,
      horizontal: !props.vertical,
      grabbing: hasMouseDown.value
    }));
    const dotClass = useBem("va-slider__handler", () => ({
      onFocus: !props.range && (flag.value || isFocused.value),
      inactive: !isFocused.value
    }));
    const labelStyles = computed170(() => ({
      color: props.labelColor ? getColor(props.labelColor) : getColor(props.color)
    }));
    const trackStyles = computed170(() => ({
      backgroundColor: props.trackColor ? getColor(props.trackColor) : getHoverColor2(getColor(props.color))
    }));
    const calculatePercentage = (value) => {
      const min = minComputed.value;
      const max = maxComputed.value;
      return (clamp2(min, value, max) - min) / (max - min) * 100;
    };
    const processedStyles = computed170(() => {
      if (Array.isArray(val.value)) {
        const val0 = calculatePercentage(val.value[0]);
        const val1 = calculatePercentage(val.value[1]);
        return {
          [pinPositionStyle.value]: `${val0}%`,
          [trackSizeStyle.value]: `${val1 - val0}%`,
          backgroundColor: getColor(props.color),
          visibility: props.showTrack ? "visible" : "hidden"
        };
      } else {
        const val0 = calculatePercentage(val.value);
        return {
          [trackSizeStyle.value]: `${val0 > 100 ? 100 : val0}%`,
          backgroundColor: getColor(props.color),
          visibility: props.showTrack ? "visible" : "hidden"
        };
      }
    });
    const dottedStyles = computed170(() => {
      if (Array.isArray(val.value)) {
        const val0 = calculatePercentage(val.value[0]);
        const val1 = calculatePercentage(val.value[1]);
        return [
          {
            [pinPositionStyle.value]: `${val0}%`,
            backgroundColor: isActiveDot(0) ? getColor(props.color) : "#ffffff",
            borderColor: getColor(props.color)
          },
          {
            [pinPositionStyle.value]: `${val1}%`,
            backgroundColor: isActiveDot(1) ? getColor(props.color) : "#ffffff",
            borderColor: getColor(props.color)
          }
        ];
      } else {
        const val0 = calculatePercentage(val.value);
        return {
          [pinPositionStyle.value]: `${val0 > 100 ? 100 : val0}%`,
          backgroundColor: isActiveDot(0) ? getColor(props.color) : "#ffffff",
          borderColor: getColor(props.color)
        };
      }
    });
    const getDottedStyles = (index) => props.range ? dottedStyles.value[index] : dottedStyles.value;
    const val = computed170({
      get: () => valueComputed.value,
      set: (val2) => {
        if (!flag.value) {
          emit("change", val2);
        }
        valueComputed.value = val2;
      }
    });
    const getValueByOrder = (order) => props.range && order !== void 0 ? val.value[order] : val.value;
    const gap = computed170(() => {
      const total = (maxComputed.value - minComputed.value) / stepComputed.value;
      return size2.value / total;
    });
    const multiple = computed170(() => {
      const decimals = `${stepComputed.value}`.split(".")[1];
      return decimals ? Math.pow(10, decimals.length) : 1;
    });
    const pinsCol = computed170(() => (maxComputed.value - minComputed.value) / stepComputed.value - 1);
    const position = computed170(() => {
      return Array.isArray(val.value) ? [(val.value[0] - minComputed.value) / stepComputed.value * gap.value, (val.value[1] - minComputed.value) / stepComputed.value * gap.value] : (val.value - minComputed.value) / stepComputed.value * gap.value;
    });
    const limit = computed170(() => [0, size2.value]);
    const valueLimit = computed170(() => [minComputed.value, maxComputed.value]);
    const isActiveDot = (index) => {
      if (!isFocused.value && !flag.value || props.disabled || props.readonly) {
        return false;
      }
      return props.range ? currentSliderDotIndex.value === index : currentSliderDotIndex.value === 0;
    };
    const moveStart = (e, index = currentSliderDotIndex.value) => {
      var _a2, _b;
      e.preventDefault();
      if (!index) {
        if (!props.range) {
          index = 0;
        } else if (Array.isArray(position.value)) {
          const touch = "touches" in e ? e.touches[0] : e;
          const pos = getPos(touch);
          index = pos > (position.value[1] - position.value[0]) / 2 + position.value[0] ? 1 : 0;
        }
      }
      if (Array.isArray(val.value)) {
        currentSliderDotIndex.value = index;
      }
      Array.isArray(val.value) ? (_a2 = dots.value[index]) == null ? void 0 : _a2.focus() : (_b = dot.value) == null ? void 0 : _b.focus();
      flag.value = true;
      emit("drag-start");
    };
    const moving = (e) => {
      if (!hasMouseDown.value || !flag.value || props.disabled || props.readonly) {
        return;
      }
      e.preventDefault();
      if ("touches" in e) {
        setValueOnPos(getPos(e.touches[0]));
      } else {
        setValueOnPos(getPos(e));
      }
    };
    const moveEnd = () => {
      if (!props.disabled && !props.readonly) {
        if (flag.value) {
          emit("drag-end");
          emit("change", val.value);
        }
        flag.value = false;
        hasMouseDown.value = false;
      }
    };
    const clamp2 = (min, v, max) => Math.max(Math.min(v, max), min);
    const moveWithKeys = (event) => {
      var _a2, _b;
      if (![dots.value[0], dots.value[1], dot.value].includes(document.activeElement)) {
        return;
      }
      if (props.disabled || props.readonly) {
        return;
      }
      const moveDot = (where, which) => {
        if (Array.isArray(val.value)) {
          const value = val.value[which] + (where ? stepComputed.value : -stepComputed.value);
          const limitedValue = clamp2(minComputed.value, value, maxComputed.value);
          val.value = [
            which === 0 ? limitedValue : val.value[0],
            which === 1 ? limitedValue : val.value[1]
          ];
        } else {
          const value = val.value + (where ? stepComputed.value : -stepComputed.value);
          const limitedValue = clamp2(minComputed.value, value, maxComputed.value);
          val.value = limitedValue;
        }
      };
      if (["ArrowLeft", "ArrowUp", "ArrowRight", "ArrowDown"].includes(event.key)) {
        event.preventDefault();
      }
      const isActive = (el) => el === document.activeElement;
      if (props.range && Array.isArray(val.value)) {
        const isVerticalDot0More = (event2) => props.vertical && isActive(dots.value[0]) && event2.key === "ArrowUp";
        const isVerticalDot0Less = (event2) => props.vertical && isActive(dots.value[0]) && event2.key === "ArrowDown";
        const isVerticalDot1More = (event2) => props.vertical && isActive(dots.value[1]) && event2.key === "ArrowUp";
        const isVerticalDot1Less = (event2) => props.vertical && isActive(dots.value[1]) && event2.key === "ArrowDown";
        const isHorizontalDot0Less = (event2) => !props.vertical && isActive(dots.value[0]) && event2.key === "ArrowLeft";
        const isHorizontalDot0More = (event2) => !props.vertical && isActive(dots.value[0]) && event2.key === "ArrowRight";
        const isHorizontalDot1Less = (event2) => !props.vertical && isActive(dots.value[1]) && event2.key === "ArrowLeft";
        const isHorizontalDot1More = (event2) => !props.vertical && isActive(dots.value[1]) && event2.key === "ArrowRight";
        switch (true) {
          case ((isVerticalDot1Less(event) || isHorizontalDot1Less(event)) && moreToLess.value && val.value[0] !== minComputed.value):
            (_a2 = dots.value[0]) == null ? void 0 : _a2.focus();
            moveDot(0, 0);
            break;
          case ((isVerticalDot0More(event) || isHorizontalDot0More(event)) && lessToMore.value && val.value[1] !== maxComputed.value):
            (_b = dots.value[1]) == null ? void 0 : _b.focus();
            moveDot(1, 1);
            break;
          case ((isVerticalDot0Less(event) || isHorizontalDot0Less(event)) && val.value[0] !== minComputed.value):
            moveDot(0, 0);
            break;
          case ((isVerticalDot1More(event) || isHorizontalDot1More(event)) && val.value[1] !== maxComputed.value):
            moveDot(1, 1);
            break;
          case ((isVerticalDot1Less(event) || isHorizontalDot1Less(event)) && val.value[1] !== minComputed.value):
            moveDot(0, 1);
            break;
          case ((isVerticalDot0More(event) || isHorizontalDot0More(event)) && val.value[0] !== maxComputed.value):
            moveDot(1, 0);
            break;
        }
      } else {
        if (props.vertical) {
          if (event.key === "ArrowDown") {
            moveDot(0, 0);
          }
          if (event.key === "ArrowUp") {
            moveDot(1, 0);
          }
        } else {
          if (event.key === "ArrowLeft") {
            moveDot(0, 0);
          }
          if (event.key === "ArrowRight") {
            moveDot(1, 0);
          }
        }
      }
    };
    const checkActivePin = (pin) => {
      if (Array.isArray(val.value)) {
        return pin * stepComputed.value > val.value[0] && pin * stepComputed.value < val.value[1];
      } else {
        return pin * stepComputed.value < val.value;
      }
    };
    const pinPositionStep = computed170(() => stepComputed.value / (maxComputed.value - minComputed.value) * 100);
    const getPinStyles = (pin) => ({
      backgroundColor: checkActivePin(pin) ? getColor(props.color) : getHoverColor2(getColor(props.color)),
      [pinPositionStyle.value]: `${pin * pinPositionStep.value}%`,
      transition: hasMouseDown.value ? "none" : "var(--va-slider-pin-transition)"
    });
    const getPos = (e) => {
      getStaticData();
      return props.vertical ? offset2.value - e.clientY : e.clientX - offset2.value;
    };
    const getStaticData = () => {
      if (sliderContainer.value) {
        size2.value = sliderContainer.value[props.vertical ? "offsetHeight" : "offsetWidth"];
        offset2.value = sliderContainer.value.getBoundingClientRect()[pinPositionStyle.value];
      }
    };
    const getValueByIndex = (index) => {
      return (stepComputed.value * multiple.value * index + minComputed.value * multiple.value) / multiple.value;
    };
    const getTrackLabel = (val2, order) => {
      if (!props.trackLabel) {
        return val2;
      }
      return typeof props.trackLabel === "function" ? props.trackLabel(val2, order) : props.trackLabel;
    };
    const setCurrentValue = (newValue) => {
      const slider = currentSliderDotIndex.value;
      if (Array.isArray(val.value)) {
        if (isDiff(val.value[slider], newValue)) {
          if (slider === 0) {
            val.value = [newValue, val.value[1]];
          } else {
            val.value = [val.value[0], newValue];
          }
        }
      } else {
        if (newValue < minComputed.value) {
          val.value = minComputed.value;
        } else if (newValue > maxComputed.value) {
          val.value = maxComputed.value;
        } else if (isDiff(val.value, newValue)) {
          val.value = newValue;
        }
      }
    };
    const setValueOnPos = (pixelPosition) => {
      const range = limit.value;
      const valueRange = valueLimit.value;
      const dotToFocus = Array.isArray(val.value) ? dots.value[currentSliderDotIndex.value] : dot.value;
      dotToFocus == null ? void 0 : dotToFocus.focus();
      if (pixelPosition >= range[0] && pixelPosition <= range[1]) {
        const v = getValueByIndex(Math.round(pixelPosition / gap.value));
        if (currentSliderDotIndex.value) {
          if (Array.isArray(position.value) && Array.isArray(val.value) && pixelPosition <= position.value[0]) {
            val.value = [v, val.value[0]];
            currentSliderDotIndex.value = 0;
          } else {
            setCurrentValue(v);
          }
        } else {
          if (Array.isArray(position.value) && Array.isArray(val.value) && pixelPosition >= position.value[1]) {
            val.value = [val.value[1], v];
            currentSliderDotIndex.value = 1;
          } else {
            setCurrentValue(v);
          }
        }
      } else if (pixelPosition < range[0]) {
        setCurrentValue(valueRange[0]);
      } else {
        setCurrentValue(valueRange[1]);
      }
    };
    const isDiff = (a, b) => JSON.stringify(a) !== JSON.stringify(b);
    const clickOnContainer = (e) => {
      if (props.disabled || props.readonly) {
        return;
      }
      const pos = "touches" in e ? getPos(e.touches[0]) : getPos(e);
      if (Array.isArray(position.value)) {
        currentSliderDotIndex.value = pos > (position.value[1] - position.value[0]) / 2 + position.value[0] ? 1 : 0;
      }
      hasMouseDown.value = true;
      setValueOnPos(pos);
      moveStart(e, currentSliderDotIndex.value);
    };
    const bindEvents = () => {
      document.addEventListener("mousemove", moving);
      document.addEventListener("touchmove", moving, { passive: false });
      document.addEventListener("mouseup", moveEnd);
      document.addEventListener("mouseleave", moveEnd);
      document.addEventListener("touchcancel", moveEnd);
      document.addEventListener("touchend", moveEnd);
      document.addEventListener("keydown", moveWithKeys);
    };
    const unbindEvents = () => {
      document.removeEventListener("mousemove", moving);
      document.removeEventListener("touchmove", moving);
      document.removeEventListener("mouseup", moveEnd);
      document.removeEventListener("mouseleave", moveEnd);
      document.removeEventListener("touchcancel", moveEnd);
      document.removeEventListener("touchend", moveEnd);
      document.removeEventListener("keydown", moveWithKeys);
    };
    const componentId = useComponentUuid();
    const ariaLabelIdComputed = computed170(() => `aria-label-id-${componentId}`);
    const { tp } = useTranslation();
    const slots = useSlots13();
    const ariaAttributesComputed = computed170(() => ({
      role: "slider",
      "aria-valuemin": minComputed.value,
      "aria-valuemax": maxComputed.value,
      "aria-label": !slots.label && !props.label ? tp(props.ariaLabel, { value: String(val.value) }) : void 0,
      "aria-labelledby": slots.label || props.label ? ariaLabelIdComputed.value : void 0,
      "aria-orientation": props.vertical ? "vertical" : "horizontal",
      "aria-disabled": props.disabled,
      "aria-readonly": props.readonly,
      "aria-valuenow": !Array.isArray(val.value) ? val.value : void 0,
      "aria-valuetext": Array.isArray(val.value) ? String(val.value) : void 0
    }));
    onMounted31(() => {
      if (validateSlider(val.value, stepComputed.value, minComputed.value, maxComputed.value, props.range)) {
        getStaticData();
        bindEvents();
      }
    });
    onBeforeUnmount22(unbindEvents);
    watch52([
      val,
      () => stepComputed.value,
      () => minComputed.value,
      () => maxComputed.value,
      () => props.range
    ], ([value, step, min, max, range]) => {
      validateSlider(value, step, min, max, range);
    });
    watch52(hasMouseDown, (hasMouseDown2) => {
      document.documentElement.style.cursor = hasMouseDown2 ? "grabbing" : "";
    });
    return (_ctx, _cache) => {
      return openBlock98(), createElementBlock84("div", mergeProps47({
        class: ["va-slider", unref88(sliderClass)]
      }, ariaAttributesComputed.value), [
        (__props.vertical ? _ctx.$slots.append : _ctx.$slots.prepend) ? (openBlock98(), createElementBlock84("div", _hoisted_159, [
          renderSlot82(_ctx.$slots, __props.vertical ? "append" : "prepend")
        ])) : createCommentVNode49("", true),
        (_ctx.$slots.label || __props.label) && !__props.invertLabel ? (openBlock98(), createElementBlock84("span", {
          key: 1,
          class: "va-input__label",
          id: ariaLabelIdComputed.value,
          style: normalizeStyle51(labelStyles.value)
        }, [
          renderSlot82(_ctx.$slots, "label", {}, () => [
            createTextVNode28(toDisplayString37(__props.label), 1)
          ])
        ], 12, _hoisted_228)) : createCommentVNode49("", true),
        (__props.vertical ? __props.iconAppend : __props.iconPrepend) ? (openBlock98(), createElementBlock84("span", _hoisted_320, [
          createVNode39(unref88(VaIcon), {
            name: __props.vertical ? __props.iconAppend : __props.iconPrepend,
            color: unref88(getColor)(_ctx.$props.color),
            size: 16
          }, null, 8, ["name", "color"])
        ])) : createCommentVNode49("", true),
        createElementVNode45("div", {
          ref_key: "sliderContainer",
          ref: sliderContainer,
          class: "va-slider__container",
          onMousedown: clickOnContainer,
          onTouchstart: clickOnContainer
        }, [
          createElementVNode45("div", {
            class: "va-slider__track",
            "aria-hidden": "true",
            style: normalizeStyle51(trackStyles.value)
          }, null, 4),
          __props.pins ? (openBlock98(true), createElementBlock84(Fragment28, { key: 0 }, renderList24(pinsCol.value, (pin, i) => {
            return openBlock98(), createElementBlock84("div", {
              key: i,
              class: normalizeClass48(["va-slider__mark", { "va-slider__mark--active": checkActivePin(pin) }]),
              style: normalizeStyle51(getPinStyles(pin))
            }, null, 6);
          }), 128)) : createCommentVNode49("", true),
          _ctx.$props.range ? (openBlock98(), createElementBlock84(Fragment28, { key: 1 }, [
            createElementVNode45("div", {
              ref: "process",
              class: normalizeClass48(["va-slider__track va-slider__track--selected", { "va-slider__track--active": isFocused.value }]),
              "aria-hidden": "true",
              style: normalizeStyle51(processedStyles.value)
            }, null, 6),
            (openBlock98(true), createElementBlock84(Fragment28, null, renderList24(orders.value, (order) => {
              return openBlock98(), createElementBlock84("div", {
                key: "dot" + order,
                ref_for: true,
                ref: unref88(setItemRefByIndex)(order),
                class: normalizeClass48(["va-slider__handler", unref88(dotClass)]),
                style: normalizeStyle51(getDottedStyles(order)),
                tabindex: __props.disabled || __props.readonly ? void 0 : 0,
                onFocus: ($event) => (isFocused.value = true, currentSliderDotIndex.value = order),
                onBlur: _cache[0] || (_cache[0] = ($event) => isFocused.value = false)
              }, [
                isActiveDot(order) ? (openBlock98(), createElementBlock84("div", {
                  key: 0,
                  style: normalizeStyle51({ backgroundColor: unref88(getColor)(_ctx.$props.color) }),
                  class: "va-slider__handler__dot--focus"
                }, null, 4)) : createCommentVNode49("", true),
                __props.trackLabelVisible ? (openBlock98(), createElementBlock84("div", {
                  key: 1,
                  style: normalizeStyle51(labelStyles.value),
                  class: "va-slider__handler__dot--value"
                }, [
                  renderSlot82(_ctx.$slots, "trackLabel", normalizeProps35(guardReactiveProps30({ value: getValueByOrder(order), order })), () => [
                    createTextVNode28(toDisplayString37(getTrackLabel(getValueByOrder(order), order)), 1)
                  ])
                ], 4)) : createCommentVNode49("", true)
              ], 46, _hoisted_411);
            }), 128))
          ], 64)) : (openBlock98(), createElementBlock84(Fragment28, { key: 2 }, [
            createElementVNode45("div", {
              ref: "process",
              "aria-hidden": "true",
              class: normalizeClass48(["va-slider__track va-slider__track--selected", { "va-slider__track--active": isFocused.value }]),
              style: normalizeStyle51(processedStyles.value)
            }, null, 6),
            createElementVNode45("div", {
              ref_key: "dot",
              ref: dot,
              class: normalizeClass48(["va-slider__handler", unref88(dotClass)]),
              style: normalizeStyle51(dottedStyles.value),
              tabindex: _ctx.$props.disabled || _ctx.$props.readonly ? void 0 : 0,
              onFocus: _cache[1] || (_cache[1] = ($event) => isFocused.value = true),
              onBlur: _cache[2] || (_cache[2] = ($event) => isFocused.value = false)
            }, [
              isActiveDot(0) ? (openBlock98(), createElementBlock84("div", {
                key: 0,
                class: "va-slider__handler__dot--focus",
                style: normalizeStyle51({ backgroundColor: unref88(getColor)(_ctx.$props.color) })
              }, null, 4)) : createCommentVNode49("", true),
              __props.trackLabelVisible ? (openBlock98(), createElementBlock84("div", {
                key: 1,
                class: "va-slider__handler__dot--value",
                style: normalizeStyle51(labelStyles.value)
              }, [
                renderSlot82(_ctx.$slots, "trackLabel", normalizeProps35(guardReactiveProps30({ value: getValueByOrder() })), () => [
                  createTextVNode28(toDisplayString37(getTrackLabel(getValueByOrder())), 1)
                ])
              ], 4)) : createCommentVNode49("", true)
            ], 46, _hoisted_59)
          ], 64))
        ], 544),
        (__props.vertical ? __props.iconPrepend : __props.iconAppend) ? (openBlock98(), createElementBlock84("span", _hoisted_66, [
          createVNode39(unref88(VaIcon), {
            name: __props.vertical ? __props.iconPrepend : __props.iconAppend,
            color: unref88(getColor)(_ctx.$props.color),
            size: 16
          }, null, 8, ["name", "color"])
        ])) : createCommentVNode49("", true),
        (_ctx.$slots.label || __props.label) && __props.invertLabel ? (openBlock98(), createElementBlock84("span", {
          key: 4,
          class: "va-input__label va-input__label--inverse",
          style: normalizeStyle51(labelStyles.value),
          id: ariaLabelIdComputed.value
        }, [
          renderSlot82(_ctx.$slots, "label", {}, () => [
            createTextVNode28(toDisplayString37(__props.label), 1)
          ])
        ], 12, _hoisted_74)) : createCommentVNode49("", true),
        (__props.vertical ? _ctx.$slots.prepend : _ctx.$slots.append) ? (openBlock98(), createElementBlock84("div", _hoisted_82, [
          renderSlot82(_ctx.$slots, __props.vertical ? "prepend" : "append")
        ])) : createCommentVNode49("", true)
      ], 16);
    };
  }
});

// node_modules/vuestic-ui/dist/es/src/components/va-slider/index.js
var VaSlider = withConfigTransport$1(_sfc_main101);

// node_modules/vuestic-ui/dist/es/src/components/va-split/VaSplit.vue_vue_type_script_setup_true_lang.js
import { defineComponent as defineComponent101, shallowRef as shallowRef33, ref as ref72, onMounted as onMounted32, computed as computed171, watch as watch53, openBlock as openBlock99, createElementBlock as createElementBlock85, normalizeClass as normalizeClass49, unref as unref89, createElementVNode as createElementVNode46, normalizeStyle as normalizeStyle52, renderSlot as renderSlot83, normalizeProps as normalizeProps36, guardReactiveProps as guardReactiveProps31, withModifiers as withModifiers21, createVNode as createVNode40 } from "vue";

// node_modules/vuestic-ui/dist/es/src/utils/is-number.js
var isNumber = (value) => typeof value === "number";

// node_modules/vuestic-ui/dist/es/src/components/va-split/useSplitDragger.js
import { ref as ref71 } from "vue";
var useSplitDraggerProps = {
  vertical: { type: Boolean, default: false },
  disabled: { type: Boolean, default: false }
};
var useSplitDragger = (containerSizeComputed, splitterPositionComputed, props) => {
  const isDragging = ref71(false);
  const dragStartPosition = ref71(0);
  const dragStartSplitterPosition = ref71(0);
  const currentSplitterPosition = ref71(0);
  const getEventPosition = (e, eventName) => {
    const event = e.type === eventName ? e : e.changedTouches[0];
    return props.vertical ? event.pageY : event.pageX;
  };
  const startDragging = (e) => {
    if (props.disabled || !containerSizeComputed.value) {
      return;
    }
    isDragging.value = true;
    dragStartPosition.value = getEventPosition(e, "mousedown");
    dragStartSplitterPosition.value = splitterPositionComputed.value;
  };
  const processDragging = (e) => {
    if (!isDragging.value) {
      return;
    }
    const currentPosition = getEventPosition(e, "mousemove");
    const distance = currentPosition - dragStartPosition.value;
    currentSplitterPosition.value = dragStartSplitterPosition.value + Math.floor(distance / containerSizeComputed.value * 100);
  };
  const stopDragging = () => {
    isDragging.value = false;
  };
  useEvent(["mousemove", "touchmove"], processDragging);
  useEvent(["mouseup", "touchcancel"], stopDragging);
  return { isDragging, startDragging, currentSplitterPosition };
};

// node_modules/vuestic-ui/dist/es/src/components/va-split/VaSplit.vue_vue_type_script_setup_true_lang.js
import "D:/Desktop/forntend/Front_End_Web_Hotel_Nhom_2/my-nuxt-app/node_modules/vuestic-ui/dist/es/VaSplit.css";
var _hoisted_160 = ["aria-label"];
var _hoisted_229 = { class: "va-split__dragger" };
var _sfc_main102 = defineComponent101({
  ...{
    name: "VaSplit"
  },
  __name: "VaSplit",
  props: {
    ...useComponentPresetProp,
    ...useSplitDraggerProps,
    ...useStatefulProps,
    modelValue: {
      type: Number,
      default: 50,
      validator: (v) => v <= 100
    },
    maximization: { type: Boolean, default: false },
    maximizeStart: { type: Boolean, default: false },
    limits: {
      type: Array,
      default: () => [0, 0]
    },
    snapping: {
      type: Array,
      default: void 0
    },
    snappingRange: { type: [Number, String], default: 4 },
    ariaLabel: useTranslationProp("$t:splitPanels")
  },
  emits: [...useStatefulEmits],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const splitPanelsContainer = shallowRef33();
    const { valueComputed } = useStateful(props, emit);
    const containerSize = ref72();
    const bodyFontSize = ref72(16);
    const handleContainerResize = () => {
      var _a2;
      const { width, height } = ((_a2 = splitPanelsContainer.value) == null ? void 0 : _a2.getBoundingClientRect()) || { width: 0, height: 0 };
      containerSize.value = props.vertical ? height : width;
      bodyFontSize.value = parseFloat(getComputedStyle(document.documentElement).fontSize);
    };
    onMounted32(handleContainerResize);
    useResizeObserver([splitPanelsContainer], handleContainerResize);
    const convertToPercents = (v, type) => {
      let numberValue = "";
      let measureValue = "";
      if (isNumber(v)) {
        return v;
      }
      v.split("").filter((char) => char && char !== " ").forEach((char) => {
        !isNaN(+char) ? numberValue += char : measureValue += char;
      });
      switch (measureValue) {
        case "%":
          return +numberValue;
        case "px":
          return +numberValue / containerSize.value * 100;
        case "rem":
          return +numberValue * bodyFontSize.value / containerSize.value * 100;
        case "any":
          return ["min", "snapping"].includes(type) ? 0 : 100;
        case "":
          return 100;
        default:
          warn("Invalid limits measure!");
          return 0;
      }
    };
    const getPanelMinMax = (v) => {
      if (v === "undefined" || !containerSize.value) {
        return;
      }
      let minPercents = 0;
      let maxPercents = 100;
      if (isString(v) || isNumber(v)) {
        minPercents = convertToPercents(v, "min");
      }
      if (Array.isArray(v)) {
        minPercents = convertToPercents(v[0], "min");
        maxPercents = convertToPercents(v[1], "max");
      }
      if (minPercents > maxPercents) {
        warn(`Min panels size can not be larger than max one! Passed limit: ${v}.`);
        maxPercents = minPercents;
      }
      return { min: minPercents ?? 0, max: maxPercents ?? 100 };
    };
    const startPanelMinMax = computed171(() => getPanelMinMax(props.limits[0]) ?? { min: 0, max: 100 });
    const endPanelMinMax = computed171(() => getPanelMinMax(props.limits[1]) ?? { min: 0, max: 100 });
    const endPanelMinChecked = computed171(() => {
      const passedCheck = !(startPanelMinMax.value.min + endPanelMinMax.value.min > 100);
      if (!passedCheck) {
        warn("The sum of different panels min sizes should be lesser or equal to 100% of the container size!");
      }
      return !passedCheck ? 100 - startPanelMinMax.value.min : endPanelMinMax.value.min;
    });
    const panelsMinMax = computed171(() => {
      if (Math.ceil(endPanelMinMax.value.max + startPanelMinMax.value.max) < 100) {
        warn("The sum of different panels max sizes should be equal to 100% of the container size!");
      }
      return {
        start: {
          min: startPanelMinMax.value.min,
          max: Math.min(startPanelMinMax.value.max, 100 - endPanelMinChecked.value)
        },
        end: {
          min: endPanelMinChecked.value,
          max: Math.min(endPanelMinMax.value.max, 100 - startPanelMinMax.value.min)
        }
      };
    });
    const checkSnappingLimitsCondition = (el) => el >= panelsMinMax.value.start.min && el >= panelsMinMax.value.end.min && el <= panelsMinMax.value.start.max && el <= panelsMinMax.value.end.max;
    const snappingMarksPosition = computed171(() => {
      if (!Array.isArray(props.snapping) || !containerSize.value) {
        return;
      }
      let result = props.snapping.map((el) => convertToPercents(el, "snapping"));
      if (!result.every(checkSnappingLimitsCondition)) {
        const filteredMarks = result.filter(checkSnappingLimitsCondition);
        warn(`Some of the snapping marks (${result}) are not in allowed range (${Object.values(panelsMinMax.value.start).join("-")} / ${Object.values(panelsMinMax.value.end).join("-")}) and will be removed (${filteredMarks})!`);
        result = filteredMarks;
      }
      const checkSnappingRange = () => {
        return result.every((el, index, array) => {
          if (!array[index + 1]) {
            return true;
          }
          return Math.abs(el - array[index + 1]) > Number(props.snappingRange);
        });
      };
      if (!checkSnappingRange()) {
        warn("Distance between some snapping marks is lesser than snapping range!");
      }
      return result;
    });
    const snappingRangeParsed = computed171(() => convertToPercents(props.snappingRange, "snapping"));
    const splitterPosition = ref72(valueComputed.value);
    const splitterPositionComputed = computed171(() => {
      if (snappingMarksPosition.value) {
        const nearestSnappingMark = snappingMarksPosition.value.find((el) => {
          return splitterPosition.value + snappingRangeParsed.value > el && splitterPosition.value - snappingRangeParsed.value < el;
        });
        if (nearestSnappingMark) {
          return nearestSnappingMark;
        }
      }
      return clamp(
        splitterPosition.value,
        Math.max(panelsMinMax.value.start.min, 100 - panelsMinMax.value.end.max),
        Math.min(panelsMinMax.value.start.max, 100 - panelsMinMax.value.end.min)
      );
    });
    const {
      isDragging,
      startDragging,
      currentSplitterPosition
    } = useSplitDragger(containerSize, splitterPositionComputed, props);
    const maximizePanel = () => {
      if (!props.maximization || props.disabled) {
        return;
      }
      splitterPosition.value = props.maximizeStart ? panelsMinMax.value.start.max : 100 - panelsMinMax.value.end.max;
    };
    watch53(valueComputed, (v) => {
      if (v < panelsMinMax.value.start.min || v > 100 - panelsMinMax.value.end.min) {
        warn("Incorrect `modelValue`. Check current `limits` prop value.");
      }
      splitterPosition.value = v;
    }, { immediate: true });
    watch53(currentSplitterPosition, (v) => {
      splitterPosition.value = v;
    });
    watch53(isDragging, (v) => {
      if (!v) {
        valueComputed.value = splitterPositionComputed.value;
      }
      document.documentElement.style.cursor = v ? "var(--va-split-dragging-cursor)" : "";
    });
    const sizePropertyComputed = computed171(() => props.vertical ? "height" : "width");
    const getPanelStyle = (position) => {
      let sizeValue = position === "start" ? splitterPositionComputed.value : 100 - splitterPositionComputed.value;
      if (sizeValue < 0) {
        sizeValue = 0;
      }
      if (sizeValue > 100) {
        sizeValue = 100;
      }
      return { [sizePropertyComputed.value]: `${sizeValue}%` };
    };
    const draggerStyleComputed = computed171(() => {
      if (props.disabled) {
        return {};
      }
      if (isDragging.value) {
        return { cursor: "var(--va-split-dragging-cursor)" };
      }
      return { cursor: props.vertical ? "var(--va-split-vertical-dragger-cursor)" : "var(--va-split-horizontal-dragger-cursor)" };
    });
    const classComputed = useBem("va-split", () => ({
      horizontal: !props.vertical,
      vertical: props.vertical,
      dragging: isDragging.value
    }));
    const { t, tp } = useTranslation();
    return (_ctx, _cache) => {
      return openBlock99(), createElementBlock85("section", {
        ref_key: "splitPanelsContainer",
        ref: splitPanelsContainer,
        class: normalizeClass49(["va-split", unref89(classComputed)]),
        "aria-label": unref89(tp)(_ctx.$props.ariaLabel)
      }, [
        createElementVNode46("div", {
          class: "va-split__panel",
          style: normalizeStyle52(getPanelStyle("start"))
        }, [
          renderSlot83(_ctx.$slots, "start", normalizeProps36(guardReactiveProps31({ containerSize: containerSize.value })))
        ], 4),
        createElementVNode46("div", _hoisted_229, [
          createElementVNode46("div", {
            class: "va-split__dragger__overlay",
            style: normalizeStyle52(draggerStyleComputed.value),
            onMousedown: _cache[0] || (_cache[0] = withModifiers21(
              //@ts-ignore
              (...args) => unref89(startDragging) && unref89(startDragging)(...args),
              ["prevent"]
            )),
            onTouchstart: _cache[1] || (_cache[1] = withModifiers21(
              //@ts-ignore
              (...args) => unref89(startDragging) && unref89(startDragging)(...args),
              ["prevent"]
            )),
            onDblclick: withModifiers21(maximizePanel, ["prevent"]),
            onContextmenu: _cache[2] || (_cache[2] = withModifiers21(() => {
            }, ["prevent"])),
            onDragstart: _cache[3] || (_cache[3] = withModifiers21(() => {
            }, ["prevent"]))
          }, [
            renderSlot83(_ctx.$slots, "grabber", {}, () => [
              createVNode40(unref89(VaDivider), {
                class: "va-split__dragger__default",
                vertical: !_ctx.$props.vertical
              }, null, 8, ["vertical"])
            ])
          ], 36)
        ]),
        createElementVNode46("div", {
          class: "va-split__panel",
          style: normalizeStyle52(getPanelStyle("end"))
        }, [
          renderSlot83(_ctx.$slots, "end", normalizeProps36(guardReactiveProps31({ containerSize: containerSize.value })))
        ], 4)
      ], 10, _hoisted_160);
    };
  }
});

// node_modules/vuestic-ui/dist/es/src/components/va-split/index.js
var VaSplit = withConfigTransport$1(_sfc_main102);

// node_modules/vuestic-ui/dist/es/src/components/va-tabs/VaTabs.vue_vue_type_script_setup_true_lang.js
import { defineComponent as defineComponent102, shallowRef as shallowRef34, ref as ref73, reactive as reactive6, computed as computed172, unref as unref90, watchEffect as watchEffect11, provide as provide9, watch as watch54, onMounted as onMounted33, openBlock as openBlock100, createElementBlock as createElementBlock86, normalizeClass as normalizeClass50, createElementVNode as createElementVNode47, createBlock as createBlock50, createCommentVNode as createCommentVNode50, normalizeStyle as normalizeStyle53, createVNode as createVNode41, withCtx as withCtx54, renderSlot as renderSlot84 } from "vue";

// node_modules/vuestic-ui/dist/es/src/components/va-tabs/types.js
var TabsViewKey = Symbol("TabsView");

// node_modules/vuestic-ui/dist/es/src/components/va-tabs/VaTabs.vue_vue_type_script_setup_true_lang.js
import "D:/Desktop/forntend/Front_End_Web_Hotel_Nhom_2/my-nuxt-app/node_modules/vuestic-ui/dist/es/VaTabs.css";
var _hoisted_161 = ["aria-disabled"];
var _hoisted_230 = createElementVNode47("div", { class: "va-tabs__slider" }, null, -1);
var _hoisted_321 = [
  _hoisted_230
];
var _hoisted_412 = { class: "va-tabs__tabs-items" };
var _hoisted_510 = { class: "va-tabs__content" };
var getClientWidth = (element) => (element == null ? void 0 : element.clientWidth) || 0;
var _sfc_main103 = defineComponent102({
  ...{
    name: "VaTabs"
  },
  __name: "VaTabs",
  props: {
    ...useStatefulProps,
    ...useComponentPresetProp,
    modelValue: { type: [String, Number], default: null },
    left: { type: Boolean, default: true },
    right: { type: Boolean, default: false },
    center: { type: Boolean, default: false },
    grow: { type: Boolean, default: false },
    hidePagination: { type: Boolean, default: false },
    disabled: { type: Boolean, default: false },
    hideSlider: { type: Boolean, default: false },
    vertical: { type: Boolean, default: false },
    color: { type: String, default: "primary" },
    prevIcon: { type: String, default: "va-arrow-left" },
    nextIcon: { type: String, default: "va-arrow-right" },
    ariaMoveRightLabel: useTranslationProp("$t:movePaginationLeft"),
    ariaMoveLeftLabel: useTranslationProp("$t:movePaginationRight")
  },
  emits: ["update:modelValue", "click:next", "click:prev"],
  setup(__props, { expose: __expose, emit: __emit }) {
    const { tp } = useTranslation();
    const props = __props;
    const emit = __emit;
    const wrapper = shallowRef34();
    const container = shallowRef34();
    const tabs = shallowRef34();
    const tabsList = ref73([]);
    const sliderHeight = ref73(null);
    const sliderWidth = ref73(null);
    const sliderOffsetX = ref73(0);
    const sliderOffsetY = ref73(0);
    const showPagination = ref73(false);
    const tabsContentOffset = ref73(0);
    const startingXPoint = ref73(0);
    const animationIncluded = ref73(false);
    const { valueComputed: tabSelected } = useStateful(props, emit);
    const tabConfig = reactive6({
      VaTab: {
        color: props.color
      }
    });
    const computedClass = computed172(() => {
      const { left, right, center, grow, disabled } = props;
      return {
        "va-tabs__container--left": left && !right && !center && !grow,
        "va-tabs__container--right": right,
        "va-tabs__container--center": center,
        "va-tabs__container--grow": grow,
        "va-tabs__container--disabled": disabled
      };
    });
    const computedTabsClass = computed172(() => ({ "va-tabs--vertical": props.vertical }));
    const { getColor } = useColors();
    const colorComputed = computed172(() => getColor(props.color));
    const sliderStyles = computed172(() => {
      if (props.hideSlider) {
        return { display: "none" };
      }
      return {
        backgroundColor: colorComputed.value,
        height: props.vertical ? `${sliderHeight.value}px` : "",
        width: props.vertical ? "" : `${sliderWidth.value}px`,
        transform: `translateY(-${sliderOffsetY.value}px) translateX(${sliderOffsetX.value}px)`,
        transition: animationIncluded.value ? "var(--va-tabs-slider-wrapper-transition)" : ""
      };
    });
    const paginationControlledStyles = computed172(() => {
      if (props.vertical) {
        return {
          transform: "translateX(0px)"
        };
      }
      return {
        transform: `translateX(${startingXPoint.value - tabsContentOffset.value}px)`,
        transition: animationIncluded.value ? "var(--va-tabs-slider-transition)" : "",
        position: props.hidePagination ? "unset" : "absolute"
      };
    });
    const disablePaginationLeft = computed172(() => tabsContentOffset.value === 0);
    const disablePaginationRight = computed172(() => {
      const lastTab = tabsList.value[tabsList.value.length - 1];
      const leftSidePosition = unref90(lastTab.leftSidePosition);
      const rightSidePosition = unref90(lastTab.rightSidePosition);
      const containerClientWidth = getClientWidth(container.value);
      return rightSidePosition <= tabsContentOffset.value + containerClientWidth || leftSidePosition <= tabsContentOffset.value;
    });
    const resetSliderSizes = () => {
      sliderWidth.value = 0;
      sliderHeight.value = 0;
    };
    const moveToTab = (tab) => {
      const containerClientWidth = getClientWidth(container.value);
      const leftSidePosition = unref90(tab.leftSidePosition);
      const rightSidePosition = unref90(tab.rightSidePosition);
      if (!showPagination.value) {
        tabsContentOffset.value = 0;
        return;
      }
      if (leftSidePosition - tabsContentOffset.value >= 0 && rightSidePosition - tabsContentOffset.value <= containerClientWidth) {
        return;
      }
      if (leftSidePosition - tabsContentOffset.value < 0) {
        tabsContentOffset.value = leftSidePosition;
        return;
      }
      if (rightSidePosition - tabsContentOffset.value > containerClientWidth) {
        tabsContentOffset.value = rightSidePosition - containerClientWidth;
        return;
      }
      tabsContentOffset.value = 0;
    };
    const updateStartingXPoint = () => {
      startingXPoint.value = 0;
      if (!showPagination.value) {
        return;
      }
      const containerClientWidth = getClientWidth(container.value);
      const tabsClientWidth = getClientWidth(tabs.value);
      if (props.right) {
        startingXPoint.value = tabsClientWidth - containerClientWidth;
      } else if (props.center) {
        startingXPoint.value = Math.floor((tabsClientWidth - containerClientWidth) / 2);
      }
    };
    const updateTabsState = () => {
      resetSliderSizes();
      tabsList.value.forEach((tab) => {
        var _a2;
        tab.updateSidePositions();
        const isTabSelected = (((_a2 = tab.name) == null ? void 0 : _a2.value) || tab.id) === tabSelected.value;
        tab.isActive = tab.isActiveRouterLink || isTabSelected;
        if (tab.isActive) {
          moveToTab(tab);
          updateSlider(tab);
        }
      });
      updateStartingXPoint();
    };
    watchEffect11(() => {
      updateTabsState();
    });
    const updatePagination = () => {
      const tabsClientWidth = getClientWidth(tabs.value);
      const wrapperClientWidth = getClientWidth(wrapper.value);
      requestAnimationFrame(() => {
        showPagination.value = !!(tabs.value && wrapper.value && tabsClientWidth > wrapperClientWidth);
      });
    };
    const movePaginationLeft = () => {
      var _a2, _b;
      const containerClientWidth = getClientWidth(container.value);
      let offsetToSet = tabsContentOffset.value - containerClientWidth;
      for (let i = 0; i < tabsList.value.length - 1; i++) {
        const currentTabLeftSidePosition = unref90((_a2 = tabsList.value[i]) == null ? void 0 : _a2.leftSidePosition);
        const nextTabLeftSidePosition = unref90((_b = tabsList.value[i + 1]) == null ? void 0 : _b.leftSidePosition);
        if (currentTabLeftSidePosition > offsetToSet && currentTabLeftSidePosition < tabsContentOffset.value || nextTabLeftSidePosition >= tabsContentOffset.value) {
          offsetToSet = currentTabLeftSidePosition;
          break;
        }
      }
      tabsContentOffset.value = Math.max(0, offsetToSet);
      emit("click:prev");
    };
    const movePaginationRight = () => {
      var _a2;
      const containerClientWidth = getClientWidth(container.value);
      const containerRightSide = tabsContentOffset.value + containerClientWidth;
      let offsetToSet = containerRightSide;
      for (let i = 0; i < tabsList.value.length - 1; i++) {
        const rightSidePosition2 = unref90(tabsList.value[i].rightSidePosition);
        if (rightSidePosition2 > containerRightSide) {
          offsetToSet = unref90(tabsList.value[i].leftSidePosition);
          if (tabsContentOffset.value < offsetToSet) {
            break;
          }
        }
      }
      const rightSidePosition = unref90((_a2 = tabsList.value[tabsList.value.length - 1]) == null ? void 0 : _a2.rightSidePosition);
      const maxOffset = rightSidePosition - containerClientWidth;
      offsetToSet = Math.min(maxOffset, offsetToSet);
      tabsContentOffset.value = Math.max(0, offsetToSet);
      emit("click:next");
    };
    const updateSlider = (tab) => {
      var _a2;
      const tabElement = unref90(tab.tabElement);
      const tabOffsetTop = (tabElement == null ? void 0 : tabElement.offsetTop) || 0;
      const tabOffsetLeft = (tabElement == null ? void 0 : tabElement.offsetLeft) || 0;
      const tabClientHeight = (tabElement == null ? void 0 : tabElement.clientHeight) || 0;
      const tabClientWidth = (tabElement == null ? void 0 : tabElement.clientWidth) || 0;
      if (props.vertical) {
        const containerClientHeight = ((_a2 = container.value) == null ? void 0 : _a2.clientHeight) || 0;
        const calculatedSliderOffsetY = containerClientHeight - tabOffsetTop - tabClientHeight;
        sliderOffsetY.value = Math.max(calculatedSliderOffsetY, 0);
        sliderHeight.value = tabClientHeight;
        sliderOffsetX.value = 0;
        sliderWidth.value = 0;
      } else {
        sliderOffsetX.value = tabOffsetLeft;
        sliderWidth.value = tabClientWidth;
        sliderOffsetY.value = 0;
        sliderHeight.value = 0;
      }
    };
    const includeAnimation = () => {
      if (!animationIncluded.value) {
        requestAnimationFrame(() => {
          animationIncluded.value = true;
        });
      }
    };
    const selectTab = (tab) => {
      var _a2;
      if (!tab) {
        return;
      }
      tabSelected.value = ((_a2 = tab.name) == null ? void 0 : _a2.value) || tab.id;
      if (props.stateful) {
        updateTabsState();
      }
    };
    const registerTab = (tab) => {
      var _a2;
      const idx = tabsList.value.push(tab) - 1;
      tab.id = ((_a2 = tab.name) == null ? void 0 : _a2.value) || idx;
    };
    const unregisterTab = (tab) => {
      tabsList.value = tabsList.value.filter((filteredTab) => filteredTab.id !== tab.id);
      tabsList.value.forEach((tabListItem, idx) => {
        var _a2;
        tabListItem.id = ((_a2 = tabListItem.name) == null ? void 0 : _a2.value) || idx;
      });
    };
    provide9(TabsViewKey, {
      parentDisabled: props.disabled,
      selectTab,
      moveToTab,
      registerTab,
      unregisterTab
    });
    watch54(() => props.modelValue, updateTabsState);
    useResizeObserver([wrapper], updatePagination);
    useResizeObserver([container], updateTabsState);
    onMounted33(() => {
      requestAnimationFrame(() => {
        includeAnimation();
      });
    });
    __expose({
      selectTab,
      moveToTab,
      movePaginationLeft,
      movePaginationRight
    });
    return (_ctx, _cache) => {
      return openBlock100(), createElementBlock86("div", {
        class: normalizeClass50(["va-tabs", computedTabsClass.value])
      }, [
        createElementVNode47("div", {
          ref_key: "wrapper",
          ref: wrapper,
          class: "va-tabs__wrapper",
          role: "tablist",
          "aria-disabled": _ctx.$props.disabled
        }, [
          showPagination.value && !_ctx.$props.hidePagination ? (openBlock100(), createBlock50(unref90(VaButton), {
            key: 0,
            class: "va-tabs__pagination",
            "aria-label": unref90(tp)(_ctx.$props.ariaMoveLeftLabel),
            size: "medium",
            disabled: disablePaginationLeft.value,
            color: __props.color,
            preset: "secondary",
            icon: _ctx.$props.prevIcon,
            onClick: movePaginationLeft
          }, null, 8, ["aria-label", "disabled", "color", "icon"])) : createCommentVNode50("", true),
          createElementVNode47("div", {
            ref_key: "container",
            ref: container,
            class: normalizeClass50(["va-tabs__container", computedClass.value])
          }, [
            createElementVNode47("div", {
              ref_key: "tabs",
              ref: tabs,
              class: "va-tabs__tabs",
              style: normalizeStyle53(paginationControlledStyles.value)
            }, [
              createElementVNode47("div", {
                class: "va-tabs__slider-wrapper",
                "aria-hidden": "true",
                style: normalizeStyle53(sliderStyles.value)
              }, _hoisted_321, 4),
              createVNode41(unref90(_sfc_main4), { components: tabConfig }, {
                default: withCtx54(() => [
                  createElementVNode47("div", _hoisted_412, [
                    renderSlot84(_ctx.$slots, "tabs")
                  ])
                ]),
                _: 3
              }, 8, ["components"])
            ], 4)
          ], 2),
          showPagination.value && !_ctx.$props.hidePagination ? (openBlock100(), createBlock50(unref90(VaButton), {
            key: 1,
            class: "va-tabs__pagination",
            "aria-label": unref90(tp)(_ctx.$props.ariaMoveRightLabel),
            size: "medium",
            color: __props.color,
            disabled: disablePaginationRight.value,
            preset: "secondary",
            icon: _ctx.$props.nextIcon,
            onClick: movePaginationRight
          }, null, 8, ["aria-label", "color", "disabled", "icon"])) : createCommentVNode50("", true)
        ], 8, _hoisted_161),
        createElementVNode47("div", _hoisted_510, [
          renderSlot84(_ctx.$slots, "default")
        ])
      ], 2);
    };
  }
});

// node_modules/vuestic-ui/dist/es/src/components/va-tabs/index.js
var VaTabs = withConfigTransport$1(_sfc_main103);

// node_modules/vuestic-ui/dist/es/src/components/va-tabs/components/VaTab/VaTab.vue_vue_type_script_setup_true_lang.js
import { defineComponent as defineComponent103, shallowRef as shallowRef35, computed as computed173, ref as ref74, inject as inject10, watch as watch55, onMounted as onMounted34, onBeforeUnmount as onBeforeUnmount23, openBlock as openBlock101, createBlock as createBlock51, resolveDynamicComponent as resolveDynamicComponent11, unref as unref91, mergeProps as mergeProps48, withKeys as withKeys25, toHandlers as toHandlers8, withCtx as withCtx55, createElementVNode as createElementVNode48, renderSlot as renderSlot85, createCommentVNode as createCommentVNode51, toDisplayString as toDisplayString38, nextTick as nextTick12 } from "vue";
import "D:/Desktop/forntend/Front_End_Web_Hotel_Nhom_2/my-nuxt-app/node_modules/vuestic-ui/dist/es/VaTab.css";
var _hoisted_162 = { class: "va-tab__content" };
var _hoisted_231 = ["textContent"];
var _sfc_main104 = defineComponent103({
  ...{
    name: "VaTab"
  },
  __name: "VaTab",
  props: {
    ...useRouterLinkProps,
    ...useComponentPresetProp,
    selected: { type: Boolean, default: false },
    color: { type: String, default: "" },
    icon: { type: String, default: "" },
    label: { type: String, default: "" },
    disabled: { type: Boolean },
    name: { type: [String, Number] },
    tag: { type: String, default: "div" }
  },
  emits: ["click", "keydown-enter", "focus"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const rootElement = shallowRef35();
    const tabElement = computed173(() => unwrapEl(rootElement.value));
    const isActive = ref74(false);
    const hoverState = ref74(false);
    const rightSidePosition = ref74(0);
    const leftSidePosition = ref74(0);
    const { keyboardFocusListeners, hasKeyboardFocus } = useKeyboardOnlyFocus();
    const { tagComputed, isActiveRouterLink, linkAttributesComputed } = useRouterLink(props);
    const classComputed = computed173(() => ({ "va-tab--disabled": props.disabled }));
    const {
      parentDisabled,
      selectTab,
      moveToTab,
      registerTab,
      unregisterTab
    } = inject10(TabsViewKey, {
      parentDisabled: false,
      tabsList: [],
      selectTab: (tab) => tab,
      moveToTab: (tab) => tab,
      registerTab: (tab) => tab,
      unregisterTab: (tab) => tab
    });
    const tabIndexComputed = computed173(() => props.disabled || parentDisabled ? -1 : 0);
    const { getColor } = useColors();
    const colorComputed = computed173(() => getColor(props.color));
    const computedStyle = computed173(() => ({
      color: hoverState.value || isActive.value ? colorComputed.value : "inherit"
    }));
    const updateHoverState = (isHover) => {
      hoverState.value = isHover;
    };
    const updateSidePositions = () => {
      var _a2, _b;
      const componentOffsetLeft = ((_a2 = tabElement.value) == null ? void 0 : _a2.offsetLeft) || 0;
      const componentOffsetWidth = ((_b = tabElement.value) == null ? void 0 : _b.offsetWidth) || 0;
      rightSidePosition.value = componentOffsetLeft + componentOffsetWidth;
      leftSidePosition.value = componentOffsetLeft;
    };
    const width = useElementWidth(rootElement);
    watch55(width, () => {
      updateSidePositions();
    });
    const onTabClick = async () => {
      await nextTick12();
      selectTab(tabComponent);
      emit("click");
    };
    const onTabKeydown = async () => {
      await nextTick12();
      selectTab(tabComponent);
      emit("keydown-enter");
    };
    const onFocus = () => {
      if (hasKeyboardFocus.value) {
        moveToTab(tabComponent);
      }
      emit("focus");
    };
    const tabComponent = {
      name: computed173(() => props.name),
      id: null,
      tabElement,
      isActive,
      tabIndexComputed,
      isActiveRouterLink,
      rightSidePosition,
      leftSidePosition,
      onTabClick,
      onTabKeydown,
      onFocus,
      updateSidePositions
    };
    onMounted34(() => {
      registerTab(tabComponent);
    });
    onBeforeUnmount23(() => {
      unregisterTab(tabComponent);
    });
    return (_ctx, _cache) => {
      return openBlock101(), createBlock51(resolveDynamicComponent11(unref91(tagComputed)), mergeProps48({
        ref_key: "rootElement",
        ref: rootElement,
        class: ["va-tab", classComputed.value],
        role: "tab",
        "aria-selected": isActive.value,
        "aria-disabled": _ctx.$props.disabled || unref91(parentDisabled),
        style: computedStyle.value,
        onMouseenter: _cache[0] || (_cache[0] = ($event) => updateHoverState(true)),
        onMouseleave: _cache[1] || (_cache[1] = ($event) => updateHoverState(false)),
        onFocus,
        onClick: onTabClick,
        onKeydown: withKeys25(onTabKeydown, ["enter"]),
        tabindex: tabIndexComputed.value
      }, toHandlers8(unref91(keyboardFocusListeners)), unref91(linkAttributesComputed)), {
        default: withCtx55(() => [
          createElementVNode48("div", _hoisted_162, [
            renderSlot85(_ctx.$slots, "default", {}, () => [
              __props.icon ? (openBlock101(), createBlock51(unref91(VaIcon), {
                key: 0,
                class: "va-tab__icon",
                size: "small",
                name: __props.icon
              }, null, 8, ["name"])) : createCommentVNode51("", true),
              createElementVNode48("span", {
                class: "va-tab__label",
                textContent: toDisplayString38(__props.label)
              }, null, 8, _hoisted_231)
            ])
          ])
        ]),
        _: 3
      }, 16, ["aria-selected", "aria-disabled", "class", "style", "tabindex"]);
    };
  }
});

// node_modules/vuestic-ui/dist/es/src/components/va-tabs/components/VaTab/index.js
var VaTab = withConfigTransport$1(_sfc_main104);

// node_modules/vuestic-ui/dist/es/src/components/va-stepper/VaStepper.vue_vue_type_script_setup_true_lang.js
import { defineComponent as defineComponent106, shallowRef as shallowRef37, computed as computed176, ref as ref75, watch as watch57, openBlock as openBlock104, createElementBlock as createElementBlock89, mergeProps as mergeProps50, createElementVNode as createElementVNode50, normalizeClass as normalizeClass51, withKeys as withKeys27, Fragment as Fragment30, renderList as renderList25, renderSlot as renderSlot86, normalizeProps as normalizeProps37, createCommentVNode as createCommentVNode53, guardReactiveProps as guardReactiveProps32, createVNode as createVNode43, unref as unref94, createBlock as createBlock54 } from "vue";

// node_modules/vuestic-ui/dist/es/src/components/va-stepper/VaStepperControls.vue_vue_type_script_setup_true_lang.js
import { defineComponent as defineComponent104, computed as computed174, openBlock as openBlock102, createElementBlock as createElementBlock87, createVNode as createVNode42, unref as unref92, withCtx as withCtx56, createTextVNode as createTextVNode29, toDisplayString as toDisplayString39, createBlock as createBlock52, createCommentVNode as createCommentVNode52 } from "vue";

// node_modules/vuestic-ui/dist/es/src/utils/un-function.js
var unFunction = (fn, ...args) => {
  if (isFunction(fn)) {
    return fn(...args);
  }
  return fn;
};

// node_modules/vuestic-ui/dist/es/src/components/va-stepper/VaStepperControls.vue_vue_type_script_setup_true_lang.js
import "D:/Desktop/forntend/Front_End_Web_Hotel_Nhom_2/my-nuxt-app/node_modules/vuestic-ui/dist/es/VaStepperControls.css";
var _hoisted_163 = { class: "va-stepper__default-controls" };
var _sfc_main105 = defineComponent104({
  ...{
    name: "VaStepperControls"
  },
  __name: "VaStepperControls",
  props: {
    modelValue: { type: [Number, String], required: true },
    steps: {
      type: Array,
      required: true
    },
    nextDisabled: { type: Boolean, required: true },
    stepControls: { type: Object, required: true },
    finishButtonHidden: { type: Boolean, default: false }
  },
  setup(__props) {
    const props = __props;
    const { t } = useTranslation();
    const isLoading = computed174(() => {
      const currentStep = props.steps[Number(props.modelValue)];
      return unFunction(currentStep.isLoading) || false;
    });
    const isLastStep = computed174(() => {
      const lastEnabledStepIndex = props.steps.length - 1;
      return Number(props.modelValue) >= lastEnabledStepIndex;
    });
    return (_ctx, _cache) => {
      return openBlock102(), createElementBlock87("div", _hoisted_163, [
        createVNode42(unref92(VaButton), {
          preset: "primary",
          disabled: Number(_ctx.$props.modelValue) <= 0,
          loading: isLoading.value,
          onClick: _cache[0] || (_cache[0] = ($event) => _ctx.$props.stepControls.prevStep())
        }, {
          default: withCtx56(() => [
            createTextVNode29(toDisplayString39(unref92(t)("back")), 1)
          ]),
          _: 1
        }, 8, ["disabled", "loading"]),
        !isLastStep.value ? (openBlock102(), createBlock52(unref92(VaButton), {
          key: 0,
          onClick: _cache[1] || (_cache[1] = ($event) => _ctx.$props.stepControls.nextStep()),
          disabled: _ctx.$props.nextDisabled,
          loading: isLoading.value
        }, {
          default: withCtx56(() => [
            createTextVNode29(toDisplayString39(unref92(t)("next")), 1)
          ]),
          _: 1
        }, 8, ["disabled", "loading"])) : !_ctx.$props.finishButtonHidden ? (openBlock102(), createBlock52(unref92(VaButton), {
          key: 1,
          onClick: _cache[2] || (_cache[2] = ($event) => _ctx.$props.stepControls.finish()),
          loading: isLoading.value
        }, {
          default: withCtx56(() => [
            createTextVNode29(toDisplayString39(unref92(t)("finish")), 1)
          ]),
          _: 1
        }, 8, ["loading"])) : createCommentVNode52("", true)
      ]);
    };
  }
});

// node_modules/vuestic-ui/dist/es/src/components/va-stepper/VaStepperStepButton.vue_vue_type_script_setup_true_lang.js
import { defineComponent as defineComponent105, shallowRef as shallowRef36, computed as computed175, watch as watch56, nextTick as nextTick13, openBlock as openBlock103, createElementBlock as createElementBlock88, mergeProps as mergeProps49, unref as unref93, withKeys as withKeys26, createElementVNode as createElementVNode49, createBlock as createBlock53, Fragment as Fragment29, createTextVNode as createTextVNode30, toDisplayString as toDisplayString40 } from "vue";

// node_modules/vuestic-ui/dist/es/src/components/va-stepper/step.js
var isStepHasError = (step) => {
  return unFunction(step.hasError, step) || false;
};

// node_modules/vuestic-ui/dist/es/src/components/va-stepper/VaStepperStepButton.vue_vue_type_script_setup_true_lang.js
import "D:/Desktop/forntend/Front_End_Web_Hotel_Nhom_2/my-nuxt-app/node_modules/vuestic-ui/dist/es/VaStepperStepButton.css";
var _hoisted_164 = { class: "va-stepper__step-button__icon" };
var _sfc_main106 = defineComponent105({
  ...{
    name: "VaStepperStepButton"
  },
  __name: "VaStepperStepButton",
  props: {
    modelValue: { type: Number, required: true },
    step: {
      type: Object,
      required: true
    },
    color: { type: String, required: true },
    stepIndex: { type: [Number, String], required: true },
    navigationDisabled: { type: Boolean, required: true },
    nextDisabled: { type: Boolean, required: true },
    focus: { type: Object, required: true },
    stepControls: { type: Object, required: true }
  },
  emits: ["update:modelValue"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const stepElement = shallowRef36();
    const hasError = computed175(() => isStepHasError(props.step));
    const stepIndexComputed = useNumericProp("stepIndex");
    const displayError = computed175(() => hasError.value && props.modelValue === stepIndexComputed.value);
    const isLoading = computed175(() => unFunction(props.step.isLoading) || false);
    const { getColor } = useColors();
    const stepperColor = computed175(() => getColor(hasError.value ? "danger" : props.color));
    const isNextStepDisabled = (index) => props.nextDisabled && index > props.modelValue;
    const { t } = useTranslation();
    const computedClass = useBem("va-stepper__step-button", () => ({
      active: props.modelValue >= stepIndexComputed.value,
      disabled: props.step.disabled || isNextStepDisabled(stepIndexComputed.value),
      "navigation-disabled": props.navigationDisabled,
      error: displayError.value
    }));
    watch56(() => props.focus, () => {
      if (props.focus.trigger) {
        nextTick13(() => {
          var _a2;
          return (_a2 = stepElement.value) == null ? void 0 : _a2.focus();
        });
      }
    }, { deep: true });
    const ariaAttributesComputed = computed175(() => ({
      tabindex: props.focus.stepIndex === stepIndexComputed.value && !props.navigationDisabled ? 0 : void 0,
      "aria-disabled": props.step.disabled || isNextStepDisabled(stepIndexComputed.value) ? true : void 0,
      "aria-current": props.modelValue === props.stepIndex ? t("step") : void 0
    }));
    return (_ctx, _cache) => {
      return openBlock103(), createElementBlock88("li", mergeProps49({
        ref_key: "stepElement",
        ref: stepElement,
        class: ["va-stepper__step-button", unref93(computedClass)],
        onClick: _cache[0] || (_cache[0] = ($event) => !_ctx.$props.navigationDisabled && _ctx.$props.stepControls.setStep(unref93(stepIndexComputed))),
        onKeyup: [
          _cache[1] || (_cache[1] = withKeys26(($event) => !_ctx.$props.navigationDisabled && _ctx.$props.stepControls.setStep(unref93(stepIndexComputed)), ["enter"])),
          _cache[2] || (_cache[2] = withKeys26(($event) => !_ctx.$props.navigationDisabled && _ctx.$props.stepControls.setStep(unref93(stepIndexComputed)), ["space"]))
        ]
      }, ariaAttributesComputed.value, {
        style: `--va-stepper-color: ${String(stepperColor.value)}`
      }), [
        createElementVNode49("div", _hoisted_164, [
          isLoading.value ? (openBlock103(), createBlock53(unref93(VaProgressCircle), {
            key: 0,
            color: "currentColor",
            indeterminate: "",
            size: "small"
          })) : __props.step.icon ? (openBlock103(), createBlock53(unref93(VaIcon), {
            key: 1,
            name: __props.step.icon,
            size: "1.3rem"
          }, null, 8, ["name"])) : (openBlock103(), createElementBlock88(Fragment29, { key: 2 }, [
            createTextVNode30(toDisplayString40(unref93(stepIndexComputed) + 1), 1)
          ], 64))
        ]),
        createTextVNode30(" " + toDisplayString40(__props.step.label), 1)
      ], 16);
    };
  }
});

// node_modules/vuestic-ui/dist/es/src/components/va-stepper/VaStepper.vue_vue_type_script_setup_true_lang.js
import "D:/Desktop/forntend/Front_End_Web_Hotel_Nhom_2/my-nuxt-app/node_modules/vuestic-ui/dist/es/VaStepper.css";
var _hoisted_165 = { class: "va-stepper__step-content" };
var _hoisted_232 = { class: "va-stepper__controls" };
var _sfc_main107 = defineComponent106({
  ...{
    name: "VaStepper"
  },
  __name: "VaStepper",
  props: {
    ...useStatefulProps,
    modelValue: { type: Number, default: 0 },
    steps: {
      type: Array,
      default: () => [],
      required: true
    },
    color: { type: String, default: "primary" },
    vertical: { type: Boolean, default: false },
    navigationDisabled: { type: Boolean, default: false },
    controlsHidden: { type: Boolean, default: false },
    nextDisabled: { type: Boolean, default: false },
    nextDisabledOnError: { type: Boolean, default: false },
    finishButtonHidden: { type: Boolean, default: false },
    ariaLabel: useTranslationProp("$t:progress"),
    linear: { type: Boolean, default: false },
    /** Hidden step shown when all steps complete */
    finishStep: { type: Object }
  },
  emits: ["update:modelValue", "finish", "update:steps"],
  setup(__props, { expose: __expose, emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const stepperNavigation = shallowRef37();
    const { valueComputed: modelValue } = useStateful(props, emit, "modelValue");
    const stepsComputed = computed176(() => {
      if (!props.finishStep) {
        return props.steps;
      }
      return [...props.steps, props.finishStep];
    });
    const isFinishStep = (index) => {
      if (!props.finishStep) {
        return false;
      }
      return index === stepsComputed.value.length - 1;
    };
    const focusedStep = ref75({ trigger: false, stepIndex: props.navigationDisabled ? -1 : props.modelValue });
    const { getColor } = useColors();
    const isNextStepDisabled = (index) => {
      if (props.nextDisabledOnError && isStepHasError(stepsComputed.value[index])) {
        return true;
      }
      return props.nextDisabled;
    };
    const findFirstNonDisabled = (from, direction) => {
      while (from >= 0 && from < stepsComputed.value.length) {
        from += direction;
        const step = stepsComputed.value[from];
        if (!step) {
          return;
        }
        if (!step.disabled) {
          return step;
        }
      }
    };
    const findFirstWithErrorIndex = (from, direction) => {
      while (from >= 0 && from < stepsComputed.value.length) {
        from += direction;
        const step = stepsComputed.value[from];
        if (!step) {
          return;
        }
        if (isStepHasError(step) === true) {
          return from;
        }
      }
    };
    const validateMovingToStep = async (stepIndex) => {
      var _a2;
      const newStep = stepsComputed.value[stepIndex];
      const currentStep = stepsComputed.value[modelValue.value];
      const beforeNewStep = findFirstNonDisabled(stepIndex, -1);
      if (newStep.disabled) {
        return false;
      }
      if (props.linear && stepIndex < modelValue.value) {
        return true;
      }
      const nextNonError = findFirstWithErrorIndex(modelValue.value, 1);
      if (props.linear && nextNonError !== void 0 && nextNonError < stepIndex) {
        return false;
      }
      let currentStepBeforeLeaveResult;
      try {
        currentStepBeforeLeaveResult = await ((_a2 = currentStep.beforeLeave) == null ? void 0 : _a2.call(currentStep, currentStep, newStep));
      } catch (e) {
        throw new Error(`Error in beforeLeave function: ${e}`);
      }
      if (currentStepBeforeLeaveResult === false) {
        return false;
      }
      if (currentStep.completed === void 0) {
        currentStep.completed = true;
      }
      if (props.linear && beforeNewStep && !beforeNewStep.completed) {
        return false;
      }
      if (props.linear && isStepHasError(currentStep)) {
        return false;
      }
      return true;
    };
    const setStep = async (index) => {
      if (!await validateMovingToStep(index)) {
        return;
      }
      modelValue.value = index;
    };
    const setFocus = (direction) => {
      if (props.navigationDisabled) {
        return;
      }
      if (direction === "next") {
        setFocusNextStep(1);
      } else {
        setFocusPrevStep(1);
      }
    };
    const setFocusNextStep = (idx = 1) => {
      const newValue = focusedStep.value.stepIndex + idx;
      if (isNextStepDisabled(newValue)) {
        return;
      }
      if (newValue < stepsComputed.value.length) {
        if (stepsComputed.value[newValue].disabled) {
          setFocusNextStep(idx + 1);
          return;
        }
        focusedStep.value.stepIndex = newValue;
        focusedStep.value.trigger = true;
      } else {
        for (let availableIdx = 0; availableIdx < stepsComputed.value.length; availableIdx++) {
          if (!stepsComputed.value[availableIdx].disabled) {
            focusedStep.value.stepIndex = availableIdx;
            focusedStep.value.trigger = true;
            break;
          }
        }
      }
    };
    const setFocusPrevStep = (idx = 1) => {
      const newValue = focusedStep.value.stepIndex - idx;
      if (newValue >= 0) {
        if (stepsComputed.value[newValue].disabled) {
          setFocusPrevStep(idx + 1);
          return;
        }
        focusedStep.value.stepIndex = newValue;
        focusedStep.value.trigger = true;
      } else {
        for (let availableIdx = stepsComputed.value.length - 1; availableIdx >= 0; availableIdx--) {
          if (!stepsComputed.value[availableIdx].disabled && !isNextStepDisabled(availableIdx)) {
            focusedStep.value.stepIndex = availableIdx;
            focusedStep.value.trigger = true;
            break;
          }
        }
      }
    };
    const resetFocus = () => {
      requestAnimationFrame(() => {
        var _a2;
        if (!((_a2 = stepperNavigation.value) == null ? void 0 : _a2.contains(document.activeElement))) {
          focusedStep.value.stepIndex = props.modelValue;
          focusedStep.value.trigger = false;
        }
      });
    };
    watch57(() => props.modelValue, () => {
      focusedStep.value.stepIndex = props.modelValue;
      focusedStep.value.trigger = false;
    });
    const nextStep = (stepsToSkip = 0) => {
      const targetIndex = modelValue.value + 1 + stepsToSkip;
      if (!stepsComputed.value[targetIndex]) {
        return;
      }
      if (stepsComputed.value[targetIndex].disabled) {
        nextStep(stepsToSkip + 1);
      }
      setStep(targetIndex);
    };
    const prevStep = (stepsToSkip = 0) => {
      const targetIndex = modelValue.value - 1 - stepsToSkip;
      if (!stepsComputed.value[targetIndex]) {
        return;
      }
      if (stepsComputed.value[targetIndex].disabled) {
        prevStep(stepsToSkip + 1);
      }
      setStep(targetIndex);
    };
    const finish = async () => {
      if (await validateMovingToStep(props.steps.length - 1)) {
        emit("finish");
      }
    };
    const stepControls = { setStep, nextStep, prevStep, finish };
    const getIterableSlotData = (step, index) => ({
      ...stepControls,
      focus: focusedStep,
      isActive: props.modelValue === index,
      isCompleted: props.modelValue > index,
      isLastStep: stepsComputed.value.length - 1 === index,
      isNextStepDisabled: isNextStepDisabled(index),
      isPrevStepDisabled: index === 0,
      index,
      step,
      hasError: isStepHasError(step)
    });
    const { tp } = useTranslation();
    const onValueChange = () => {
      focusedStep.value.stepIndex = props.modelValue;
      focusedStep.value.trigger = true;
    };
    const ariaAttributesComputed = computed176(() => ({
      role: "group",
      "aria-label": tp(props.ariaLabel),
      "aria-orientation": props.vertical ? "vertical" : "horizontal"
    }));
    function getStepperButtonColor(index) {
      return isStepHasError(stepsComputed.value[index]) ? "danger" : getColor(props.color);
    }
    const completeStep = (shouldCompleteStep) => {
      const steps = { ...stepsComputed.value };
      if (shouldCompleteStep === true) {
        steps[props.modelValue].hasError = false;
      }
      steps[props.modelValue].completed = shouldCompleteStep ?? true;
      emit("update:steps", steps);
    };
    const setError = (shouldSetError) => {
      const steps = { ...stepsComputed.value };
      steps[props.modelValue].hasError = shouldSetError ?? true;
      steps[props.modelValue].completed = !shouldSetError;
      emit("update:steps", steps);
    };
    __expose({
      modelValue,
      focusedStep,
      getIterableSlotData,
      stepControls,
      nextStep,
      prevStep,
      setStep,
      setFocus,
      completeStep,
      setError
    });
    return (_ctx, _cache) => {
      return openBlock104(), createElementBlock89("div", mergeProps50({
        class: ["va-stepper", { "va-stepper--vertical": _ctx.$props.vertical }]
      }, ariaAttributesComputed.value), [
        createElementVNode50("ol", {
          class: normalizeClass51(["va-stepper__navigation", { "va-stepper__navigation--vertical": _ctx.$props.vertical }]),
          ref_key: "stepperNavigation",
          ref: stepperNavigation,
          onClick: onValueChange,
          onKeyup: [
            withKeys27(onValueChange, ["enter"]),
            withKeys27(onValueChange, ["space"]),
            _cache[0] || (_cache[0] = withKeys27(($event) => setFocus("prev"), ["left"])),
            _cache[1] || (_cache[1] = withKeys27(($event) => setFocus("next"), ["right"]))
          ],
          onFocusout: resetFocus
        }, [
          (openBlock104(true), createElementBlock89(Fragment30, null, renderList25(stepsComputed.value, (step, i) => {
            return openBlock104(), createElementBlock89(Fragment30, {
              key: i + step.label
            }, [
              !isFinishStep(i) ? (openBlock104(), createElementBlock89(Fragment30, { key: 0 }, [
                i > 0 ? renderSlot86(_ctx.$slots, "divider", normalizeProps37(mergeProps50({ key: 0 }, getIterableSlotData(step, i))), () => [
                  createElementVNode50("span", {
                    class: normalizeClass51(["va-stepper__divider", { "va-stepper__divider--vertical": _ctx.$props.vertical }]),
                    "aria-hidden": "true"
                  }, null, 2)
                ]) : createCommentVNode53("", true),
                renderSlot86(_ctx.$slots, `step-button-${i}`, normalizeProps37(guardReactiveProps32(getIterableSlotData(step, i))), () => [
                  createVNode43(_sfc_main106, {
                    stepIndex: i,
                    color: getStepperButtonColor(i),
                    modelValue: unref94(modelValue),
                    nextDisabled: __props.nextDisabled,
                    step,
                    stepControls,
                    navigationDisabled: __props.navigationDisabled,
                    focus: focusedStep.value
                  }, null, 8, ["stepIndex", "color", "modelValue", "nextDisabled", "step", "navigationDisabled", "focus"])
                ])
              ], 64)) : createCommentVNode53("", true)
            ], 64);
          }), 128))
        ], 34),
        createElementVNode50("div", {
          class: normalizeClass51(["va-stepper__step-content-wrapper", { "va-stepper__step-content-wrapper--vertical": _ctx.$props.vertical }])
        }, [
          createElementVNode50("div", _hoisted_165, [
            renderSlot86(_ctx.$slots, `step-content-${isFinishStep(unref94(modelValue)) ? "finish" : unref94(modelValue)}`, normalizeProps37(guardReactiveProps32(getIterableSlotData(stepsComputed.value[unref94(modelValue)], unref94(modelValue)))))
          ]),
          createElementVNode50("div", _hoisted_232, [
            renderSlot86(_ctx.$slots, "controls", normalizeProps37(guardReactiveProps32(getIterableSlotData(stepsComputed.value[unref94(modelValue)], unref94(modelValue)))), () => [
              !__props.controlsHidden ? (openBlock104(), createBlock54(_sfc_main105, {
                key: 0,
                modelValue: unref94(modelValue),
                nextDisabled: isNextStepDisabled(unref94(modelValue)),
                steps: stepsComputed.value,
                stepControls,
                finishButtonHidden: __props.finishButtonHidden
              }, null, 8, ["modelValue", "nextDisabled", "steps", "finishButtonHidden"])) : createCommentVNode53("", true)
            ])
          ])
        ], 2)
      ], 16);
    };
  }
});

// node_modules/vuestic-ui/dist/es/src/components/va-stepper/index.js
var VaStepper = withConfigTransport$1(_sfc_main107);
var defineVaStepperSteps = (steps) => steps;

// node_modules/vuestic-ui/dist/es/src/components/va-time-input/VaTimeInput.vue_vue_type_script_setup_true_lang.js
import { defineComponent as defineComponent110, shallowRef as shallowRef39, computed as computed181, nextTick as nextTick15, watch as watch60, useSlots as useSlots14, useAttrs as useAttrs7, openBlock as openBlock108, createBlock as createBlock57, unref as unref99, mergeProps as mergeProps51, withCtx as withCtx58, createVNode as createVNode44, createSlots as createSlots8, withModifiers as withModifiers24, withKeys as withKeys30, createCommentVNode as createCommentVNode54, renderList as renderList28, renderSlot as renderSlot89, normalizeProps as normalizeProps39, guardReactiveProps as guardReactiveProps34, isRef as isRef10 } from "vue";

// node_modules/vuestic-ui/dist/es/src/components/va-time-input/hooks/time-text-parser.js
import { ref as ref76 } from "vue";
var parse = (text) => {
  const m = text.match(/[0-9]{1,2}/g);
  if (!m) {
    return [];
  }
  return m.map((s) => Number(s));
};
var parsePeriod = (text) => {
  const m = text.match(/pm|am/i);
  if (!m) {
    return null;
  }
  return Number(m[0].toLowerCase() === "pm");
};
var defaultParseDateFunction2 = (text) => {
  const d = /* @__PURE__ */ new Date();
  const [h15, m, s] = parse(text);
  const period = parsePeriod(text);
  if (!h15) {
    return null;
  }
  const is12format = period !== null && h15 <= 12;
  const isPM = is12format && !!period;
  const fh = is12format ? h15 === 12 ? 0 : h15 : h15;
  d.setHours(Math.min(fh || 0, is12format ? 12 : 24) + (isPM ? 12 : 0));
  d.setMinutes(Math.min(m || 0, 60));
  d.setSeconds(Math.min(s || 0, 60));
  return d;
};
var useTimeParser = (props) => {
  const getParseDateFn = () => props.parse || defaultParseDateFunction2;
  const isValid = ref76(true);
  const parseDate = (text) => {
    const parse3 = getParseDateFn();
    const result = parse3(text);
    if (!result) {
      isValid.value = false;
    }
    return result;
  };
  const parse2 = (text) => {
    isValid.value = true;
    return parseDate(text);
  };
  return {
    parse: parse2,
    isValid
  };
};

// node_modules/vuestic-ui/dist/es/src/components/va-time-input/hooks/time-text-formatter.js
var useTimeFormatter = (props) => {
  const formatDate = (date) => {
    if (!date) {
      return "";
    }
    if (props.ampm) {
      return date.toLocaleTimeString("en-US");
    }
    return date.toLocaleTimeString("en-GB");
  };
  const sliceTime = (time, start, end) => time.split(":").slice(start, end).join(":");
  const formatWithView = (date) => {
    if (props.view === "seconds") {
      return formatDate(date);
    }
    const [time, period] = formatDate(date).split(" ");
    if (props.view === "minutes") {
      if (!period) {
        return sliceTime(time, 0, 2);
      }
      return [sliceTime(time, 0, 2), period].join(" ");
    }
    if (props.view === "hours") {
      if (!period) {
        return sliceTime(time, 0, 1);
      }
      return [sliceTime(time, 0, 1), period].join(" ");
    }
    return "";
  };
  return {
    format: (date) => props.format ? props.format(date) : formatWithView(date)
  };
};

// node_modules/vuestic-ui/dist/es/src/components/va-time-picker/VaTimePicker.vue_vue_type_script_setup_true_lang.js
import { defineComponent as defineComponent109, ref as ref78, computed as computed180, openBlock as openBlock107, createElementBlock as createElementBlock92, normalizeClass as normalizeClass53, normalizeStyle as normalizeStyle55, unref as unref97, Fragment as Fragment32, renderList as renderList27, createBlock as createBlock56, withKeys as withKeys29, withModifiers as withModifiers23 } from "vue";

// node_modules/vuestic-ui/dist/es/src/components/va-time-picker/hooks/useTimePicker.js
import { toRefs as toRefs10, ref as ref77, watch as watch58, computed as computed177 } from "vue";
var safeModelValue = (m) => m.value ? m.value : new Date((/* @__PURE__ */ new Date()).setHours(0, 0, 0, 0));
var createNumbersArray = (length) => Array.from(Array(length).keys());
var from24to12 = (h15) => (h15 === 0 ? 12 : h15) - Number(h15 > 12) * 12;
var from12to24 = (h15, isAM = false) => (h15 === 12 ? 0 : h15) + Number(isAM) * 12;
var createHoursColumn = (props, modelValue, isPM) => {
  const computedSize = computed177(() => props.ampm ? 12 : 24);
  const items2 = computed177(() => {
    let array = createNumbersArray(computedSize.value);
    if (props.hoursFilter) {
      array = array.filter((i) => props.hoursFilter(props.ampm ? i + 12 * Number(isPM.value) : i));
    }
    return array.map((n) => {
      return props.ampm ? from24to12(n) : n;
    });
  });
  const activeItem = computed177({
    get: () => {
      if (!modelValue.value) {
        return -1;
      }
      if (props.ampm) {
        const h22 = from24to12(modelValue.value.getHours() - 12 * Number(isPM.value));
        return items2.value.findIndex((i) => i === h22);
      }
      const h15 = modelValue.value.getHours();
      return items2.value.findIndex((i) => i === h15);
    },
    set: (newIndex) => {
      if (props.readonly) {
        return;
      }
      const hours = props.ampm ? from12to24(items2.value[newIndex], isPM.value) : items2.value[newIndex];
      modelValue.value = new Date(safeModelValue(modelValue).setHours(hours));
    }
  });
  return computed177(() => ({
    items: items2.value,
    activeItem
  }));
};
var createMinutesColumn = (props, modelValue) => {
  const items2 = computed177(() => {
    const array = createNumbersArray(60);
    if (!props.minutesFilter) {
      return array;
    }
    return array.filter(props.minutesFilter);
  });
  const activeItem = computed177({
    get: () => {
      if (!modelValue.value) {
        return -1;
      }
      const m = modelValue.value.getMinutes();
      return items2.value.findIndex((i) => i === m);
    },
    set: (newIndex) => {
      if (props.readonly) {
        return;
      }
      const v = items2.value[newIndex];
      modelValue.value = new Date(safeModelValue(modelValue).setMinutes(v));
    }
  });
  return computed177(() => ({
    items: items2.value,
    activeItem
  }));
};
var createSecondsColumn = (props, modelValue) => {
  const items2 = computed177(() => {
    const array = createNumbersArray(60);
    if (!props.secondsFilter) {
      return array;
    }
    return array.filter(props.secondsFilter);
  });
  const activeItem = computed177({
    get: () => {
      if (!modelValue.value) {
        return -1;
      }
      const s = modelValue.value.getSeconds();
      return items2.value.findIndex((i) => i === s);
    },
    set: (newIndex) => {
      if (props.readonly) {
        return;
      }
      const v = items2.value[newIndex];
      modelValue.value = new Date(safeModelValue(modelValue).setSeconds(v));
    }
  });
  return computed177(() => ({
    items: items2.value,
    activeItem
  }));
};
var createPeriodColumn = (props, modelValue, isPM) => {
  return computed177(() => ({
    items: ["AM", "PM"],
    activeItem: computed177({
      get: () => {
        if (!modelValue.value) {
          return -1;
        }
        return Number(isPM.value);
      },
      set: (val) => {
        isPM.value = Boolean(val);
        const h15 = safeModelValue(modelValue).getHours();
        let h24 = isPM.value ? h15 + 12 : h15;
        if (isPM.value && h15 <= 12) {
          h24 = h15 + 12;
        }
        if (!isPM.value && h15 >= 12) {
          h24 = h15 - 12;
        }
        const isValidFilteredHour = !props.hoursFilter || props.hoursFilter(h24);
        if (props.periodUpdatesModelValue && isValidFilteredHour) {
          modelValue.value = new Date(safeModelValue(modelValue).setHours(h24));
        }
      }
    })
  }));
};
var useTimePicker = (props, modelValue) => {
  const { view } = toRefs10(props);
  const isPM = ref77(false);
  watch58(modelValue, () => {
    isPM.value = safeModelValue(modelValue).getHours() >= 12;
  }, { immediate: true });
  const hoursColumn = createHoursColumn(props, modelValue, isPM);
  const minutesColumn = createMinutesColumn(props, modelValue);
  const secondsColumn = createSecondsColumn(props, modelValue);
  const periodColumn = createPeriodColumn(props, modelValue, isPM);
  const columns = computed177(() => {
    const array = [];
    if (view.value === "hours") {
      array.push(hoursColumn.value);
    } else if (view.value === "minutes") {
      array.push(hoursColumn.value, minutesColumn.value);
    } else if (view.value === "seconds") {
      array.push(hoursColumn.value, minutesColumn.value, secondsColumn.value);
    }
    if (props.ampm && !props.hidePeriodSwitch) {
      array.push(periodColumn.value);
    }
    return array;
  });
  return {
    columns,
    isPM
  };
};

// node_modules/vuestic-ui/dist/es/src/components/va-time-picker/components/VaTimePickerColumn/VaTimePickerColumn.vue_vue_type_script_setup_true_lang.js
import { defineComponent as defineComponent108, shallowRef as shallowRef38, watch as watch59, onMounted as onMounted35, nextTick as nextTick14, openBlock as openBlock106, createElementBlock as createElementBlock91, withKeys as withKeys28, withModifiers as withModifiers22, Fragment as Fragment31, renderList as renderList26, createBlock as createBlock55, unref as unref96, withCtx as withCtx57, createElementVNode as createElementVNode51, normalizeClass as normalizeClass52, renderSlot as renderSlot88, normalizeProps as normalizeProps38, guardReactiveProps as guardReactiveProps33, createTextVNode as createTextVNode31, toDisplayString as toDisplayString41 } from "vue";

// node_modules/vuestic-ui/dist/es/src/components/va-time-picker/components/VaTimePickerColumnCell.vue_vue_type_script_setup_true_lang.js
import { defineComponent as defineComponent107, computed as computed178, openBlock as openBlock105, createElementBlock as createElementBlock90, unref as unref95, normalizeStyle as normalizeStyle54, renderSlot as renderSlot87 } from "vue";
var _sfc_main108 = defineComponent107({
  ...{
    name: "VaTimePickerColumnCell"
  },
  __name: "VaTimePickerColumnCell",
  setup(__props) {
    const { isHovered, onMouseEnter, onMouseLeave } = useHover();
    const { getTextColor, getColor } = useColors();
    const styleComputed = computed178(() => isHovered.value ? {
      color: getColor(getTextColor(getColor("background-secondary"))),
      background: getColor("background-secondary")
    } : void 0);
    return (_ctx, _cache) => {
      return openBlock105(), createElementBlock90("div", {
        onMouseenter: _cache[0] || (_cache[0] = //@ts-ignore
        (...args) => unref95(onMouseEnter) && unref95(onMouseEnter)(...args)),
        onMouseleave: _cache[1] || (_cache[1] = //@ts-ignore
        (...args) => unref95(onMouseLeave) && unref95(onMouseLeave)(...args)),
        style: normalizeStyle54(styleComputed.value)
      }, [
        renderSlot87(_ctx.$slots, "default")
      ], 36);
    };
  }
});

// node_modules/vuestic-ui/dist/es/src/components/va-time-picker/components/VaTimePickerColumn/VaTimePickerColumn.vue_vue_type_script_setup_true_lang.js
import "D:/Desktop/forntend/Front_End_Web_Hotel_Nhom_2/my-nuxt-app/node_modules/vuestic-ui/dist/es/VaTimePickerColumn.css";
var _hoisted_166 = ["onClick"];
var _sfc_main109 = defineComponent108({
  ...{
    name: "VaTimePickerColumn"
  },
  __name: "VaTimePickerColumn",
  props: {
    items: { type: Array, default: () => [] },
    activeItemIndex: { type: Number, default: 0 },
    cellHeight: { type: [Number, String], default: 30 }
  },
  emits: ["item-selected", "update:activeItemIndex", ...useFocusEmits],
  setup(__props, { expose: __expose, emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const rootElement = shallowRef38();
    const { focus, blur } = useFocus(rootElement, emit);
    const [syncActiveItemIndex] = useSyncProp("activeItemIndex", props, emit);
    const cellHeightComputed = useNumericProp("cellHeight");
    watch59(syncActiveItemIndex, (newVal) => {
      scrollTo(newVal);
    });
    onMounted35(() => scrollTo(syncActiveItemIndex.value, false));
    const scrollTo = (index, animated = true) => {
      nextTick14(() => {
        var _a2, _b;
        (_b = (_a2 = rootElement.value) == null ? void 0 : _a2.scrollTo) == null ? void 0 : _b.call(_a2, {
          behavior: animated ? "smooth" : "auto",
          top: index * cellHeightComputed.value
        });
      });
    };
    const makeActiveNext = (times) => {
      syncActiveItemIndex.value = (syncActiveItemIndex.value + (times || 1)) % props.items.length;
      nextTick14(() => scrollTo(syncActiveItemIndex.value));
    };
    const makeActivePrev = (times) => {
      syncActiveItemIndex.value = (syncActiveItemIndex.value - (times || 1) + props.items.length) % props.items.length;
      nextTick14(() => scrollTo(syncActiveItemIndex.value));
    };
    const onCellClick = (index) => {
      syncActiveItemIndex.value = index;
    };
    const formatCell = (n) => {
      if (!Number.isInteger(n)) {
        return n;
      }
      return Number(n) < 10 ? `0${n}` : `${n}`;
    };
    const getIndex = () => {
      const scrollTop = rootElement.value.scrollTop;
      const calculatedIndex = Math.max(
        (scrollTop - scrollTop % cellHeightComputed.value) / cellHeightComputed.value,
        scrollTop / cellHeightComputed.value
      );
      if (calculatedIndex >= props.items.length) {
        return props.items.length - 1;
      }
      if (calculatedIndex < 0) {
        return 0;
      }
      if (syncActiveItemIndex.value * cellHeightComputed.value < scrollTop) {
        return Math.ceil(calculatedIndex);
      } else if (syncActiveItemIndex.value * cellHeightComputed.value > scrollTop) {
        return Math.floor(calculatedIndex);
      } else {
        return Math.round(calculatedIndex);
      }
    };
    const onScroll = debounce(() => {
      if (rootElement.value && syncActiveItemIndex.value !== -1) {
        syncActiveItemIndex.value = getIndex();
      }
    }, 200);
    __expose({
      focus,
      blur
    });
    return (_ctx, _cache) => {
      return openBlock106(), createElementBlock91("div", {
        ref_key: "rootElement",
        ref: rootElement,
        tabindex: "0",
        class: "va-time-picker-column",
        onKeydown: [
          _cache[0] || (_cache[0] = withKeys28(withModifiers22(($event) => makeActiveNext(), ["stop", "prevent"]), ["down"])),
          _cache[1] || (_cache[1] = withKeys28(withModifiers22(($event) => makeActiveNext(5), ["stop", "prevent"]), ["space"])),
          _cache[2] || (_cache[2] = withKeys28(withModifiers22(($event) => makeActivePrev(), ["stop", "prevent"]), ["up"]))
        ]
      }, [
        (openBlock106(true), createElementBlock91(Fragment31, null, renderList26(__props.items, (item, index) => {
          return openBlock106(), createBlock55(_sfc_main108, {
            key: item,
            onScrollPassive: unref96(onScroll),
            onTouchmovePassive: unref96(onScroll),
            onMousewheelPassive: unref96(onScroll)
          }, {
            default: withCtx57(() => [
              createElementVNode51("div", {
                class: normalizeClass52(["va-time-picker-cell", { "va-time-picker-cell--active": index === _ctx.$props.activeItemIndex }]),
                onClick: ($event) => onCellClick(index)
              }, [
                renderSlot88(_ctx.$slots, "cell", normalizeProps38(guardReactiveProps33({ item, index, activeItemIndex: __props.activeItemIndex, items: __props.items, formattedItem: formatCell(item) })), () => [
                  createTextVNode31(toDisplayString41(formatCell(item)), 1)
                ])
              ], 10, _hoisted_166)
            ]),
            _: 2
          }, 1032, ["onScrollPassive", "onTouchmovePassive", "onMousewheelPassive"]);
        }), 128))
      ], 544);
    };
  }
});

// node_modules/vuestic-ui/dist/es/src/components/va-time-picker/components/VaTimePickerColumn/index.js
var VaTimePickerColumn = withConfigTransport$1(_sfc_main109);

// node_modules/vuestic-ui/dist/es/src/composables/useCSSVariables.js
import { computed as computed179 } from "vue";
var useCSSVariables = (prefix2, cb) => {
  return computed179(() => Object.entries(cb()).reduce((acc, [key, value]) => {
    acc[`--${prefix2}-${camelCaseToKebabCase(key)}`] = value;
    return acc;
  }, {}));
};

// node_modules/vuestic-ui/dist/es/src/components/va-time-picker/VaTimePicker.vue_vue_type_script_setup_true_lang.js
import "D:/Desktop/forntend/Front_End_Web_Hotel_Nhom_2/my-nuxt-app/node_modules/vuestic-ui/dist/es/VaTimePicker.css";
var _sfc_main110 = defineComponent109({
  ...{
    name: "VaTimePicker"
  },
  __name: "VaTimePicker",
  props: {
    ...useStatefulProps,
    ...useFormFieldProps,
    ...useComponentPresetProp,
    modelValue: { type: Date, required: false },
    ampm: { type: Boolean, default: false },
    hidePeriodSwitch: { type: Boolean, default: false },
    periodUpdatesModelValue: { type: Boolean, default: true },
    // Update model value when switching period automatically
    view: { type: String, default: "minutes" },
    hoursFilter: { type: Function },
    minutesFilter: { type: Function },
    secondsFilter: { type: Function },
    framed: { type: Boolean, default: false },
    cellHeight: { type: [Number, String], default: 30 },
    visibleCellsCount: { type: [Number, String], default: 7 }
  },
  emits: [...useStatefulEmits],
  setup(__props, { expose: __expose, emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const { valueComputed } = useStateful(props, emit);
    const { columns, isPM } = useTimePicker(props, valueComputed);
    const cellHeightComputed = useNumericProp("cellHeight");
    const visibleCellsCountComputed = useNumericProp("visibleCellsCount");
    const { setItemRef, itemRefs: pickers } = useArrayRefs();
    const activeColumnIndex = ref78();
    const focus = (idx = 0) => {
      var _a2;
      (_a2 = pickers.value[idx]) == null ? void 0 : _a2.focus();
    };
    const blur = (idx) => {
      var _a2;
      idx ? (_a2 = pickers.value[idx]) == null ? void 0 : _a2.blur() : pickers.value.forEach((el) => el == null ? void 0 : el.blur());
    };
    const { computedClasses: computedFormClasses } = useFormField("va-time-picker", props);
    const focusNext = () => {
      const nextIndex = ((activeColumnIndex == null ? void 0 : activeColumnIndex.value) || 0) + 1;
      activeColumnIndex.value = nextIndex % columns.value.length;
      focus(activeColumnIndex.value);
    };
    const focusPrev = () => {
      const nextIndex = ((activeColumnIndex == null ? void 0 : activeColumnIndex.value) || 0) - 1 + columns.value.length;
      activeColumnIndex.value = nextIndex % columns.value.length;
      focus(activeColumnIndex.value);
    };
    const computedClasses = computed180(() => ({
      ...computedFormClasses,
      "va-time-picker--framed": props.framed
    }));
    const computedStyles = useCSSVariables("va-time-picker", () => {
      const gapHeight = (visibleCellsCountComputed.value - 1) / 2 * cellHeightComputed.value;
      return {
        height: `${cellHeightComputed.value * visibleCellsCountComputed.value}px`,
        "cell-height": `${cellHeightComputed.value}px`,
        "column-gap-height": `${gapHeight}px`
      };
    });
    __expose({
      focus,
      blur,
      focusNext,
      focusPrev
    });
    return (_ctx, _cache) => {
      return openBlock107(), createElementBlock92("div", {
        class: normalizeClass53(["va-time-picker", computedClasses.value]),
        style: normalizeStyle55(unref97(computedStyles))
      }, [
        (openBlock107(true), createElementBlock92(Fragment32, null, renderList27(unref97(columns), (column, idx) => {
          return openBlock107(), createBlock56(unref97(VaTimePickerColumn), {
            key: idx,
            ref_for: true,
            ref: unref97(setItemRef),
            items: column.items,
            tabindex: _ctx.disabled ? -1 : 0,
            "cell-height": unref97(cellHeightComputed),
            activeItemIndex: column.activeItem.value,
            "onUpdate:activeItemIndex": ($event) => column.activeItem.value = $event,
            onKeydown: [
              _cache[0] || (_cache[0] = withKeys29(withModifiers23(($event) => focusNext(), ["stop", "prevent"]), ["right"])),
              _cache[1] || (_cache[1] = withKeys29(withModifiers23(($event) => focusNext(), ["exact", "stop", "prevent"]), ["tab"])),
              _cache[2] || (_cache[2] = withKeys29(withModifiers23(($event) => focusPrev(), ["stop", "prevent"]), ["left"])),
              _cache[3] || (_cache[3] = withKeys29(withModifiers23(($event) => focusPrev(), ["shift", "stop", "prevent"]), ["tab"]))
            ],
            onFocus: ($event) => activeColumnIndex.value = idx
          }, null, 8, ["items", "tabindex", "cell-height", "activeItemIndex", "onUpdate:activeItemIndex", "onFocus"]);
        }), 128))
      ], 6);
    };
  }
});

// node_modules/vuestic-ui/dist/es/src/composables/useLongPresKey.js
import { unref as unref98 } from "vue";
function useLongPressKey(el, options) {
  let timeoutId = -1;
  let intervalId = -1;
  const handleMouseDown = (e) => {
    var _a2;
    (_a2 = options.onStart) == null ? void 0 : _a2.call(options, e);
    clearTimeout(timeoutId);
    timeoutId = setTimeout(() => {
      intervalId = setInterval(() => {
        var _a22;
        return (_a22 = options.onUpdate) == null ? void 0 : _a22.call(options, e);
      }, options.interval || 100);
    }, unref98(options.delay) || 500);
  };
  const handleMouseUp = (e) => {
    var _a2;
    clearTimeout(timeoutId);
    clearInterval(intervalId);
    (_a2 = options.onEnd) == null ? void 0 : _a2.call(options, e);
  };
  const htmlElement = useHTMLElement(el);
  useEvent(["keydown"], handleMouseDown, htmlElement);
  useEvent([
    "keyup",
    "blur"
  ], handleMouseUp, true);
}

// node_modules/vuestic-ui/dist/es/src/components/va-time-input/VaTimeInput.vue_vue_type_script_setup_true_lang.js
var VaInputWrapperProps4 = extractComponentProps(VaInputWrapper, ["focused", "maxLength", "counterValue"]);
var _sfc_main111 = defineComponent110({
  ...{
    name: "VaTimeInput",
    inheritAttrs: false
  },
  __name: "VaTimeInput",
  props: {
    ...VaInputWrapperProps4,
    ...useDropdownableProps,
    ...useComponentPresetProp,
    ...useClearableProps,
    ...extractComponentProps(_sfc_main110),
    ...useValidationProps,
    ...useStatefulProps,
    closeOnContentClick: { type: Boolean, default: false },
    offset: { ...useDropdownableProps.offset, default: () => [2, 0] },
    placement: { ...useDropdownableProps.placement, default: "bottom-end" },
    modelValue: { type: Date, default: void 0 },
    clearValue: { type: Date, default: null },
    format: { type: Function },
    parse: { type: Function },
    manualInput: { type: Boolean, default: false },
    leftIcon: { type: Boolean, default: false },
    icon: { type: String, default: "schedule" },
    ariaLabel: useTranslationProp("$t:selectedTime"),
    ariaResetLabel: useTranslationProp("$t:resetTime"),
    ariaToggleDropdownLabel: useTranslationProp("$t:toggleDropdown")
  },
  emits: [
    ...useFocusEmits,
    ...useValidationEmits,
    ...useClearableEmits,
    ...useStatefulEmits,
    ...useDropdownableEmits,
    "update:modelValue"
  ],
  setup(__props, { expose: __expose, emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const input = shallowRef39();
    const timePicker = shallowRef39();
    const { isOpenSync, dropdownProps } = useDropdownable(props, emit, {
      defaultCloseOnValueUpdate: computed181(() => Array.isArray(props.view) && props.view.length === 1)
    });
    const { valueComputed } = useStateful(props, emit);
    const { parse: parse2, isValid } = useTimeParser(props);
    const { format } = useTimeFormatter(props);
    const valueText = computed181(() => format(valueComputed.value || props.clearValue));
    const doShowDropdown = computed181({
      get() {
        if (props.disabled || props.readonly) {
          return false;
        }
        return isOpenSync.value;
      },
      set(v) {
        isOpenSync.value = v;
        if (v) {
          nextTick15(() => {
            var _a2;
            return (_a2 = timePicker.value) == null ? void 0 : _a2.focus();
          });
        } else {
          nextTick15(() => {
            var _a2;
            return (_a2 = input.value) == null ? void 0 : _a2.focus();
          });
        }
      }
    });
    const { isFocused, focus, blur, onFocus: focusListener, onBlur: blurListener } = useFocus(input);
    const onInputTextChanged = (e) => {
      var _a2;
      if (props.disabled) {
        return;
      }
      const val = (_a2 = e.target) == null ? void 0 : _a2.value;
      if (!val) {
        return reset();
      }
      const v = parse2(val);
      if (isValid.value && v) {
        valueComputed.value = v;
      } else {
        valueComputed.value = void 0;
        isValid.value = true;
      }
    };
    const reset = () => withoutValidation(() => {
      emit("update:modelValue", props.clearValue);
      emit("clear");
      resetValidation();
      hideDropdown();
    });
    const {
      computedError,
      computedErrorMessages,
      listeners,
      validationAriaAttributes,
      withoutValidation,
      resetValidation,
      isDirty,
      isTouched
    } = useValidation(props, emit, { reset, focus, value: valueComputed });
    watch60(doShowDropdown, (v) => {
      if (!v) {
        isTouched.value = true;
      }
    });
    const {
      canBeCleared,
      clearIconProps,
      onFocus,
      onBlur
    } = useClearable(props, valueText);
    const canBeClearedComputed = computed181(() => canBeCleared.value && valueText.value !== format(props.clearValue));
    const filteredWrapperProps = filterComponentProps(VaInputWrapperProps4);
    const computedInputWrapperProps = computed181(() => ({
      ...filteredWrapperProps.value,
      focused: isFocused.value,
      error: computedError.value,
      errorMessages: computedErrorMessages.value,
      readonly: props.readonly || !props.manualInput,
      modelValue: valueText.value
    }));
    const viewToNumber = {
      seconds: 1e3,
      minutes: 1e3 * 60,
      hours: 1e3 * 60 * 60
    };
    const onKeyPress = (e) => {
      if (!("key" in e)) {
        return;
      }
      if (e.key === "ArrowDown") {
        valueComputed.value = new Date(Number(valueComputed.value) - viewToNumber[props.view]);
        e.preventDefault();
      }
      if (e.key === "ArrowUp") {
        valueComputed.value = new Date(Number(valueComputed.value) + viewToNumber[props.view]);
        e.preventDefault();
      }
    };
    useLongPressKey(input, {
      onStart: onKeyPress,
      onUpdate: onKeyPress
    });
    const computedInputListeners = {
      onFocus: () => {
        if (props.disabled) {
          return;
        }
        focusListener();
        if (props.readonly) {
          return;
        }
        onFocus();
      },
      onBlur: () => {
        if (props.disabled) {
          return;
        }
        blurListener();
        if (props.readonly) {
          return;
        }
        onBlur();
        listeners.onBlur();
      }
    };
    const slots = useSlots14();
    const filteredSlots = computed181(() => {
      const slotsWithIcons = [
        props.leftIcon && "prependInner",
        (!props.leftIcon || props.clearable) && "icon"
      ];
      return Object.keys(slots).filter((slot) => !slotsWithIcons.includes(slot));
    });
    const hideDropdown = () => {
      doShowDropdown.value = false;
    };
    const showDropdown = (event, cancel, prevent) => {
      doShowDropdown.value = true;
    };
    const checkProhibitedDropdownOpening = (e) => {
      if (isOpenSync.value) {
        return false;
      }
      if (props.disabled || props.readonly) {
        return true;
      }
      if (e === void 0) {
        return false;
      }
      return props.manualInput && (e == null ? void 0 : e.code) !== "Space";
    };
    const toggleDropdown = (event) => {
      if (checkProhibitedDropdownOpening(event instanceof KeyboardEvent ? event : void 0)) {
        return;
      }
      doShowDropdown.value = !doShowDropdown.value;
    };
    const cursorStyleComputed = computed181(() => {
      if (props.disabled) {
        return {};
      }
      if (props.manualInput) {
        return { cursor: "text" };
      }
      return { cursor: "pointer" };
    });
    const iconTabindexComputed = computed181(() => {
      if (!props.manualInput) {
        return -1;
      }
      return props.disabled || props.readonly ? -1 : 0;
    });
    const iconProps = computed181(() => ({
      role: "button",
      "aria-hidden": false,
      name: props.icon,
      color: "secondary",
      tabindex: iconTabindexComputed.value
    }));
    const { tp } = useTranslation();
    useAttrs7();
    const dropdownPropsComputed = computed181(() => ({
      ...dropdownProps.value,
      innerAnchorSelector: ".va-input-wrapper__field",
      trigger: ["click", "right-click", "space", "enter"]
    }));
    const timePickerProps = filterComponentProps(extractComponentProps(_sfc_main110));
    __expose({
      isFocused,
      isValid,
      value: valueComputed,
      isDirty,
      isTouched,
      focus,
      blur,
      reset,
      withoutValidation,
      resetValidation,
      toggleDropdown,
      showDropdown,
      hideDropdown
    });
    return (_ctx, _cache) => {
      return openBlock108(), createBlock57(unref99(VaDropdown), mergeProps51({
        modelValue: doShowDropdown.value,
        "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => doShowDropdown.value = $event),
        class: ["va-time-input", _ctx.$attrs.class],
        style: _ctx.$attrs.style
      }, dropdownPropsComputed.value), {
        anchor: withCtx58(() => [
          createVNode44(unref99(VaInputWrapper), mergeProps51({
            class: "va-time-input__anchor",
            ref_key: "input",
            ref: input,
            style: cursorStyleComputed.value
          }, { ...computedInputWrapperProps.value, ...unref99(validationAriaAttributes), ...computedInputListeners }, { onChange: onInputTextChanged }), createSlots8({
            icon: withCtx58(() => [
              canBeClearedComputed.value ? (openBlock108(), createBlock57(unref99(VaIcon), mergeProps51({
                key: 0,
                class: "va-time-input__clear-button"
              }, { ...iconProps.value, ...unref99(clearIconProps) }, {
                "aria-label": unref99(tp)(_ctx.$props.ariaResetLabel),
                onClick: withModifiers24(reset, ["stop"]),
                onKeydown: [
                  withKeys30(withModifiers24(reset, ["stop"]), ["enter"]),
                  withKeys30(withModifiers24(reset, ["stop"]), ["space"])
                ]
              }), null, 16, ["aria-label", "onKeydown"])) : createCommentVNode54("", true),
              !_ctx.$props.leftIcon && _ctx.$props.icon ? (openBlock108(), createBlock57(unref99(VaIcon), mergeProps51({
                key: 1,
                class: "va-time-input__right-button va-time-input__side-button",
                "aria-label": unref99(tp)(_ctx.$props.ariaToggleDropdownLabel)
              }, iconProps.value), null, 16, ["aria-label"])) : createCommentVNode54("", true)
            ]),
            _: 2
          }, [
            renderList28(filteredSlots.value, (name) => {
              return {
                name,
                fn: withCtx58((slotScope) => [
                  renderSlot89(_ctx.$slots, name, normalizeProps39(guardReactiveProps34({ ...slotScope, toggleDropdown, showDropdown, hideDropdown, isOpen: unref99(isOpenSync), focus: unref99(focus) })))
                ])
              };
            }),
            _ctx.$slots.prependInner || _ctx.$props.leftIcon ? {
              name: "prependInner",
              fn: withCtx58((slotScope) => [
                renderSlot89(_ctx.$slots, "prependInner", normalizeProps39(guardReactiveProps34({ ...slotScope, toggleDropdown, showDropdown, hideDropdown, isOpen: unref99(isOpenSync), focus: unref99(focus) }))),
                _ctx.$props.leftIcon ? (openBlock108(), createBlock57(unref99(VaIcon), mergeProps51({
                  key: 0,
                  class: "va-time-input__left-button va-time-input__side-button",
                  "aria-label": unref99(tp)(_ctx.$props.ariaToggleDropdownLabel)
                }, iconProps.value), null, 16, ["aria-label"])) : createCommentVNode54("", true)
              ]),
              key: "0"
            } : void 0
          ]), 1040, ["style"])
        ]),
        default: withCtx58(() => [
          createVNode44(unref99(VaDropdownContent), {
            "no-padding": "",
            onKeydown: [
              withKeys30(withModifiers24(hideDropdown, ["prevent"]), ["esc"]),
              withKeys30(withModifiers24(hideDropdown, ["prevent"]), ["enter"])
            ]
          }, {
            default: withCtx58(() => [
              createVNode44(_sfc_main110, mergeProps51({
                ref_key: "timePicker",
                ref: timePicker
              }, unref99(timePickerProps), {
                modelValue: unref99(valueComputed),
                "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => isRef10(valueComputed) ? valueComputed.value = $event : null)
              }), null, 16, ["modelValue"])
            ]),
            _: 1
          }, 8, ["onKeydown"])
        ]),
        _: 3
      }, 16, ["modelValue", "class", "style"]);
    };
  }
});

// node_modules/vuestic-ui/dist/es/src/components/va-time-input/index.js
var VaTimeInput = withConfigTransport$1(_sfc_main111);

// node_modules/vuestic-ui/dist/es/src/components/va-timeline/VaTimeline.js
import { h as h10, Fragment as Fragment33 } from "vue";
import "D:/Desktop/forntend/Front_End_Web_Hotel_Nhom_2/my-nuxt-app/node_modules/vuestic-ui/dist/es/VaTimeline.css";
var getPropsData = (slot) => slot == null ? void 0 : slot.props;
var getIsActive = (slot) => {
  var _a2;
  return !!((_a2 = slot == null ? void 0 : slot.props) == null ? void 0 : _a2.active) || false;
};
var isVueFragment = (slot) => slot.type === Fragment33;
var isEmptyArray = (arr) => arr && arr.length === 0;
function getSlots(slots) {
  var _a2;
  const defaultSlots = (_a2 = slots.default) == null ? void 0 : _a2.call(slots);
  if (!defaultSlots || isEmptyArray(defaultSlots)) {
    return [];
  }
  if (isVueFragment(defaultSlots[0])) {
    return defaultSlots[0].children;
  }
  return defaultSlots;
}
var processSlots = (context) => {
  const slots = getSlots(context.slots);
  slots.forEach((slot, index) => {
    if (!getPropsData(slot)) {
      slot.props = {};
    }
    const propsData = getPropsData(slot);
    propsData.vertical = context.props.vertical;
    if (context.props.centered) {
      propsData.inverted = !!(index % 2);
    }
    if (index === 0) {
      propsData.isFirst = true;
    }
    if (index === slots.length - 1) {
      propsData.isLast = true;
    }
    const currentSlotActive = propsData.active;
    if (!currentSlotActive) {
      return;
    }
    if (index === 0) {
      propsData.activePrevious = currentSlotActive;
    }
    if (index === slots.length - 1) {
      propsData.activeNext = currentSlotActive;
    }
    const previousSlotActive = getIsActive(slots[index - 1]);
    if (previousSlotActive) {
      propsData.activePrevious = true;
    }
    const nextSlotActive = getIsActive(slots[index + 1]);
    if (nextSlotActive) {
      propsData.activeNext = true;
    }
  });
  return slots;
};
var COMPONENT_NAME = "va-timeline";
var _sfc_main112 = {
  name: COMPONENT_NAME,
  props: {
    ...useComponentPresetProp,
    vertical: { type: Boolean },
    centered: { type: Boolean },
    alignTop: { type: Boolean }
  },
  setup(props, { slots }) {
    return () => h10(
      "div",
      {
        class: {
          [COMPONENT_NAME]: true,
          [`${COMPONENT_NAME}--vertical`]: props.vertical,
          [`${COMPONENT_NAME}--align-top`]: props.alignTop
        }
      },
      processSlots({ props, slots })
    );
  }
};

// node_modules/vuestic-ui/dist/es/src/components/va-timeline/index.js
var VaTimeline = withConfigTransport$1(_sfc_main112);

// node_modules/vuestic-ui/dist/es/src/components/va-timeline/VaTimelineItem/VaTimelineItem.vue_vue_type_script_lang.js
import { defineComponent as defineComponent112, h as h12 } from "vue";

// node_modules/vuestic-ui/dist/es/src/components/va-timeline/VaTimelineSeparator/VaTimelineSeparator.vue_vue_type_script_lang.js
import { defineComponent as defineComponent111, h as h11 } from "vue";
import "D:/Desktop/forntend/Front_End_Web_Hotel_Nhom_2/my-nuxt-app/node_modules/vuestic-ui/dist/es/VaTimelineSeparator.css";
var componentName = "va-timeline-separator";
var _sfc_main113 = defineComponent111({
  name: componentName,
  props: {
    ...useComponentPresetProp,
    color: { type: String, default: "primary" },
    vertical: { type: Boolean },
    active: { type: Boolean },
    activePrevious: { type: Boolean },
    activeNext: { type: Boolean }
  },
  setup(props) {
    const { getColor } = useColors();
    return () => h11(
      "div",
      {
        class: {
          [componentName]: true,
          [`${componentName}--vertical`]: props.vertical
        }
      },
      [
        h11("div", {
          class: {
            [`${componentName}__line`]: true,
            [`${componentName}__line--active`]: props.activePrevious
          },
          style: {
            backgroundColor: getColor(props.activePrevious ? props.color : "divider")
          }
        }),
        h11("div", {
          class: {
            [`${componentName}__center`]: true,
            [`${componentName}__center--active`]: props.active
          },
          style: {
            backgroundColor: getColor(props.active ? props.color : "divider")
          }
        }),
        h11("div", {
          class: {
            [`${componentName}__line`]: true,
            [`${componentName}__line--active`]: props.activeNext
          },
          style: {
            backgroundColor: getColor(props.activeNext ? props.color : "divider")
          }
        })
      ]
    );
  }
});

// node_modules/vuestic-ui/dist/es/src/components/va-timeline/VaTimelineSeparator/index.js
var VaTimelineSeparator = withConfigTransport$1(_sfc_main113);

// node_modules/vuestic-ui/dist/es/src/components/va-timeline/VaTimelineItem/VaTimelineItem.vue_vue_type_script_lang.js
import "D:/Desktop/forntend/Front_End_Web_Hotel_Nhom_2/my-nuxt-app/node_modules/vuestic-ui/dist/es/VaTimelineItem.css";
var COMPONENT_NAME2 = "va-timeline-item";
var VaTimelineSeparatorProps = extractComponentProps(VaTimelineSeparator);
var _sfc_main114 = defineComponent112({
  name: COMPONENT_NAME2,
  props: {
    ...useComponentPresetProp,
    ...VaTimelineSeparatorProps,
    color: { type: String, default: "primary" },
    isFirst: { type: Boolean },
    isLast: { type: Boolean },
    inverted: { type: Boolean }
  },
  setup(props, { slots }) {
    const children = [
      h12(
        VaTimelineSeparator,
        { ...filterComponentProps(VaTimelineSeparatorProps).value }
      )
    ];
    const before = props.inverted ? slots.after : slots.before;
    if (before) {
      children.unshift(
        h12(
          "div",
          { class: `${COMPONENT_NAME2}__before` },
          before()
        )
      );
    }
    const after = props.inverted ? slots.before : slots.after;
    if (after) {
      children.push(
        h12(
          "div",
          { class: `${COMPONENT_NAME2}__after` },
          after()
        )
      );
    }
    return () => h12(
      "div",
      {
        class: [
          { [COMPONENT_NAME2]: true },
          { [`${COMPONENT_NAME2}--vertical`]: props.vertical },
          { [`${COMPONENT_NAME2}--is-first`]: props.isFirst },
          { [`${COMPONENT_NAME2}--is-last`]: props.isLast }
        ]
      },
      children
    );
  }
});

// node_modules/vuestic-ui/dist/es/src/components/va-timeline/VaTimelineItem/index.js
var VaTimelineItem = withConfigTransport$1(_sfc_main114);

// node_modules/vuestic-ui/dist/es/src/components/va-time-picker/index.js
var VaTimePicker = withConfigTransport$1(_sfc_main110);

// node_modules/vuestic-ui/dist/es/src/components/va-tree-view/VaTreeView.vue_vue_type_script_setup_true_lang.js
import { defineComponent as defineComponent114, openBlock as openBlock110, createElementBlock as createElementBlock94, unref as unref101, renderSlot as renderSlot91, createTextVNode as createTextVNode33, Fragment as Fragment35, renderList as renderList30, createBlock as createBlock59, createSlots as createSlots10, withCtx as withCtx60, normalizeProps as normalizeProps41, guardReactiveProps as guardReactiveProps36 } from "vue";

// node_modules/vuestic-ui/dist/es/src/components/va-tree-view/hooks/useTreeView.js
import { computed as computed182, toRefs as toRefs11, ref as ref79, provide as provide10 } from "vue";

// node_modules/vuestic-ui/dist/es/src/components/va-tree-view/hooks/useTreeHelpers.js
var useTreeViewProps = {
  nodes: {
    type: Array,
    default: []
  },
  stateful: {
    type: Boolean,
    default: true
  },
  selectable: {
    type: Boolean,
    default: false
  },
  selectionType: {
    type: String,
    default: "leaf",
    validator: (v) => ["leaf", "independent"].includes(v)
  },
  valueBy: {
    type: [String, Function],
    default: "id"
  },
  textBy: {
    type: [String, Function],
    default: "label"
  },
  trackBy: {
    type: [String, Function],
    default: "id"
  },
  iconBy: {
    type: [String, Function],
    default: "icon"
  },
  disabledBy: {
    type: [String, Function],
    default: "disabled"
  },
  expandedBy: {
    type: [String, Function],
    default: "expanded"
  },
  checkedBy: {
    type: [String, Function],
    default: "checked"
  },
  childrenBy: {
    type: [String, Function],
    default: "children"
  },
  expandAll: {
    type: Boolean,
    default: false
  },
  expanded: {
    type: Array,
    default: []
  },
  expandNodeBy: {
    type: String,
    default: "leaf"
  },
  filter: {
    type: String,
    default: ""
  },
  filterMethod: {
    type: Function,
    default: void 0
  },
  checked: {
    type: Array,
    default: []
  },
  color: {
    type: String,
    default: "primary"
  }
};
var useTreeViewEmits = ["update:modelValue", "update:checked", "update:expanded", "update:selected"];
var useTreeHelpers = (props) => {
  const isStringOrNumber = (node) => {
    const typeOfNode = typeof node;
    return typeOfNode === "string" || typeOfNode === "number";
  };
  const getNodeProperty = (node, key) => !key || isStringOrNumber(node) ? node : getValueByKey(node, key);
  const getValue = (node) => getNodeProperty(node, props.valueBy);
  const getNodeByValue = (value) => {
    if (!props.valueBy) {
      return value;
    }
    return props.nodes.find((node) => value === getValue(node)) || value;
  };
  const getText = (node) => getNodeProperty(node, props.textBy);
  const getChecked = (node) => getNodeProperty(node, props.checkedBy);
  const getDisabled = (node) => getNodeProperty(node, props.disabledBy);
  const getExpanded = (node) => getNodeProperty(node, props.expandedBy);
  const getTrackBy = (node) => getNodeProperty(node, props.trackBy);
  const getChildren = (node) => getNodeProperty(node, props.childrenBy) ?? [];
  const iterateNodes = (nodes, cb) => {
    nodes.forEach((node) => {
      const children = node.children || [];
      if (children.length) {
        iterateNodes(children, cb);
      }
      cb(node);
    });
  };
  return {
    getText,
    getValue,
    getChecked,
    getTrackBy,
    getChildren,
    getDisabled,
    getExpanded,
    iterateNodes,
    getNodeByValue,
    getNodeProperty
  };
};

// node_modules/vuestic-ui/dist/es/src/components/va-tree-view/types.js
var TreeViewKey = Symbol("TreeView");

// node_modules/vuestic-ui/dist/es/src/components/va-tree-view/hooks/useTreeKeyboardNavigation.js
var useTreeKeyboardNavigation = (props, methods) => {
  const { emit, toggleNode, toggleCheckbox } = methods;
  const isElementExpanded = (currentElement) => (currentElement == null ? void 0 : currentElement.getAttribute("aria-expanded")) === "true";
  const getParentElement = (currentElement) => {
    var _a2;
    return ((_a2 = currentElement == null ? void 0 : currentElement.parentElement) == null ? void 0 : _a2.closest(".va-tree-node")) || null;
  };
  const getPreviousElement = (currentElement) => currentElement == null ? void 0 : currentElement.previousElementSibling;
  const findPreviousElement = (currentElement) => {
    if (!currentElement) {
      return null;
    }
    let previousElement = getPreviousElement(currentElement);
    let lastChildElement = isElementExpanded(previousElement) && getLastChildElement(previousElement);
    if (lastChildElement) {
      do {
        if (isElementExpanded(lastChildElement)) {
          lastChildElement = getLastChildElement(lastChildElement);
          if (lastChildElement) {
            continue;
          } else {
            break;
          }
        } else {
          previousElement = lastChildElement;
          break;
        }
      } while (true);
    }
    if (!previousElement) {
      return getParentElement(currentElement);
    }
    return previousElement;
  };
  const getNextElement = (currentElement) => currentElement == null ? void 0 : currentElement.nextElementSibling;
  const findNextElement = (currentElement) => {
    if (!currentElement) {
      return null;
    }
    let nextElement = getNextElement(currentElement);
    const isCurrentExpanded = isElementExpanded(currentElement);
    if (!nextElement) {
      let parentElement = getParentElement(currentElement);
      do {
        if (!getNextElement(parentElement)) {
          parentElement = getParentElement(parentElement);
          if (!parentElement) {
            break;
          } else {
            continue;
          }
        } else {
          nextElement = getNextElement(parentElement);
          break;
        }
      } while (true);
    }
    if (isCurrentExpanded) {
      return getFirstChildElement(currentElement);
    }
    return nextElement;
  };
  const getFirstChildElement = (currentElement) => {
    var _a2;
    return ((_a2 = currentElement == null ? void 0 : currentElement.querySelector(".va-tree-node-children")) == null ? void 0 : _a2.firstElementChild) || null;
  };
  const getLastChildElement = (currentElement) => {
    var _a2;
    return ((_a2 = currentElement == null ? void 0 : currentElement.querySelector(".va-tree-node-children")) == null ? void 0 : _a2.lastElementChild) || null;
  };
  const onHorizontalMove = (currentElement, dir, node) => {
    var _a2, _b;
    const isCurrentElementExpanded = isElementExpanded(currentElement);
    if (dir === "left") {
      if (isCurrentElementExpanded) {
        toggleNode(node);
      } else {
        (_a2 = getParentElement(currentElement)) == null ? void 0 : _a2.focus();
      }
    } else {
      if (!isCurrentElementExpanded) {
        toggleNode(node);
      } else {
        (_b = getFirstChildElement(currentElement)) == null ? void 0 : _b.focus();
      }
    }
  };
  const onVerticalMove = (currentElement, dir) => {
    var _a2, _b;
    if (dir === "up") {
      (_a2 = findPreviousElement(currentElement)) == null ? void 0 : _a2.focus();
    } else {
      (_b = findNextElement(currentElement)) == null ? void 0 : _b.focus();
    }
  };
  const handleKeyboardNavigation = (event, node) => {
    const currentElement = event.target;
    switch (event.code) {
      case "ArrowUp":
        onVerticalMove(currentElement, "up");
        break;
      case "ArrowRight":
        onHorizontalMove(currentElement, "right", node);
        break;
      case "ArrowDown":
        onVerticalMove(currentElement, "down");
        break;
      case "ArrowLeft":
        onHorizontalMove(currentElement, "left", node);
        break;
      case "Space":
        if (props.selectable) {
          const state = typeof node.checked !== "undefined" ? !node.checked : null;
          toggleCheckbox(node, state);
        } else {
          emit("update:selected", node);
        }
        break;
      case "Escape":
        if (!props.selectable) {
          emit("update:selected", null);
        }
        currentElement.blur();
        break;
      default:
        currentElement.blur();
    }
  };
  return { handleKeyboardNavigation };
};
var useTreeKeyboardNavigation$1 = useTreeKeyboardNavigation;

// node_modules/vuestic-ui/dist/es/src/components/va-tree-view/hooks/useTreeView.js
var useTreeView = (props, emit) => {
  const { getColor } = useColors();
  const colorComputed = computed182(() => getColor(props.color));
  const isLeafSelectionComputed = computed182(() => props.selectionType === "leaf");
  const {
    getText,
    getValue,
    getChecked,
    getTrackBy,
    getChildren,
    getDisabled,
    getExpanded,
    iterateNodes,
    getNodeProperty
  } = useTreeHelpers(props);
  const { nodes, expandAll, filter, filterMethod, textBy } = toRefs11(props);
  const { valueComputed: expandedList } = useStateful(props, emit, "expanded");
  const { valueComputed: checkedList } = useStateful(props, emit, "checked");
  const selectedNode = ref79();
  const selectedNodeComputed = computed182({
    get: () => selectedNode.value,
    set: (node) => {
      const value = getValue(node);
      if (selectedNode.value !== value) {
        selectedNode.value = value;
        emit("update:selected", node);
      }
    }
  });
  const updateModel = (model, values, state) => {
    if (state) {
      model.value = model.value.concat(values).filter((value, idx, self) => self.indexOf(value) === idx);
    } else {
      model.value = model.value.filter((v) => !values.includes(v));
    }
  };
  const toggleCheckbox = (node, state) => {
    let stateValue = state === null ? true : state;
    if (state && node.indeterminate) {
      stateValue = false;
    }
    const values = [getValue(node)];
    if (isLeafSelectionComputed.value && node.hasChildren) {
      const toggleChildren = (nodes2) => {
        nodes2.forEach((node2) => {
          if (node2.disabled) {
            return;
          }
          const children = getChildren(node2);
          if (children.length) {
            toggleChildren(children);
          }
          values.push(getValue(node2));
        });
      };
      toggleChildren(getChildren(node));
    }
    updateModel(checkedList, values, stateValue);
  };
  const toggleNode = (node) => {
    node.expanded = !node.expanded;
  };
  const createNode = ({ node, level, children = [], computedFilterMethod: computedFilterMethod2 }) => {
    var _a2;
    const valueBy = getValue(node);
    let matchesFilter = true;
    const hasChildren = !!children.length;
    let indeterminate = false;
    let checked = checkedList.value.includes(valueBy) || false;
    if (isLeafSelectionComputed.value && hasChildren) {
      const isAllChildrenChecked = children.every((c) => c.checked);
      checked = isAllChildrenChecked;
      indeterminate = !isAllChildrenChecked && children.some((c) => c.indeterminate || c.checked);
      if (indeterminate) {
        checked = null;
      }
    }
    if (filter.value) {
      matchesFilter = (children == null ? void 0 : children.some((c) => c.matchesFilter)) || ((_a2 = computedFilterMethod2.value) == null ? void 0 : _a2.call(computedFilterMethod2, node, filter.value, textBy.value));
    }
    return {
      ...node,
      level,
      checked,
      children,
      get disabled() {
        return getDisabled(node) || false;
      },
      get expanded() {
        const expandKey = props.expandedBy;
        return expandKey in node ? node[expandKey] : expandedList.value.includes(valueBy) || false;
      },
      set expanded(value) {
        const expandKey = props.expandedBy;
        node[expandKey] = value;
        if (hasChildren) {
          updateModel(expandedList, [getValue(node)], value);
        }
      },
      hasChildren,
      matchesFilter,
      indeterminate
    };
  };
  const computedFilterMethod = computed182(() => {
    if (filterMethod == null ? void 0 : filterMethod.value) {
      return filterMethod.value;
    }
    return (node, filter2) => getText(node).toLowerCase().includes(filter2.toLowerCase());
  });
  const buildTree = (nodes2, level = 0) => nodes2.map((node) => {
    const treeItemChildren = getChildren(node);
    if (treeItemChildren.length) {
      const children = buildTree(treeItemChildren, level + 1);
      return createNode({ node, level, children, computedFilterMethod });
    }
    return createNode({ node, level, computedFilterMethod });
  });
  const getFilteredNodes = (nodes2) => nodes2.filter((node) => {
    if (node.children) {
      node.children = getFilteredNodes(node.children);
    }
    if (node.children.length === 0) {
      node.hasChildren = false;
    }
    return node.matchesFilter;
  });
  const { handleKeyboardNavigation } = useTreeKeyboardNavigation$1(props, { emit, toggleCheckbox, toggleNode });
  provide10(TreeViewKey, {
    selectedNodeComputed,
    colorComputed,
    iconBy: props.iconBy,
    selectable: props.selectable,
    expandNodeBy: props.expandNodeBy,
    getText,
    getValue,
    getTrackBy,
    toggleNode,
    toggleCheckbox,
    getNodeProperty,
    handleKeyboardNavigation
  });
  const treeItems = computed182(() => buildTree(nodes.value));
  const checkForInitialValues = () => {
    const expandedValues = [];
    const checkedValues = [];
    iterateNodes(nodes.value, (node) => {
      if (expandAll.value) {
        expandedValues.push(getValue(node));
      } else {
        getExpanded(node) && expandedValues.push(getValue(node));
      }
      if (getChecked(node)) {
        checkedValues.push(getValue(node));
      }
    });
    if (expandedValues.length) {
      updateModel(expandedList, expandedValues, true);
    }
    if (checkedValues.length) {
      updateModel(checkedList, checkedValues, true);
    }
  };
  checkForInitialValues();
  return {
    treeItems: computed182(() => getFilteredNodes(treeItems.value)),
    getText,
    getTrackBy,
    toggleCheckbox
  };
};
var useTreeView$1 = useTreeView;

// node_modules/vuestic-ui/dist/es/src/components/va-tree-view/components/VaTreeNode/VaTreeNode.vue_vue_type_script_setup_true_lang.js
import { defineComponent as defineComponent113, computed as computed183, resolveComponent as resolveComponent2, openBlock as openBlock109, createElementBlock as createElementBlock93, normalizeClass as normalizeClass54, unref as unref100, withKeys as withKeys31, withModifiers as withModifiers25, createElementVNode as createElementVNode52, renderSlot as renderSlot90, normalizeProps as normalizeProps40, guardReactiveProps as guardReactiveProps35, createVNode as createVNode45, createCommentVNode as createCommentVNode55, createTextVNode as createTextVNode32, toDisplayString as toDisplayString42, withDirectives as withDirectives9, Fragment as Fragment34, renderList as renderList29, createBlock as createBlock58, createSlots as createSlots9, withCtx as withCtx59, vShow as vShow4 } from "vue";
import "D:/Desktop/forntend/Front_End_Web_Hotel_Nhom_2/my-nuxt-app/node_modules/vuestic-ui/dist/es/VaTreeNode.css";
var _hoisted_167 = ["role", "aria-expanded", "aria-disabled", "aria-checked", "tabindex"];
var _hoisted_233 = { class: "va-tree-node-root" };
var _hoisted_322 = {
  key: 2,
  class: "va-tree-node-content__item"
};
var _hoisted_413 = ["aria-hidden"];
var INJECTION_ERROR_MESSAGE5 = "The VaTreeNode component should be used in the context of VaTreeView component";
var _sfc_main115 = defineComponent113({
  ...{
    name: "VaTreeNode"
  },
  __name: "VaTreeNode",
  props: {
    node: {
      type: Object,
      required: true
    }
  },
  setup(__props) {
    const props = __props;
    const {
      iconBy,
      selectable,
      expandNodeBy,
      colorComputed,
      selectedNodeComputed,
      getText,
      getTrackBy,
      toggleNode,
      toggleCheckbox,
      getNodeProperty,
      handleKeyboardNavigation
    } = useStrictInject(TreeViewKey, INJECTION_ERROR_MESSAGE5);
    const labelComputed = computed183(() => getText(props.node) || "");
    const isExpandedComputed = computed183(() => props.node.hasChildren ? !!props.node.expanded : void 0);
    const iconComputed = computed183(() => getNodeProperty(props.node, iconBy));
    const roleComputed = computed183(() => props.node.hasChildren ? "group" : "treeitem");
    const treeNodeClassComputed = useBem("va-tree-node", () => ({
      disabled: Boolean(props.node.disabled),
      checked: Boolean(props.node.checked),
      hasChildren: Boolean(props.node.hasChildren),
      [`level-${props.node.level}`]: true,
      [`expand-by-${expandNodeBy}`]: true
    }));
    const expandedClassComputed = useBem("va-tree-node-children", () => ({
      expanded: !!isExpandedComputed.value
    }));
    const indentClassComputed = useBem("va-tree-node-content", () => ({
      indent: props.node.hasChildren === false
    }));
    const cursorClassComputed = useBem("va-tree-node-content", () => ({
      clickable: props.node.hasChildren === true && expandNodeBy === "node"
    }));
    const tabIndexComputed = computed183(() => props.node.disabled ? -1 : 0);
    const onNodeClick = (type) => {
      const nodeType = expandNodeBy === "node" && type === "leaf" ? "node" : type;
      if (expandNodeBy === nodeType) {
        toggleNode(props.node);
      }
      selectedNodeComputed.value = props.node;
    };
    return (_ctx, _cache) => {
      const _component_va_tree_node = resolveComponent2("va-tree-node", true);
      return openBlock109(), createElementBlock93("div", {
        class: normalizeClass54(["va-tree-node", unref100(treeNodeClassComputed)]),
        role: roleComputed.value,
        "aria-expanded": isExpandedComputed.value,
        "aria-disabled": _ctx.$props.node.disabled,
        "aria-checked": !!_ctx.$props.node.checked,
        tabindex: tabIndexComputed.value,
        onKeydown: [
          _cache[4] || (_cache[4] = withKeys31(withModifiers25(($event) => unref100(handleKeyboardNavigation)($event, _ctx.$props.node), ["stop", "prevent"]), ["up"])),
          _cache[5] || (_cache[5] = withKeys31(withModifiers25(($event) => unref100(handleKeyboardNavigation)($event, _ctx.$props.node), ["stop", "prevent"]), ["right"])),
          _cache[6] || (_cache[6] = withKeys31(withModifiers25(($event) => unref100(handleKeyboardNavigation)($event, _ctx.$props.node), ["stop", "prevent"]), ["down"])),
          _cache[7] || (_cache[7] = withKeys31(withModifiers25(($event) => unref100(handleKeyboardNavigation)($event, _ctx.$props.node), ["stop", "prevent"]), ["left"])),
          _cache[8] || (_cache[8] = withKeys31(withModifiers25(($event) => unref100(handleKeyboardNavigation)($event, _ctx.$props.node), ["stop", "prevent"]), ["space"])),
          _cache[9] || (_cache[9] = withKeys31(withModifiers25(($event) => unref100(handleKeyboardNavigation)($event, _ctx.$props.node), ["stop", "prevent"]), ["esc"]))
        ]
      }, [
        createElementVNode52("div", _hoisted_233, [
          createElementVNode52("div", {
            class: normalizeClass54(["va-tree-node-content", unref100(indentClassComputed)]),
            onClick: _cache[3] || (_cache[3] = ($event) => onNodeClick("node"))
          }, [
            _ctx.$props.node.hasChildren ? (openBlock109(), createElementBlock93("div", {
              key: 0,
              class: "va-tree-node-content__item va-tree-node-content__item--leaf",
              onClick: _cache[0] || (_cache[0] = withModifiers25(($event) => onNodeClick("leaf"), ["stop"]))
            }, [
              renderSlot90(_ctx.$slots, "icon-toggle", normalizeProps40(guardReactiveProps35(_ctx.$props.node)), () => [
                createVNode45(unref100(VaIcon), {
                  name: isExpandedComputed.value ? "keyboard_arrow_down" : "keyboard_arrow_right",
                  size: "20px"
                }, null, 8, ["name"])
              ])
            ])) : createCommentVNode55("", true),
            unref100(selectable) ? (openBlock109(), createElementBlock93("div", {
              key: 1,
              class: "va-tree-node-content__item",
              onClick: _cache[2] || (_cache[2] = withModifiers25(() => {
              }, ["stop"]))
            }, [
              renderSlot90(_ctx.$slots, "checkbox", normalizeProps40(guardReactiveProps35(_ctx.$props.node)), () => [
                createVNode45(unref100(VaCheckbox), {
                  "model-value": _ctx.$props.node.checked,
                  color: unref100(colorComputed),
                  indeterminate: "",
                  "onUpdate:modelValue": _cache[1] || (_cache[1] = (v) => unref100(toggleCheckbox)(_ctx.$props.node, v)),
                  class: "va-tree-node__checkbox"
                }, null, 8, ["model-value", "color"])
              ])
            ])) : createCommentVNode55("", true),
            iconComputed.value ? (openBlock109(), createElementBlock93("div", _hoisted_322, [
              renderSlot90(_ctx.$slots, "icon", normalizeProps40(guardReactiveProps35(_ctx.$props.node)), () => [
                createVNode45(unref100(VaIcon), {
                  name: iconComputed.value,
                  size: "small"
                }, null, 8, ["name"])
              ])
            ])) : createCommentVNode55("", true),
            createElementVNode52("div", {
              class: normalizeClass54(["va-tree-node-content__body", unref100(cursorClassComputed)])
            }, [
              renderSlot90(_ctx.$slots, "content", normalizeProps40(guardReactiveProps35(_ctx.$props.node)), () => [
                createTextVNode32(toDisplayString42(labelComputed.value), 1)
              ])
            ], 2)
          ], 2)
        ]),
        withDirectives9(createElementVNode52("div", {
          "aria-hidden": !_ctx.$props.node.expanded,
          class: normalizeClass54(["va-tree-node-children", unref100(expandedClassComputed)])
        }, [
          (openBlock109(true), createElementBlock93(Fragment34, null, renderList29(_ctx.$props.node.children, (childNode) => {
            return openBlock109(), createBlock58(_component_va_tree_node, {
              key: unref100(getTrackBy)(childNode),
              node: childNode
            }, createSlots9({ _: 2 }, [
              renderList29(_ctx.$slots, (_, name) => {
                return {
                  name,
                  fn: withCtx59((slotScope) => [
                    renderSlot90(_ctx.$slots, name, normalizeProps40(guardReactiveProps35(slotScope)))
                  ])
                };
              })
            ]), 1032, ["node"]);
          }), 128))
        ], 10, _hoisted_413), [
          [vShow4, _ctx.$props.node.hasChildren]
        ])
      ], 42, _hoisted_167);
    };
  }
});

// node_modules/vuestic-ui/dist/es/src/components/va-tree-view/components/VaTreeNode/index.js
var VaTreeNode = withConfigTransport$1(_sfc_main115);

// node_modules/vuestic-ui/dist/es/src/components/va-tree-view/VaTreeView.vue_vue_type_script_setup_true_lang.js
import "D:/Desktop/forntend/Front_End_Web_Hotel_Nhom_2/my-nuxt-app/node_modules/vuestic-ui/dist/es/VaTreeView.css";
var _hoisted_168 = {
  class: "va-tree-view",
  role: "tree"
};
var _sfc_main116 = defineComponent114({
  ...{
    name: "VaTreeView"
  },
  __name: "VaTreeView",
  props: { ...useTreeViewProps },
  emits: [...useTreeViewEmits],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const { treeItems, getTrackBy } = useTreeView$1(props, emit);
    return (_ctx, _cache) => {
      return openBlock110(), createElementBlock94("div", _hoisted_168, [
        _ctx.$props.filter && !unref101(treeItems).length ? renderSlot91(_ctx.$slots, "not-found", { key: 0 }, () => [
          createTextVNode33("No matching nodes found")
        ]) : (openBlock110(true), createElementBlock94(Fragment35, { key: 1 }, renderList30(unref101(treeItems), (nodeItem) => {
          return openBlock110(), createBlock59(unref101(VaTreeNode), {
            key: unref101(getTrackBy)(nodeItem),
            node: nodeItem
          }, createSlots10({ _: 2 }, [
            renderList30(_ctx.$slots, (_, name) => {
              return {
                name,
                fn: withCtx60((slotScope) => [
                  renderSlot91(_ctx.$slots, name, normalizeProps41(guardReactiveProps36(slotScope)))
                ])
              };
            })
          ]), 1032, ["node"]);
        }), 128))
      ]);
    };
  }
});

// node_modules/vuestic-ui/dist/es/src/components/va-tree-view/index.js
var VaTreeView = withConfigTransport$1(_sfc_main116);

// node_modules/vuestic-ui/dist/es/src/components/va-scroll-container/VaScrollContainer.vue_vue_type_script_setup_true_lang.js
import { defineComponent as defineComponent115, computed as computed184, openBlock as openBlock111, createElementBlock as createElementBlock95, normalizeStyle as normalizeStyle56, createElementVNode as createElementVNode53, renderSlot as renderSlot92 } from "vue";
import "D:/Desktop/forntend/Front_End_Web_Hotel_Nhom_2/my-nuxt-app/node_modules/vuestic-ui/dist/es/VaScrollContainer.css";
var _hoisted_169 = { class: "va-scroll-container__content" };
var _sfc_main117 = defineComponent115({
  ...{
    name: "VaScrollContainer"
  },
  __name: "VaScrollContainer",
  props: {
    ...useSizeProps,
    vertical: { type: Boolean, default: false },
    horizontal: { type: Boolean, default: false },
    color: { type: String, default: "secondary" },
    rtl: { type: Boolean, default: false },
    gradient: { type: Boolean, default: false },
    sizesConfig: {
      type: Object,
      default: () => ({
        defaultSize: 4,
        sizes: { small: 4, medium: 6, large: 8 }
      })
    },
    size: {
      type: String,
      default: "small",
      validator: (v) => ["small", "medium", "large"].includes(v)
    }
  },
  setup(__props) {
    const props = __props;
    const { getColor } = useColors();
    const { sizeComputed } = useSize(props);
    const overflowX = computed184(() => props.horizontal ? "auto" : "hidden");
    const overflowY = computed184(() => props.vertical ? "auto" : "hidden");
    const scrollColor = computed184(() => {
      const color = getColor(props.color);
      return props.gradient ? `linear-gradient(0deg, var(--va-scroll-container-scrollbar-gradient-to) 0%, ${color} 100%)` : color;
    });
    const scrollbarSize = computed184(() => sizeComputed.value);
    const scrollbarPosition = computed184(() => props.rtl ? "rtl" : "ltr");
    return (_ctx, _cache) => {
      return openBlock111(), createElementBlock95("div", {
        class: "va-scroll-container",
        style: normalizeStyle56(`--va-scroll-color: ${String(scrollColor.value)};--va-scrollbar-size: ${String(scrollbarSize.value)};--va-overflow-x: ${String(overflowX.value)};--va-overflow-y: ${String(overflowY.value)};--va-scrollbar-position: ${String(scrollbarPosition.value)}`)
      }, [
        createElementVNode53("div", _hoisted_169, [
          renderSlot92(_ctx.$slots, "default")
        ])
      ], 4);
    };
  }
});

// node_modules/vuestic-ui/dist/es/src/components/va-scroll-container/index.js
var VaScrollContainer = withConfigTransport$1(_sfc_main117);

// node_modules/vuestic-ui/dist/es/src/components/va-viewer/VaViewer.vue_vue_type_script_setup_true_lang.js
import { defineComponent as defineComponent116, ref as ref80, computed as computed185, useSlots as useSlots15, openBlock as openBlock112, createElementBlock as createElementBlock96, Fragment as Fragment36, createElementVNode as createElementVNode54, mergeProps as mergeProps52, renderSlot as renderSlot93, normalizeProps as normalizeProps42, guardReactiveProps as guardReactiveProps37, createCommentVNode as createCommentVNode56, createBlock as createBlock60, Teleport as Teleport4, createVNode as createVNode46, unref as unref102 } from "vue";
import "D:/Desktop/forntend/Front_End_Web_Hotel_Nhom_2/my-nuxt-app/node_modules/vuestic-ui/dist/es/VaViewer.css";
var _hoisted_170 = { class: "va-viewer-content" };
var _sfc_main118 = defineComponent116({
  ...{
    name: "VaViewer",
    inheritAttrs: false
  },
  __name: "VaViewer",
  setup(__props, { expose: __expose }) {
    const content = ref80();
    const controls = ref80();
    const isMounted = useIsMounted();
    const isClosed = ref80(true);
    const isOpened = computed185(() => isMounted.value && !isClosed.value);
    const openViewer = () => isClosed.value = false;
    const closeViewer = () => isClosed.value = true;
    const slots = useSlots15();
    const handleAnchorClick = () => {
      if (!slots.anchor) {
        openViewer();
      }
    };
    useClickOutside([content, controls], closeViewer);
    const document2 = useDocument();
    const teleportTarget = computed185(() => {
      var _a2;
      return (_a2 = document2.value) == null ? void 0 : _a2.body;
    });
    __expose({
      openViewer,
      closeViewer
    });
    return (_ctx, _cache) => {
      return openBlock112(), createElementBlock96(Fragment36, null, [
        createElementVNode54("div", mergeProps52({ class: "va-viewer" }, _ctx.$attrs, { onClick: handleAnchorClick }), [
          renderSlot93(_ctx.$slots, "anchor", normalizeProps42(guardReactiveProps37({ openViewer }))),
          !_ctx.$slots.anchor ? renderSlot93(_ctx.$slots, "default", { key: 0 }) : createCommentVNode56("", true)
        ], 16),
        isOpened.value ? (openBlock112(), createBlock60(Teleport4, {
          key: 0,
          to: teleportTarget.value
        }, [
          createElementVNode54("div", _hoisted_170, [
            createElementVNode54("div", {
              ref_key: "content",
              ref: content,
              class: "va-viewer-content__main-area"
            }, [
              !_ctx.$slots.image ? renderSlot93(_ctx.$slots, "default", { key: 0 }) : createCommentVNode56("", true),
              renderSlot93(_ctx.$slots, "image")
            ], 512),
            createElementVNode54("div", {
              ref_key: "controls",
              ref: controls,
              class: "va-viewer-content__controls-panel"
            }, [
              renderSlot93(_ctx.$slots, "controls"),
              renderSlot93(_ctx.$slots, "close", normalizeProps42(guardReactiveProps37({ close: closeViewer })), () => [
                createElementVNode54("button", {
                  class: "va-viewer-content__close-button",
                  onClick: closeViewer
                }, [
                  createVNode46(unref102(VaIcon), {
                    name: "close",
                    color: "backgroundPrimary"
                  })
                ])
              ])
            ], 512)
          ])
        ], 8, ["to"])) : createCommentVNode56("", true)
      ], 64);
    };
  }
});

// node_modules/vuestic-ui/dist/es/src/components/va-viewer/index.js
var VaViewer = withConfigTransport$1(_sfc_main118);

// node_modules/vuestic-ui/dist/es/src/components/va-value/VaValue.vue_vue_type_script_lang.js
import { defineComponent as defineComponent117, ref as ref81, h as h13, Fragment as Fragment37 } from "vue";
var _sfc_main119 = defineComponent117({
  name: "VaValue",
  props: {
    defaultValue: { type: null, required: false, default: false }
  },
  setup(props, { slots }) {
    const value = ref81(props.defaultValue);
    const slotBind = new Proxy(value, {
      get(target, prop) {
        if (prop === "value") {
          return target.value;
        }
        return target[prop];
      },
      set(target, prop, value2) {
        if (prop === "value") {
          target.value = value2;
        }
        return true;
      }
    });
    return () => {
      return h13(Fragment37, [renderSlotNodes(slots.default, slotBind)]);
    };
  }
});

// node_modules/vuestic-ui/dist/es/src/components/va-value/index.js
var VaValue = withConfigTransport$1(_sfc_main119);

// node_modules/vuestic-ui/dist/es/src/components/va-textarea/VaTextarea.vue_vue_type_script_setup_true_lang.js
import { defineComponent as defineComponent118, useAttrs as useAttrs8, shallowRef as shallowRef40, computed as computed186, ref as ref83, watchEffect as watchEffect12, openBlock as openBlock113, createBlock as createBlock61, unref as unref103, mergeProps as mergeProps53, withCtx as withCtx61, createElementVNode as createElementVNode55, normalizeClass as normalizeClass55, withDirectives as withDirectives10, isRef as isRef11, vModelText as vModelText2 } from "vue";

// node_modules/vuestic-ui/dist/es/src/components/va-textarea/composables/useLineHeight.js
import { ref as ref82, watch as watch61 } from "vue";
var makeTextElement = (textarea) => {
  const div = document.createElement("div");
  div.style.position = "absolute";
  div.style.top = "0";
  div.style.left = "0";
  div.style.width = "auto";
  const { font } = window.getComputedStyle(textarea);
  div.style.font = font;
  div.textContent = "Vuestic";
  div.style.zIndex = "-1";
  div.style.pointerEvents = "none";
  div.style.opacity = "0";
  div.ariaHidden = "true";
  div.innerText = textarea.value;
  return div;
};
var useTextHeight = (textarea, text) => {
  const textElement = ref82();
  const textHeight = ref82();
  watch61(textarea, (el) => {
    var _a2, _b;
    if (el) {
      textElement.value = makeTextElement(el);
      (_b = (_a2 = textarea.value) == null ? void 0 : _a2.parentElement) == null ? void 0 : _b.appendChild(textElement.value);
    }
  });
  useResizeObserver(textElement, (newElement) => {
    if (!newElement || !textarea.value) {
      return;
    }
    textHeight.value = newElement[0].contentRect.height;
  });
  watch61(text, (newText) => {
    if (!textElement.value) {
      return;
    }
    textElement.value.innerText = String(newText);
    textElement.value.innerHTML += "&nbsp;;";
  });
  return textHeight;
};

// node_modules/vuestic-ui/dist/es/src/components/va-textarea/VaTextarea.vue_vue_type_script_setup_true_lang.js
import "D:/Desktop/forntend/Front_End_Web_Hotel_Nhom_2/my-nuxt-app/node_modules/vuestic-ui/dist/es/VaTextarea.css";
var _hoisted_171 = ["rows", "loading", "ariaLabel"];
var positiveNumberValidator = (val) => {
  if (val > 0) {
    return true;
  }
  throw new Error(
    `\`minRows|maxRows\` must be a positive integer greater than 0, but ${val} is provided`
  );
};
var { createEmits: createEmits2, createListeners: createListeners2 } = useEmitProxy([
  "input",
  "change",
  "click",
  "update:modelValue"
]);
var VaInputWrapperProps5 = extractComponentProps(VaInputWrapper);
var _sfc_main120 = defineComponent118({
  ...{
    name: "VaTextarea"
  },
  __name: "VaTextarea",
  props: {
    ...useFormFieldProps,
    ...VaInputWrapperProps5,
    ...useStatefulProps,
    ...useValidationProps,
    modelValue: { type: [String, Number], default: "" },
    placeholder: { type: String },
    autosize: { type: Boolean, default: false },
    minRows: {
      type: [Number, String],
      default: 1,
      validator: positiveNumberValidator
    },
    maxRows: {
      type: [Number, String],
      validator: positiveNumberValidator
    },
    resize: {
      type: Boolean,
      default: true
    },
    clearValue: {
      type: [String],
      default: ""
    }
  },
  emits: [...createEmits2(), ...useValidationEmits],
  setup(__props, { expose: __expose, emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const attrs = useAttrs8();
    const textarea = shallowRef40();
    const { valueComputed } = useStateful(props, emit, "modelValue", {
      defaultValue: ""
    });
    const focus = () => {
      focusElement(textarea.value);
    };
    const blur = () => {
      blurElement(textarea.value);
    };
    const reset = () => withoutValidation(() => {
      emit("update:modelValue", props.clearValue);
      emit("clear");
      resetValidation();
    });
    const {
      isDirty,
      isTouched,
      computedError,
      computedErrorMessages,
      listeners: validationListeners,
      validationAriaAttributes,
      isLoading,
      resetValidation,
      withoutValidation
    } = useValidation(props, emit, {
      value: valueComputed,
      focus,
      reset
    });
    const isResizable = computed186(() => {
      return props.resize && !props.autosize;
    });
    const rows = ref83(props.minRows);
    const textHeight = useTextHeight(textarea, valueComputed);
    function calculateInputHeight() {
      let minRows = parseFloat(String(props.minRows));
      let maxRows = parseFloat(String(props.maxRows));
      minRows = isNaN(minRows) ? 1 : minRows;
      maxRows = isNaN(maxRows) ? Infinity : maxRows;
      if (!props.autosize) {
        rows.value = Math.max(maxRows, Math.min(minRows, maxRows ?? 0));
        return;
      }
      if (!textHeight.value || !textarea.value) {
        return;
      }
      const style = getComputedStyle(textarea.value);
      const height = textHeight.value;
      const lineHeight = parseFloat(style.lineHeight);
      const minHeight = Math.max(
        minRows * lineHeight,
        minRows + Math.round(lineHeight)
      );
      const maxHeight = maxRows * lineHeight || Infinity;
      const newHeight = Math.max(minHeight, Math.min(maxHeight, height ?? 0));
      rows.value = Math.round(newHeight / lineHeight);
      textarea.value.style.height = `${newHeight + 1}px`;
    }
    watchEffect12(() => {
      calculateInputHeight();
    });
    const computedStyle = computed186(
      () => ({
        resize: isResizable.value ? void 0 : "none"
      })
    );
    const computedProps = computed186(() => ({
      ...pick(props, ["disabled", "readonly", "placeholder", "name"])
    }));
    const computedInputAttributes = computed186(() => ({
      ...validationAriaAttributes.value,
      ...omit(attrs, ["class", "style"])
    }));
    const vaInputWrapperProps = filterComponentProps(VaInputWrapperProps5);
    const listeners = createListeners2(emit);
    __expose({
      isDirty,
      isTouched,
      isLoading,
      computedError,
      computedErrorMessages,
      reset,
      focus,
      blur,
      value: valueComputed,
      withoutValidation,
      resetValidation
    });
    return (_ctx, _cache) => {
      return openBlock113(), createBlock61(unref103(VaInputWrapper), mergeProps53({ class: "va-textarea" }, unref103(vaInputWrapperProps), {
        error: unref103(computedError),
        "error-messages": unref103(computedErrorMessages)
      }), {
        default: withCtx61(() => [
          createElementVNode55("div", {
            class: normalizeClass55(["va-textarea__resize-wrapper", {
              "va-textarea__resize-wrapper--resizable": isResizable.value
            }])
          }, [
            withDirectives10(createElementVNode55("textarea", mergeProps53({
              "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => isRef11(valueComputed) ? valueComputed.value = $event : null)
            }, { ...computedProps.value, ...unref103(listeners), ...computedInputAttributes.value, ...unref103(validationListeners) }, {
              class: ["va-textarea__textarea", {
                "va-textarea__textarea--autosize": __props.autosize
              }],
              ref_key: "textarea",
              ref: textarea,
              rows: rows.value,
              style: computedStyle.value,
              loading: unref103(isLoading),
              ariaLabel: _ctx.$props.label
            }), null, 16, _hoisted_171), [
              [vModelText2, unref103(valueComputed)]
            ])
          ], 2)
        ]),
        _: 1
      }, 16, ["error", "error-messages"]);
    };
  }
});

// node_modules/vuestic-ui/dist/es/src/components/va-textarea/index.js
var VaTextarea = withConfigTransport(_sfc_main120);

// node_modules/vuestic-ui/dist/es/src/components/va-menu/VaMenu.vue_vue_type_script_setup_true_lang.js
import { defineComponent as defineComponent122, ref as ref85, openBlock as openBlock117, createBlock as createBlock64, unref as unref106, mergeProps as mergeProps56, withCtx as withCtx63, renderSlot as renderSlot97, createVNode as createVNode48, withKeys as withKeys33, withModifiers as withModifiers26, createSlots as createSlots11, nextTick as nextTick17 } from "vue";

// node_modules/vuestic-ui/dist/es/src/components/va-menu-list/VaMenuList.vue_vue_type_script_setup_true_lang.js
import { defineComponent as defineComponent121, ref as ref84, computed as computed188, openBlock as openBlock116, createElementBlock as createElementBlock99, mergeProps as mergeProps55, unref as unref105, createElementVNode as createElementVNode58, Fragment as Fragment39, renderList as renderList31, createBlock as createBlock63, resolveDynamicComponent as resolveDynamicComponent12, renderSlot as renderSlot96, createVNode as createVNode47, createCommentVNode as createCommentVNode58, withCtx as withCtx62, normalizeProps as normalizeProps43, guardReactiveProps as guardReactiveProps38 } from "vue";

// node_modules/vuestic-ui/dist/es/src/components/va-menu-list/components/VaMenuItem.vue_vue_type_script_setup_true_lang.js
import { defineComponent as defineComponent119, openBlock as openBlock114, createElementBlock as createElementBlock97, mergeProps as mergeProps54, unref as unref104, toHandlers as toHandlers9, withKeys as withKeys32, createElementVNode as createElementVNode56, renderSlot as renderSlot94, createBlock as createBlock62, createCommentVNode as createCommentVNode57, toDisplayString as toDisplayString43 } from "vue";

// node_modules/vuestic-ui/dist/es/src/components/va-menu-list/composables/useMenuKeyboardNavigation.js
var NON_DISABLED_MENU_ITEM_SELECTOR = '[role="menuitem"]:not([aria-disabled="true"])';
var FOCUSED_MENU_ITEM_SELECTOR = '[role="menuitem"]:focus';
var makeMenuItemAttributes = (options) => ({
  role: "menuitem",
  tabindex: -1,
  "aria-disabled": Boolean(options.disabled)
});
var makeMenuContainerAttributes = () => ({
  role: "menu",
  tabindex: 0
});
var useMenuKeyboardNavigation = (container) => {
  useEvent("keydown", ({ key }) => {
    if (!container.value) {
      return;
    }
    const items2 = container.value.querySelectorAll(NON_DISABLED_MENU_ITEM_SELECTOR);
    const focusedItem = container.value.querySelector(FOCUSED_MENU_ITEM_SELECTOR);
    if (!items2.length) {
      return;
    }
    if (!focusedItem) {
      const firstItem = container.value.querySelector(NON_DISABLED_MENU_ITEM_SELECTOR);
      if (firstItem) {
        focusElement(firstItem);
      }
      return;
    }
    if (key === "ArrowDown" || key === "ArrowRight") {
      const focusedElementIndex = Array.from(items2).indexOf(focusedItem);
      focusElement(items2[focusedElementIndex + 1]);
    }
    if (key === "ArrowUp" || key === "ArrowLeft") {
      const focusedElementIndex = Array.from(items2).indexOf(focusedItem);
      focusElement(items2[focusedElementIndex - 1]);
    }
  }, container);
};

// node_modules/vuestic-ui/dist/es/src/components/va-menu-list/components/VaMenuItem.vue_vue_type_script_setup_true_lang.js
import "D:/Desktop/forntend/Front_End_Web_Hotel_Nhom_2/my-nuxt-app/node_modules/vuestic-ui/dist/es/VaMenuItem.css";
var _hoisted_172 = { class: "va-menu-item__cell va-menu-item__cell--left" };
var _hoisted_234 = { class: "va-menu-item__cell va-menu-item__cell--center" };
var _hoisted_323 = { class: "va-menu-item__content" };
var _hoisted_414 = { class: "va-menu-item__cell va-menu-item__cell--right" };
var _sfc_main121 = defineComponent119({
  ...{
    name: "VaMenuItem"
  },
  __name: "VaMenuItem",
  props: {
    name: { type: String, default: "" },
    icon: { type: String, defatult: "" },
    rightIcon: { type: String, defatult: "" },
    disabled: { type: Boolean, default: false }
  },
  emits: ["selected"],
  setup(__props, { emit: __emit }) {
    const { hasKeyboardFocus, keyboardFocusListeners } = useKeyboardOnlyFocusGlobal();
    return (_ctx, _cache) => {
      return openBlock114(), createElementBlock97("tr", mergeProps54({ class: "va-menu-item" }, unref104(makeMenuItemAttributes)({ disabled: __props.disabled }), toHandlers9(unref104(keyboardFocusListeners), true), {
        class: {
          "va-menu-item--disabled": __props.disabled,
          "va-menu-item--keyboard-focus": unref104(hasKeyboardFocus)
        },
        onClick: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("selected")),
        onKeydown: _cache[1] || (_cache[1] = withKeys32(($event) => _ctx.$emit("selected"), ["enter", "space"]))
      }), [
        createElementVNode56("td", _hoisted_172, [
          renderSlot94(_ctx.$slots, "left-icon", {}, () => [
            __props.icon ? (openBlock114(), createBlock62(unref104(VaIcon), {
              key: 0,
              class: "va-menu-item__icon--left",
              name: __props.icon
            }, null, 8, ["name"])) : createCommentVNode57("", true)
          ])
        ]),
        createElementVNode56("td", _hoisted_234, [
          renderSlot94(_ctx.$slots, "default", {}, () => [
            createElementVNode56("a", _hoisted_323, toDisplayString43(__props.name), 1)
          ])
        ]),
        createElementVNode56("td", _hoisted_414, [
          renderSlot94(_ctx.$slots, "right-icon", {}, () => [
            __props.rightIcon ? (openBlock114(), createBlock62(unref104(VaIcon), {
              key: 0,
              class: "va-menu-item__icon--right",
              name: __props.rightIcon
            }, null, 8, ["name"])) : createCommentVNode57("", true)
          ])
        ])
      ], 16);
    };
  }
});

// node_modules/vuestic-ui/dist/es/src/components/va-menu-list/components/VaMenuGroup.vue_vue_type_script_setup_true_lang.js
import { defineComponent as defineComponent120, computed as computed187, openBlock as openBlock115, createElementBlock as createElementBlock98, Fragment as Fragment38, createElementVNode as createElementVNode57, normalizeStyle as normalizeStyle57, toDisplayString as toDisplayString44, renderSlot as renderSlot95 } from "vue";
import "D:/Desktop/forntend/Front_End_Web_Hotel_Nhom_2/my-nuxt-app/node_modules/vuestic-ui/dist/es/VaMenuGroup.css";
var _hoisted_173 = { class: "va-menu-list__group-name" };
var _sfc_main122 = defineComponent120({
  ...{
    name: "VaMenuGroup"
  },
  __name: "VaMenuGroup",
  props: {
    groupName: {
      type: String,
      required: true
    },
    color: {
      type: String,
      default: "secondary"
    }
  },
  setup(__props) {
    const props = __props;
    const { getColor } = useColors();
    const colorComputed = computed187(() => getColor(props.color));
    return (_ctx, _cache) => {
      return openBlock115(), createElementBlock98(Fragment38, null, [
        createElementVNode57("div", {
          class: "va-menu-list__group-name-wrapper",
          colspan: "99999",
          style: normalizeStyle57(`--va-color-computed: ${String(colorComputed.value)}`)
        }, [
          createElementVNode57("span", _hoisted_173, toDisplayString44(__props.groupName), 1)
        ], 4),
        renderSlot95(_ctx.$slots, "default", {
          style: normalizeStyle57(`--va-color-computed: ${String(colorComputed.value)}`)
        }, void 0, true)
      ], 64);
    };
  }
});

// node_modules/vuestic-ui/dist/es/src/components/va-menu-list/components/VaMenuGroup.js
import "D:/Desktop/forntend/Front_End_Web_Hotel_Nhom_2/my-nuxt-app/node_modules/vuestic-ui/dist/es/VaMenuGroup.css";
var _VaMenuGroup = _export_sfc(_sfc_main122, [["__scopeId", "data-v-4dd1ae9a"]]);

// node_modules/vuestic-ui/dist/es/src/components/va-menu-list/VaMenuList.vue_vue_type_script_setup_true_lang.js
import "D:/Desktop/forntend/Front_End_Web_Hotel_Nhom_2/my-nuxt-app/node_modules/vuestic-ui/dist/es/VaMenuList.css";
var _hoisted_174 = { colspan: "9999" };
var _sfc_main123 = defineComponent121({
  ...{
    name: "VaMenuList"
  },
  __name: "VaMenuList",
  props: {
    ...useSelectableListProps,
    options: { type: Array, default: () => [] }
  },
  emits: ["selected"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const container = ref84();
    useMenuKeyboardNavigation(container);
    const { getText, getValue, getDisabled, getGroupBy, getTrackBy } = useSelectableList(props);
    const optionGroups = computed188(() => props.options.reduce((groups, option) => {
      const groupBy = getGroupBy(option);
      if (!groupBy) {
        groups._noGroup.push(option);
      } else {
        if (!groups[groupBy]) {
          groups[groupBy] = [];
        }
        groups[groupBy].push(option);
      }
      return groups;
    }, { _noGroup: [] }));
    const getUnSlottedVNodes = (nodes) => {
      if (Array.isArray(nodes) && nodes[0].type === Fragment39) {
        return nodes[0].children;
      }
      return nodes;
    };
    const getVNodeComponentName = (node) => {
      if (typeof node.type === "object" && "name" in node.type && typeof node.type.name === "string") {
        return node.type.name;
      }
      return "";
    };
    const getVNodeKey = (node) => {
      if (typeof node.type === "string") {
        return node.type;
      }
      if (typeof node.type === "object" && "name" in node.type && typeof node.type.name === "string") {
        return node.type.name;
      }
      return String(node.key);
    };
    return (_ctx, _cache) => {
      return openBlock116(), createElementBlock99("table", mergeProps55({
        class: "va-menu-list",
        ref_key: "container",
        ref: container
      }, unref105(makeMenuContainerAttributes)()), [
        createElementVNode58("tbody", null, [
          _ctx.$slots.default ? (openBlock116(true), createElementBlock99(Fragment39, { key: 0 }, renderList31(getUnSlottedVNodes(_ctx.$slots.default()), (child) => {
            return openBlock116(), createElementBlock99(Fragment39, null, [
              getVNodeComponentName(child) === "VaMenuItem" ? (openBlock116(), createBlock63(resolveDynamicComponent12(child), {
                key: getVNodeKey(child) + "menuitem"
              })) : getVNodeComponentName(child) === "VaDropdown" ? (openBlock116(), createBlock63(resolveDynamicComponent12(child), {
                key: getVNodeKey(child) + "menu-dropdown"
              })) : (openBlock116(), createElementBlock99("td", {
                colspan: "999",
                key: getVNodeKey(child),
                class: "va-menu-list__virtual-td"
              }, [
                (openBlock116(), createBlock63(resolveDynamicComponent12(child)))
              ]))
            ], 64);
          }), 256)) : renderSlot96(_ctx.$slots, "default", { key: 1 }, () => [
            (openBlock116(true), createElementBlock99(Fragment39, null, renderList31(optionGroups.value, (options, groupName) => {
              return openBlock116(), createElementBlock99(Fragment39, { key: groupName }, [
                groupName !== "_noGroup" ? renderSlot96(_ctx.$slots, "group", { key: 0 }, () => [
                  createElementVNode58("tr", null, [
                    createElementVNode58("td", _hoisted_174, [
                      createVNode47(_VaMenuGroup, { "group-name": groupName }, null, 8, ["group-name"])
                    ])
                  ])
                ]) : createCommentVNode58("", true),
                (openBlock116(true), createElementBlock99(Fragment39, null, renderList31(options, (option) => {
                  return openBlock116(), createBlock63(_sfc_main121, {
                    key: unref105(getTrackBy)(option),
                    name: unref105(getText)(option),
                    icon: option.icon,
                    "right-icon": option.rightIcon,
                    disabled: unref105(getDisabled)(option),
                    onSelected: ($event) => _ctx.$emit("selected", unref105(getValue)(option), option)
                  }, {
                    "left-icon": withCtx62((bind) => [
                      renderSlot96(_ctx.$slots, "left-icon", normalizeProps43(guardReactiveProps38(bind)))
                    ]),
                    "right-icon": withCtx62((bind) => [
                      renderSlot96(_ctx.$slots, "right-icon", normalizeProps43(guardReactiveProps38(bind)))
                    ]),
                    _: 2
                  }, 1032, ["name", "icon", "right-icon", "disabled", "onSelected"]);
                }), 128))
              ], 64);
            }), 128))
          ])
        ])
      ], 16);
    };
  }
});

// node_modules/vuestic-ui/dist/es/src/components/va-menu-list/index.js
var VaMenuList = withConfigTransport(_sfc_main123);
var VaMenuItem = withConfigTransport(_sfc_main121);
var VaMenuGroup = withConfigTransport(_VaMenuGroup);

// node_modules/vuestic-ui/dist/es/src/composables/useImmediateFocus.js
import { watchEffect as watchEffect13, nextTick as nextTick16 } from "vue";
var useImmediateFocus = (el) => {
  watchEffect13(() => {
    if (el.value) {
      nextTick16(() => {
        focusElement(unwrapEl(el.value));
      });
    }
  });
};

// node_modules/vuestic-ui/dist/es/src/components/va-menu/VaMenu.vue_vue_type_script_setup_true_lang.js
var VaMenuListProps = extractComponentProps(VaMenuList);
var VaMenuListEmits = extractComponentEmits(VaMenuList);
var VaDropdownProps4 = extractComponentProps(VaDropdown);
var VaDropdownEmits = extractComponentEmits(VaDropdown);
var _sfc_main124 = defineComponent122({
  ...{
    name: "VaMenu"
  },
  __name: "VaMenu",
  props: {
    ...useComponentPresetProp,
    ...VaMenuListProps,
    ...VaDropdownProps4,
    stickToEdges: { type: Boolean, default: true }
  },
  emits: [
    ...VaDropdownEmits,
    ...VaMenuListEmits
  ],
  setup(__props, { expose: __expose, emit: __emit }) {
    const menuList = ref85();
    const dropdown = ref85();
    useImmediateFocus(menuList);
    const close = () => {
      var _a2;
      (_a2 = dropdown.value) == null ? void 0 : _a2.hide();
      nextTick17(() => {
        var _a22;
        const el = unwrapEl((_a22 = dropdown.value) == null ? void 0 : _a22.anchorRef);
        if (el) {
          focusFirstFocusableChild(el);
        }
      });
    };
    const onKeydown = (event) => {
      if (event.key === "Escape") {
        close();
      }
      if (event.key === "ArrowDown" || event.key === "ArrowUp") {
        event.preventDefault();
      }
    };
    const menuListProps = filterComponentProps(VaMenuListProps);
    const dropdownProps = filterComponentProps(VaDropdownProps4);
    __expose({
      close
    });
    return (_ctx, _cache) => {
      return openBlock117(), createBlock64(unref106(VaDropdown), mergeProps56(unref106(dropdownProps), {
        ref_key: "dropdown",
        ref: dropdown
      }), {
        anchor: withCtx63(() => [
          renderSlot97(_ctx.$slots, "anchor")
        ]),
        default: withCtx63(() => [
          createVNode48(unref106(VaDropdownContent), { onKeydown }, {
            default: withCtx63(() => [
              createVNode48(unref106(VaMenuList), mergeProps56({
                onKeydown: _cache[0] || (_cache[0] = withKeys33(withModifiers26(() => {
                }, ["prevent", "stop"]), ["enter", "space"]))
              }, unref106(menuListProps), {
                ref_key: "menuList",
                ref: menuList,
                onSelected: _cache[1] || (_cache[1] = ($event) => {
                  _ctx.$emit("selected", $event);
                  close();
                })
              }), createSlots11({ _: 2 }, [
                _ctx.$slots.default ? {
                  name: "default",
                  fn: withCtx63(() => [
                    renderSlot97(_ctx.$slots, "default")
                  ]),
                  key: "0"
                } : void 0
              ]), 1040)
            ]),
            _: 3
          })
        ]),
        _: 3
      }, 16);
    };
  }
});

// node_modules/vuestic-ui/dist/es/src/components/va-menu/va-menu.js
var VaMenu = withConfigTransport(_sfc_main124);

// node_modules/vuestic-ui/dist/es/src/components/va-form-field/VaFormField.vue_vue_type_script_setup_true_lang.js
import { defineComponent as defineComponent123, mergeDefaults, computed as computed189, ref as ref86, watchEffect as watchEffect14, openBlock as openBlock118, createBlock as createBlock65, unref as unref107, createSlots as createSlots12, withCtx as withCtx64, renderSlot as renderSlot98, normalizeProps as normalizeProps44, guardReactiveProps as guardReactiveProps39, renderList as renderList32 } from "vue";

// node_modules/vuestic-ui/dist/es/src/composables/useValidation.props.js
var validationPropsDefaults = {
  rules: () => [],
  dirty: false,
  errorCount: 1,
  success: false,
  messages: () => [],
  immediateValidation: false
};

// node_modules/vuestic-ui/dist/es/src/composables/useStateful.props.js
var statefulPropsDefaults = {
  stateful: false
};

// node_modules/vuestic-ui/dist/es/src/components/va-form-field/VaFormField.vue_vue_type_script_setup_true_lang.js
var _sfc_main125 = defineComponent123({
  __name: "VaFormField",
  props: mergeDefaults({
    stateful: { type: Boolean },
    modelValue: {},
    name: {},
    rules: {},
    dirty: { type: Boolean },
    error: { type: Boolean },
    errorMessages: {},
    errorCount: {},
    success: { type: Boolean },
    messages: {},
    immediateValidation: { type: Boolean },
    clearValue: {}
  }, {
    ...statefulPropsDefaults,
    ...validationPropsDefaults
  }),
  emits: ["update:error", "update:errorMessages", "update:dirty", "update:modelValue"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const { valueComputed } = useStateful(props, emit, "modelValue");
    const reset = () => {
      valueComputed.value = props.clearValue;
    };
    const focus = () => {
    };
    const {
      computedError,
      computedErrorMessages,
      validate,
      isDirty,
      isLoading,
      isValid,
      resetValidation,
      validationAriaAttributes,
      listeners
    } = useValidation(props, emit, {
      reset,
      focus,
      value: valueComputed
    });
    const messagesComputed = computed189(() => computedError.value ? computedErrorMessages.value : props.messages);
    const messagesColor = computed189(() => {
      if (!isValid.value) {
        return "danger";
      }
      if (props.success) {
        return "success";
      }
      return "";
    });
    const errorLimit = computed189(() => props.error ? Number(props.errorCount) : 99);
    const innerValue = ref86(valueComputed.value);
    watchEffect14(() => {
      innerValue.value = valueComputed.value;
    });
    const makeSlotRef = () => {
      return new Proxy(innerValue, {
        get(v, key) {
          if (key === "ref") {
            return innerValue.value;
          }
          return Reflect.get(v, key);
        },
        set(_, key, value) {
          if (key === "ref") {
            innerValue.value = value;
            valueComputed.value = value;
            return true;
          }
          return Reflect.set(valueComputed, key, value);
        }
      });
    };
    return (_ctx, _cache) => {
      return openBlock118(), createBlock65(unref107(VaMessageList), {
        "model-value": messagesComputed.value,
        "has-error": !unref107(isValid),
        color: messagesColor.value,
        limit: errorLimit.value
      }, createSlots12({
        default: withCtx64(({ ariaAttributes, attrs }) => [
          renderSlot98(_ctx.$slots, "default", normalizeProps44(guardReactiveProps39({
            error: unref107(computedError),
            errorMessages: messagesComputed.value,
            messages: messagesComputed.value,
            validate: unref107(validate),
            isDirty: unref107(isDirty),
            isLoading: unref107(isLoading),
            isValid: unref107(isValid),
            resetValidation: unref107(resetValidation),
            validationAriaAttributes: unref107(validationAriaAttributes),
            ...unref107(listeners),
            value: makeSlotRef(),
            modelValue: makeSlotRef(),
            ariaAttributes,
            bind: {
              ...attrs,
              ...ariaAttributes,
              ...unref107(listeners)
            }
          })))
        ]),
        _: 2
      }, [
        renderList32(["message", "messages"], (name) => {
          return {
            name,
            fn: withCtx64((slotScope) => [
              renderSlot98(_ctx.$slots, name, normalizeProps44(guardReactiveProps39(slotScope)))
            ])
          };
        })
      ]), 1032, ["model-value", "has-error", "color", "limit"]);
    };
  }
});

// node_modules/vuestic-ui/dist/es/src/components/va-form-field/index.js
var VaFormField = withConfigTransport(_sfc_main125);

// node_modules/vuestic-ui/dist/es/src/services/vue-plugin/components.js
var vuesticComponents = Object.freeze(Object.defineProperty({
  __proto__: null,
  VaAccordion,
  VaAffix,
  VaAlert,
  VaAppBar,
  VaAspectRatio,
  VaAvatar,
  VaAvatarGroup,
  VaBacktop,
  VaBadge,
  VaBreadcrumbs,
  VaBreadcrumbsItem,
  VaButton,
  VaButtonDropdown,
  VaButtonGroup,
  VaButtonToggle,
  VaCard,
  VaCardActions,
  VaCardBlock,
  VaCardContent,
  VaCardTitle,
  VaCarousel,
  VaCheckbox,
  VaChip,
  VaCollapse,
  VaColorIndicator,
  VaColorInput,
  VaColorPalette,
  VaConfig: _sfc_main4,
  VaContent,
  VaCounter,
  VaDataTable,
  VaDateInput,
  VaDatePicker,
  VaDivider,
  VaDropdown,
  VaDropdownContent,
  VaFallback,
  VaFileUpload,
  VaForm,
  VaFormField,
  VaHover,
  VaIcon,
  VaImage,
  VaInfiniteScroll,
  VaInnerLoading,
  VaInput,
  VaInputWrapper,
  VaLayout,
  VaList,
  VaListItem,
  VaListItemLabel,
  VaListItemSection,
  VaListLabel,
  VaListSeparator,
  VaMenu,
  VaMenuGroup,
  VaMenuItem,
  VaMenuList,
  VaMessageList,
  VaModal,
  VaNavbar,
  VaNavbarItem,
  VaOptionList,
  VaPagination,
  VaParallax,
  VaPopover,
  VaProgressBar,
  VaProgressCircle,
  VaRadio,
  VaRating,
  VaScrollContainer,
  VaSelect,
  VaSeparator: _sfc_main5,
  VaSidebar,
  VaSidebarItem,
  VaSidebarItemContent,
  VaSidebarItemTitle,
  VaSkeleton,
  VaSkeletonGroup,
  VaSlider,
  VaSpacer: _sfc_main6,
  VaSplit,
  VaStepper,
  VaStickyScrollbar: _sfc_main7,
  VaSwitch,
  VaTab,
  VaTabs,
  VaTextarea,
  VaTimeInput,
  VaTimePicker,
  VaTimeline,
  VaTimelineItem,
  VaToast,
  VaTreeView,
  VaValue,
  VaViewer,
  VaVirtualScroller
}, Symbol.toStringTag, { value: "Module" }));

// node_modules/vuestic-ui/dist/es/src/services/vue-plugin/utils/use-plugin.js
var isPluginFabric = (plugin) => typeof plugin === "function";
var usePlugin = (app, plugin, ...options) => {
  if (isPluginFabric(plugin)) {
    app.use(plugin(...options));
  } else {
    app.use(plugin);
  }
};

// node_modules/vuestic-ui/dist/es/src/services/vue-plugin/create-vuestic/create-vuestic.js
var createVuestic = defineVuesticPlugin((options = {}) => ({
  install(app) {
    const { config } = options;
    setCurrentApp(app);
    Object.entries(vuesticComponents).forEach(([name, component]) => {
      app.component(name, component);
    });
    usePlugin(app, GlobalConfigPlugin(config));
    usePlugin(app, CachePlugin);
    usePlugin(app, ColorConfigPlugin(config));
    usePlugin(app, ColorsClassesPlugin);
    usePlugin(app, BreakpointConfigPlugin);
    usePlugin(app, VaDropdownPlugin);
    usePlugin(app, VaToastPlugin);
    usePlugin(app, VaModalPlugin);
    setCurrentApp(null);
  }
}));

// node_modules/vuestic-ui/dist/es/src/services/vue-plugin/create-vuestic/create-vuestic-essential.js
var ESSENTIAL_PLUGIN_NAMES = ["GlobalConfigPlugin", "ColorConfigPlugin"];
var createVuesticEssential = defineVuesticPlugin((options = {}) => ({
  install(app) {
    const { config, components, plugins } = options;
    setCurrentApp(app);
    usePlugin(app, (plugins == null ? void 0 : plugins.GlobalConfigPlugin) || GlobalConfigPlugin, config);
    usePlugin(app, (plugins == null ? void 0 : plugins.CachePlugin) || CachePlugin);
    usePlugin(app, (plugins == null ? void 0 : plugins.ColorConfigPlugin) || ColorConfigPlugin, config);
    if (plugins) {
      Object.entries(plugins).forEach(([name, plugin]) => {
        if (ESSENTIAL_PLUGIN_NAMES.includes(name)) {
          return;
        }
        usePlugin(app, plugin);
      });
    }
    if (components) {
      Object.entries(components).forEach(([name, component]) => {
        app.component(name, component);
      });
    }
    setCurrentApp(null);
  }
}));

// node_modules/vuestic-ui/dist/es/src/services/web-components/register-vuestic-web-components-essential.js
import { defineCustomElement } from "vue";
var componentsOrder = [
  "VaConfig",
  // VaConfig should be registered before any component, because it provides them config
  "VaForm",
  // VaForm registered before any component, but not before VaConfig
  "VaAccordion",
  "VaFileUpload",
  "VaSidebar",
  "VaTabs"
];
var registerVuesticWebComponentsEssential = (options) => {
  const { css, components } = options;
  Object.entries(components).sort(([nameA], [nameB]) => {
    if (!componentsOrder.includes(nameA) && !componentsOrder.includes(nameB)) {
      return 0;
    }
    let indexA = componentsOrder.indexOf(nameA);
    let indexB = componentsOrder.indexOf(nameB);
    if (indexA === -1) {
      indexA = Number.MAX_SAFE_INTEGER;
    }
    if (indexB === -1) {
      indexB = Number.MAX_SAFE_INTEGER;
    }
    return indexA - indexB;
  }).forEach(([name, component]) => {
    const customElement = defineCustomElement(component);
    if (css && "styles" in component) {
      component.styles.push(css);
    }
    customElements.define(`${camelCaseToKebabCase(name)}`, customElement);
  });
};

// node_modules/vuestic-ui/dist/es/src/services/web-components/register-vuestic-web-components.js
var defaultCSS = `
.material-icons {
  font-family: 'Material Icons';
  font-weight: normal;
  font-style: normal;
  line-height: 1;
  letter-spacing: normal;
  text-transform: none;
  display: inline-block;
  white-space: nowrap;
  word-wrap: normal;
  direction: ltr;
  -webkit-font-smoothing: antialiased;
}`;
var registerVuesticWebComponents = (options = {}) => {
  const { css = defaultCSS } = options;
  registerVuesticWebComponentsEssential({
    css,
    components: vuesticComponents
  });
};

// node_modules/vuestic-ui/dist/es/src/components/va-data-table/fabrics.js
var defineVaDataTableColumns = (columns) => columns;
var defineVaDataTableItems = (items2) => items2;

// node_modules/vuestic-ui/dist/es/src/components/va-modal/hooks/useModal.js
import { getCurrentInstance as getCurrentInstance28 } from "vue";
var useModal = () => {
  var _a2;
  const appContext = (_a2 = getCurrentInstance28()) == null ? void 0 : _a2.appContext;
  if (!appContext) {
    throw new Error("useModal can be used only in setup function. You can use app.config.globalProperties.$vaModal outside setup function");
  }
  const init = (options) => {
    return createModalInstance(options, appContext);
  };
  const confirm = (options) => {
    if (typeof options === "string") {
      return new Promise((resolve, reject) => {
        createModalInstance({
          message: options,
          onOk() {
            resolve(true);
          },
          onCancel() {
            resolve(false);
          }
        }, appContext);
      });
    }
    return new Promise((resolve, reject) => {
      createModalInstance({
        ...options,
        onOk() {
          var _a22;
          (_a22 = options == null ? void 0 : options.onOk) == null ? void 0 : _a22.call(options);
          resolve(true);
        },
        onCancel() {
          var _a22;
          (_a22 = options == null ? void 0 : options.onCancel) == null ? void 0 : _a22.call(options);
          resolve(false);
        }
      }, appContext);
    });
  };
  return { init, confirm };
};

// node_modules/vuestic-ui/dist/es/src/components/va-rating/components/VaRatingItem/index.js
var VaRatingItem = withConfigTransport$1(_sfc_main88);

// node_modules/vuestic-ui/dist/es/src/composables/useAppContext.js
import { getCurrentInstance as getCurrentInstance29, computed as computed190 } from "vue";
var useAppContext = () => {
  const currentInstance = getCurrentInstance29();
  return computed190(() => {
    var _a2;
    return ((_a2 = getCurrentApp()) == null ? void 0 : _a2._context) || (currentInstance == null ? void 0 : currentInstance.appContext);
  });
};

// node_modules/vuestic-ui/dist/es/src/components/va-toast/hooks/useToast.js
var useToast = () => {
  const appContext = useAppContext();
  const createdInThisSetupContext = [];
  const notify = (options) => {
    const id = createToastInstance(options, appContext.value);
    if (id) {
      createdInThisSetupContext.push(id);
    }
    return id;
  };
  const init = (options) => {
    return notify(options);
  };
  const close = (id) => closeById(id);
  const closeAll = (allApps = false) => closeAllNotifications(allApps ? void 0 : appContext.value);
  const closeAllCreatedInThisHook = () => {
    createdInThisSetupContext.forEach((id) => closeById(id));
  };
  return {
    init,
    notify,
    close,
    closeAll,
    closeAllCreatedInThisHook
  };
};

// node_modules/vuestic-ui/dist/es/src/composables/useMount.js
import { getCurrentInstance as getCurrentInstance30, nextTick as nextTick18, render as render3, h as h14 } from "vue";
var destroy3 = (el, vNode) => {
  if (el) {
    render3(null, el);
    el.remove();
  }
  el = null;
};
var mount3 = (component, { props, appContext } = {}) => {
  const el = document == null ? void 0 : document.createElement("div");
  document.body.appendChild(el);
  const vNode = h14(component, {
    ...props,
    stateful: (props == null ? void 0 : props.stateful) ?? true
  });
  if (appContext) {
    vNode.appContext = appContext;
  }
  if (el) {
    render3(vNode, el);
  }
  return { vNode, el };
};
var useMount = (component) => {
  var _a2;
  const appContext = (_a2 = getCurrentInstance30()) == null ? void 0 : _a2.appContext;
  if (!appContext) {
    throw new Error("useMount can be used only in setup function");
  }
  const createInstance2 = (props) => {
    const { vNode, el } = mount3(component, { props, appContext });
    return () => {
      nextTick18(() => {
        destroy3(el);
      });
    };
  };
  return {
    createInstance: createInstance2
  };
};

// node_modules/vuestic-ui/dist/es/src/components/va-menu/hooks/useMenu.js
import { onBeforeUnmount as onBeforeUnmount24 } from "vue";
var useMenu = () => {
  const { createInstance: createInstance2 } = useMount(VaMenu);
  const instances = [];
  const destroyAll = () => instances.forEach((destroy4) => destroy4());
  const show = (props) => {
    destroyAll();
    props.event.preventDefault();
    const destroy4 = createInstance2({
      ...props,
      anchor: props.event.target,
      cursor: {
        getBoundingClientRect() {
          const resX = props.event.clientX;
          const resY = props.event.clientY;
          return {
            width: 0,
            height: 0,
            x: resX,
            y: resY,
            top: resY,
            right: resX,
            bottom: resY,
            left: resX
          };
        },
        contextElement: props.event.target
      },
      stateful: true,
      modelValue: true,
      preset: "context",
      onBeforeUnmount: () => {
        destroy4();
      }
    });
    instances.push(destroy4);
    return () => {
      destroy4();
      instances.splice(instances.indexOf(destroy4), 1);
    };
  };
  onBeforeUnmount24(destroyAll);
  return {
    show
  };
};
export {
  BreakpointConfigPlugin,
  CachePlugin,
  ColorConfigPlugin,
  ColorsClassesPlugin,
  GlobalConfigPlugin,
  TabsViewKey,
  VaAccordion,
  VaAffix,
  VaAlert,
  VaAppBar,
  VaAspectRatio,
  VaAvatar,
  VaAvatarGroup,
  VaBacktop,
  VaBadge,
  VaBreadcrumbs,
  VaBreadcrumbsItem,
  VaButton,
  VaButtonDropdown,
  VaButtonGroup,
  VaButtonToggle,
  VaCard,
  VaCardActions,
  VaCardBlock,
  VaCardContent,
  VaCardTitle,
  VaCarousel,
  VaCheckbox,
  VaChip,
  VaCollapse,
  VaColorIndicator,
  VaColorInput,
  VaColorPalette,
  _sfc_main4 as VaConfig,
  VaContent,
  VaCounter,
  VaDataTable,
  VaDateInput,
  VaDatePicker,
  VaDivider,
  VaDropdown,
  VaDropdownContent,
  VaDropdownPlugin,
  VaFallback,
  VaFileUpload,
  VaFileUploadGalleryItem,
  VaFileUploadKey,
  VaFileUploadList,
  VaFileUploadListItem,
  VaFileUploadSingleItem,
  VaFileUploadUndo,
  VaForm,
  VaFormField,
  VaHover,
  VaIcon,
  VaImage,
  VaInfiniteScroll,
  VaInnerLoading,
  VaInput,
  VaInputWrapper,
  VaLayout,
  VaList,
  VaListItem,
  VaListItemLabel,
  VaListItemSection,
  VaListLabel,
  VaListSeparator,
  VaMenu,
  VaMenuGroup,
  VaMenuItem,
  VaMenuList,
  VaMessageList,
  _sfc_main3 as VaMessageListWrapper,
  VaModal,
  VaModalPlugin,
  VaNavbar,
  VaNavbarItem,
  VaOptionList,
  VaPagination,
  VaParallax,
  VaPopover,
  VaProgressBar,
  VaProgressCircle,
  VaRadio,
  VaRating,
  VaRatingItem,
  VaScrollContainer,
  VaSelect,
  VaSelectOption,
  VaSelectOptionList,
  _sfc_main5 as VaSeparator,
  VaSidebar,
  VaSidebarItem,
  VaSidebarItemContent,
  VaSidebarItemTitle,
  VaSkeleton,
  VaSkeletonGroup,
  VaSlider,
  _sfc_main6 as VaSpacer,
  VaSplit,
  VaStepper,
  _sfc_main7 as VaStickyScrollbar,
  VaSwitch,
  VaTab,
  VaTabs,
  VaTextarea,
  VaTimeInput,
  VaTimePicker,
  VaTimeline,
  VaTimelineItem,
  VaTimelineSeparator,
  VaToast,
  VaToastPlugin,
  VaTreeView,
  VaValue,
  VaViewer,
  VaVirtualScroller,
  VuesticIconAliases,
  VuesticIconFonts,
  presets as colorsPreset,
  compareWithMask,
  createDateMask,
  createIconsConfig,
  createNumeralMask,
  createRegexMask,
  createVuestic,
  createVuesticEssential,
  defineVaDataTableColumns,
  defineVaDataTableItems,
  defineVaStepperSteps,
  defineVuesticConfig,
  registerVuesticWebComponents,
  registerVuesticWebComponentsEssential,
  defaultThresholds as thresholdsPreset,
  useBreakpoint,
  useColors,
  useElementTextColor,
  useForm,
  useGlobalConfig,
  useI18nConfig,
  useIcon as useIcons,
  useInputMask,
  useMenu,
  useModal,
  useStickyTableHeaders,
  useToast
};
//# sourceMappingURL=vuestic-ui.js.map
