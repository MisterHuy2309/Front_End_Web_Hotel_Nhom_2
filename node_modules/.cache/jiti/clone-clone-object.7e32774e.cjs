"use strict";Object.defineProperty(exports, "__esModule", { value: true });exports.default = void 0;var _path = _interopRequireDefault(require("../../path.js"));
var _isArray = _interopRequireDefault(require("../../is-array.js"));
var _isObject = _interopRequireDefault(require("../../is-object.js"));
var _array = require("../methods/array.js");
var _set = require("../methods/set.js");
var _map = require("../methods/map.js");
var _object = require("../methods/object.js");function _interopRequireDefault(e) {return e && e.__esModule ? e : { default: e };}

class CloneObject {
  constructor(value, path, argumentsList, hasOnValidate) {
    this._path = path;
    this._isChanged = false;
    this._clonedCache = new Set();
    this._hasOnValidate = hasOnValidate;
    this._changes = hasOnValidate ? [] : null;

    this.clone = path === undefined ? value : this._shallowClone(value);
  }

  static isHandledMethod(name) {
    return _object.IMMUTABLE_OBJECT_METHODS.has(name);
  }

  _shallowClone(value) {
    let clone = value;

    if ((0, _isObject.default)(value)) {
      clone = { ...value };
    } else if ((0, _isArray.default)(value) || ArrayBuffer.isView(value)) {
      clone = [...value];
    } else if (value instanceof Date) {
      clone = new Date(value);
    } else if (value instanceof Set) {
      clone = new Set([...value].map((item) => this._shallowClone(item)));
    } else if (value instanceof Map) {
      clone = new Map();

      for (const [key, item] of value.entries()) {
        clone.set(key, this._shallowClone(item));
      }
    }

    this._clonedCache.add(clone);

    return clone;
  }

  preferredThisArg(isHandledMethod, name, thisArgument, thisProxyTarget) {
    if (isHandledMethod) {
      if ((0, _isArray.default)(thisProxyTarget)) {
        this._onIsChanged = _array.MUTABLE_ARRAY_METHODS[name];
      } else if (thisProxyTarget instanceof Set) {
        this._onIsChanged = _set.MUTABLE_SET_METHODS[name];
      } else if (thisProxyTarget instanceof Map) {
        this._onIsChanged = _map.MUTABLE_MAP_METHODS[name];
      }

      return thisProxyTarget;
    }

    return thisArgument;
  }

  update(fullPath, property, value) {
    const changePath = _path.default.after(fullPath, this._path);

    if (property !== 'length') {
      let object = this.clone;

      _path.default.walk(changePath, (key) => {
        if (object?.[key]) {
          if (!this._clonedCache.has(object[key])) {
            object[key] = this._shallowClone(object[key]);
          }

          object = object[key];
        }
      });

      if (this._hasOnValidate) {
        this._changes.push({
          path: changePath,
          property,
          previous: value
        });
      }

      if (object?.[property]) {
        object[property] = value;
      }
    }

    this._isChanged = true;
  }

  undo(object) {
    let change;

    for (let index = this._changes.length - 1; index !== -1; index--) {
      change = this._changes[index];

      _path.default.get(object, change.path)[change.property] = change.previous;
    }
  }

  isChanged(value) {
    return this._onIsChanged === undefined ?
    this._isChanged :
    this._onIsChanged(this.clone, value);
  }

  isPathApplicable(changePath) {
    return _path.default.isRootPath(this._path) || _path.default.isSubPath(changePath, this._path);
  }
}exports.default = CloneObject; /* v9-e62faf23bb6a9c3b */
