"use strict";Object.defineProperty(exports, "__esModule", { value: true });exports.default = void 0;
var _constants = require("./lib/constants.js");
var _isBuiltin = require("./lib/is-builtin.js");
var _path = _interopRequireDefault(require("./lib/path.js"));
var _isArray = _interopRequireDefault(require("./lib/is-array.js"));
var _isSymbol = _interopRequireDefault(require("./lib/is-symbol.js"));
var _isIterator = _interopRequireDefault(require("./lib/is-iterator.js"));
var _wrapIterator = _interopRequireDefault(require("./lib/wrap-iterator.js"));
var _ignoreProperty = _interopRequireDefault(require("./lib/ignore-property.js"));
var _cache = _interopRequireDefault(require("./lib/cache.js"));
var _smartClone = _interopRequireDefault(require("./lib/smart-clone/smart-clone.js"));function _interopRequireDefault(e) {return e && e.__esModule ? e : { default: e };} /* eslint-disable unicorn/prefer-spread */

const defaultOptions = {
  equals: Object.is,
  isShallow: false,
  pathAsArray: false,
  ignoreSymbols: false,
  ignoreUnderscores: false,
  ignoreDetached: false,
  details: false
};

const onChange = (object, onChange, options = {}) => {
  options = {
    ...defaultOptions,
    ...options
  };

  const proxyTarget = Symbol('ProxyTarget');
  const { equals, isShallow, ignoreDetached, details } = options;
  const cache = new _cache.default(equals);
  const hasOnValidate = typeof options.onValidate === 'function';
  const smartClone = new _smartClone.default(hasOnValidate);

  // eslint-disable-next-line max-params
  const validate = (target, property, value, previous, applyData) => !hasOnValidate ||
  smartClone.isCloning ||
  options.onValidate(_path.default.concat(cache.getPath(target), property), value, previous, applyData) === true;

  const handleChangeOnTarget = (target, property, value, previous) => {
    if (
    !(0, _ignoreProperty.default)(cache, options, property) &&
    !(ignoreDetached && cache.isDetached(target, object)))
    {
      handleChange(cache.getPath(target), property, value, previous);
    }
  };

  // eslint-disable-next-line max-params
  const handleChange = (changePath, property, value, previous, applyData) => {
    if (smartClone.isCloning && smartClone.isPartOfClone(changePath)) {
      smartClone.update(changePath, property, previous);
    } else {
      onChange(_path.default.concat(changePath, property), value, previous, applyData);
    }
  };

  const getProxyTarget = (value) => value ?
  value[proxyTarget] ?? value :
  value;

  const prepareValue = (value, target, property, basePath) => {
    if (
    (0, _isBuiltin.isBuiltinWithoutMutableMethods)(value) ||
    property === 'constructor' ||
    isShallow && !_smartClone.default.isHandledMethod(target, property) ||
    (0, _ignoreProperty.default)(cache, options, property) ||
    cache.isGetInvariant(target, property) ||
    ignoreDetached && cache.isDetached(target, object))
    {
      return value;
    }

    if (basePath === undefined) {
      basePath = cache.getPath(target);
    }

    /*
    		Check for circular references.
     		If the value already has a corresponding path/proxy,
    and if the path corresponds to one of the parents,
    then we are on a circular case, where the child is pointing to their parent.
    In this case we return the proxy object with the shortest path.
    		*/

    const childPath = _path.default.concat(basePath, property);
    const existingPath = cache.getPath(value);

    if (existingPath && isSameObjectTree(childPath, existingPath)) {
      // We are on the same object tree but deeper, so we use the parent path.
      return cache.getProxy(value, existingPath, handler, proxyTarget);
    }

    return cache.getProxy(value, childPath, handler, proxyTarget);
  };

  /*
  Returns true if `childPath` is a subpath of `existingPath`
  (if childPath starts with existingPath). Otherwise, it returns false.
   	It also returns false if the 2 paths are identical.
   	For example:
  - childPath    = group.layers.0.parent.layers.0.value
  - existingPath = group.layers.0.parent
  */


  const isSameObjectTree = (childPath, existingPath) => {
    if ((0, _isSymbol.default)(childPath) || childPath.length <= existingPath.length) {
      return false;
    }

    if ((0, _isArray.default)(existingPath) && existingPath.length === 0) {
      return false;
    }

    const childParts = (0, _isArray.default)(childPath) ? childPath : childPath.split(_constants.PATH_SEPARATOR);
    const existingParts = (0, _isArray.default)(existingPath) ? existingPath : existingPath.split(_constants.PATH_SEPARATOR);

    if (childParts.length <= existingParts.length) {
      return false;
    }

    return !existingParts.some((part, index) => part !== childParts[index]);
  };

  const handler = {
    get(target, property, receiver) {
      if ((0, _isSymbol.default)(property)) {
        if (property === proxyTarget || property === _constants.TARGET) {
          return target;
        }

        if (
        property === _constants.UNSUBSCRIBE &&
        !cache.isUnsubscribed &&
        cache.getPath(target).length === 0)
        {
          cache.unsubscribe();
          return target;
        }
      }

      const value = (0, _isBuiltin.isBuiltinWithMutableMethods)(target) ?
      Reflect.get(target, property) :
      Reflect.get(target, property, receiver);

      return prepareValue(value, target, property);
    },

    set(target, property, value, receiver) {
      value = getProxyTarget(value);

      const reflectTarget = target[proxyTarget] ?? target;
      const previous = reflectTarget[property];

      if (equals(previous, value) && property in target) {
        return true;
      }

      const isValid = validate(target, property, value, previous);

      if (
      isValid &&
      cache.setProperty(reflectTarget, property, value, receiver, previous))
      {
        handleChangeOnTarget(target, property, target[property], previous);

        return true;
      }

      return !isValid;
    },

    defineProperty(target, property, descriptor) {
      if (!cache.isSameDescriptor(descriptor, target, property)) {
        const previous = target[property];

        if (
        validate(target, property, descriptor.value, previous) &&
        cache.defineProperty(target, property, descriptor, previous))
        {
          handleChangeOnTarget(target, property, descriptor.value, previous);
        }
      }

      return true;
    },

    deleteProperty(target, property) {
      if (!Reflect.has(target, property)) {
        return true;
      }

      const previous = Reflect.get(target, property);
      const isValid = validate(target, property, undefined, previous);

      if (
      isValid &&
      cache.deleteProperty(target, property, previous))
      {
        handleChangeOnTarget(target, property, undefined, previous);

        return true;
      }

      return !isValid;
    },

    apply(target, thisArg, argumentsList) {
      const thisProxyTarget = thisArg[proxyTarget] ?? thisArg;

      if (cache.isUnsubscribed) {
        return Reflect.apply(target, thisProxyTarget, argumentsList);
      }

      if (
      (details === false ||
      details !== true && !details.includes(target.name)) &&
      _smartClone.default.isHandledType(thisProxyTarget))
      {
        let applyPath = _path.default.initial(cache.getPath(target));
        const isHandledMethod = _smartClone.default.isHandledMethod(thisProxyTarget, target.name);

        smartClone.start(thisProxyTarget, applyPath, argumentsList);

        let result = Reflect.apply(
          target,
          smartClone.preferredThisArg(target, thisArg, thisProxyTarget),
          isHandledMethod ?
          argumentsList.map((argument) => getProxyTarget(argument)) :
          argumentsList
        );

        const isChanged = smartClone.isChanged(thisProxyTarget, equals);
        const previous = smartClone.stop();

        if (_smartClone.default.isHandledType(result) && isHandledMethod) {
          if (thisArg instanceof Map && target.name === 'get') {
            applyPath = _path.default.concat(applyPath, argumentsList[0]);
          }

          result = cache.getProxy(result, applyPath, handler);
        }

        if (isChanged) {
          const applyData = {
            name: target.name,
            args: argumentsList,
            result
          };
          const changePath = smartClone.isCloning ?
          _path.default.initial(applyPath) :
          applyPath;
          const property = smartClone.isCloning ?
          _path.default.last(applyPath) :
          '';

          if (validate(_path.default.get(object, changePath), property, thisProxyTarget, previous, applyData)) {
            handleChange(changePath, property, thisProxyTarget, previous, applyData);
          } else {
            smartClone.undo(thisProxyTarget);
          }
        }

        if (
        (thisArg instanceof Map || thisArg instanceof Set) &&
        (0, _isIterator.default)(result))
        {
          return (0, _wrapIterator.default)(result, target, thisArg, applyPath, prepareValue);
        }

        return result;
      }

      return Reflect.apply(target, thisArg, argumentsList);
    }
  };

  const proxy = cache.getProxy(object, options.pathAsArray ? [] : '', handler);
  onChange = onChange.bind(proxy);

  if (hasOnValidate) {
    options.onValidate = options.onValidate.bind(proxy);
  }

  return proxy;
};

onChange.target = (proxy) => proxy?.[_constants.TARGET] ?? proxy;
onChange.unsubscribe = (proxy) => proxy?.[_constants.UNSUBSCRIBE] ?? proxy;var _default = exports.default =

onChange; /* v9-dc2bc76682172ec3 */
