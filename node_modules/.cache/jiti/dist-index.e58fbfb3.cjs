"use strict";Object.defineProperty(exports, "__esModule", { value: true });Object.defineProperty(exports, "SUPPORTED_EXTENSIONS", { enumerable: true, get: function () {return _c12CEGFwQZa.S;} });exports.createDefineConfig = createDefineConfig;Object.defineProperty(exports, "loadConfig", { enumerable: true, get: function () {return _c12CEGFwQZa.l;} });Object.defineProperty(exports, "loadDotenv", { enumerable: true, get: function () {return _c12CEGFwQZa.a;} });Object.defineProperty(exports, "setupDotenv", { enumerable: true, get: function () {return _c12CEGFwQZa.s;} });exports.watchConfig = watchConfig;var _c12CEGFwQZa = require("./shared/c12.CEGFwQZa.mjs");

var _perfectDebounce = require("perfect-debounce");
var _pathe = require("pathe");
require("node:fs");
require("node:fs/promises");
require("node:url");
require("node:os");
require("exsolve");
require("jiti");
require("rc9");
require("defu");
require("pkg-types");
require("dotenv");function _getRequireWildcardCache(e) {if ("function" != typeof WeakMap) return null;var r = new WeakMap(),t = new WeakMap();return (_getRequireWildcardCache = function (e) {return e ? t : r;})(e);}function _interopRequireWildcard(e, r) {if (!r && e && e.__esModule) return e;if (null === e || "object" != typeof e && "function" != typeof e) return { default: e };var t = _getRequireWildcardCache(r);if (t && t.has(e)) return t.get(e);var n = { __proto__: null },a = Object.defineProperty && Object.getOwnPropertyDescriptor;for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) {var i = a ? Object.getOwnPropertyDescriptor(e, u) : null;i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u];}return n.default = e, t && t.set(e, n), n;}

function createDefineConfig() {
  return (input) => input;
}

const eventMap = {
  add: "created",
  change: "updated",
  unlink: "removed"
};
async function watchConfig(options) {
  let config = await (0, _c12CEGFwQZa.l)(options);
  const configName = options.name || "config";
  const configFileName = options.configFile ?? (options.name === "config" ? "config" : `${options.name}.config`);
  const watchingFiles = [
  ...new Set(
    (config.layers || []).filter((l) => l.cwd).flatMap((l) => [
    ..._c12CEGFwQZa.S.flatMap((ext) => [
    (0, _pathe.resolve)(l.cwd, configFileName + ext),
    (0, _pathe.resolve)(l.cwd, ".config", configFileName + ext),
    (0, _pathe.resolve)(
      l.cwd,
      ".config",
      configFileName.replace(/\.config$/, "") + ext
    )]
    ),
    l.source && (0, _pathe.resolve)(l.cwd, l.source),
    // TODO: Support watching rc from home and workspace
    options.rcFile && (0, _pathe.resolve)(
      l.cwd,
      typeof options.rcFile === "string" ? options.rcFile : `.${configName}rc`
    ),
    options.packageJson && (0, _pathe.resolve)(l.cwd, "package.json")]
    ).filter(Boolean)
  )];

  const watch = await Promise.resolve().then(() => jitiImport('chokidar').then((m) => _interopRequireWildcard(m))).then((r) => r.watch || r.default || r);
  const { diff } = await Promise.resolve().then(() => jitiImport('ohash/utils').then((m) => _interopRequireWildcard(m)));
  const _fswatcher = watch(watchingFiles, {
    ignoreInitial: true,
    ...options.chokidarOptions
  });
  const onChange = async (event, path) => {
    const type = eventMap[event];
    if (!type) {
      return;
    }
    if (options.onWatch) {
      await options.onWatch({
        type,
        path
      });
    }
    const oldConfig = config;
    const newConfig = await (0, _c12CEGFwQZa.l)(options);
    config = newConfig;
    const changeCtx = {
      newConfig,
      oldConfig,
      getDiff: () => diff(oldConfig.config, config.config)
    };
    if (options.acceptHMR) {
      const changeHandled = await options.acceptHMR(changeCtx);
      if (changeHandled) {
        return;
      }
    }
    if (options.onUpdate) {
      await options.onUpdate(changeCtx);
    }
  };
  if (options.debounce === false) {
    _fswatcher.on("all", onChange);
  } else {
    _fswatcher.on("all", (0, _perfectDebounce.debounce)(onChange, options.debounce ?? 100));
  }
  const utils = {
    watchingFiles,
    unwatch: async () => {
      await _fswatcher.close();
    }
  };
  return new Proxy(utils, {
    get(_, prop) {
      if (prop in utils) {
        return utils[prop];
      }
      return config[prop];
    }
  });
} /* v9-3e23d5d788c58752 */
